const e="import { Models } from '@buckdb/.buck/models'\nimport * as t from '.buck/types'\nimport { DuckdbCon } from '@buckdb/core'\nimport { DDirection } from './typedef'\nimport { CopyToInterface } from './copy'\nimport { FromPlainDict, ToPlain } from './deep-map'\nimport { Flatten, KeyIntersection, NestedKeyOf, PArray, PRecord, Primitive, TripleMerge } from './generic-utils'\nimport type { DeriveName } from './utils'\n\ntype TRessource = keyof Models | (string & {})\n\ntype StrictCollection = { catalog: string; uri: string; alias: string }\n// Utility type to merge two types into a frame object\n\ntype ModelForCollection<Mods extends Models, C extends StrictCollection> = C extends { catalog: infer R; uri: infer T } // Use uri T for lookup\n    ? R extends keyof Mods ? T extends keyof Mods[R] ? Mods[R][T] : T extends keyof Mods[''] ? Mods[''][T] : {} : {}\n    : {}\n\nexport const v__ = Symbol('alias')\n\ntype ShallowModel<T extends Record<string, any>> = {\n    [K in keyof T as T[K] extends Record<typeof v__, 1> ? never : K]: T[K]\n}\ninterface TFlag {\n    [v__]: never\n}\n\ntype MergedModel<Mods extends Models, C extends StrictCollection[]> =\n    C extends [infer F extends StrictCollection, ...infer Rest extends StrictCollection[]]\n    ? TripleMerge<{ [K in F['alias']]: TFlag & ModelForCollection<Mods, F> }, ModelForCollection<Mods, F>, MergedModel<Mods, Rest>>\n    : {} // Base case should be an empty object for merging\n// Recursive type to merge all models from collections, using alias as key\ntype ShallowMergedModel<Mods extends Models, C extends StrictCollection[]> = C extends [infer F extends StrictCollection, ...infer Rest extends StrictCollection[]] ? ModelForCollection<Mods, F> & MergedModel<Mods, Rest>\n    : {} // Base case should be an empty object for merging\n\ntype DRawField = t.DAnyField\n\ntype DPrimitiveField = t.DVarcharField | t.DNumericField | t.DDateField | t.DBoolField\ntype DNestedField = t.DArrayField | t.DStructField | t.DJsonField | t.DMapField\nexport type GField = DPrimitiveField | DNestedField | DRawField | t.DArrayField<DNestedField | DPrimitiveField>\n\ninterface GenericRecursive<T> {\n    [key: string]: T | GenericRecursive<T> | string | number | boolean | unknown\n}\nexport type SelectModel = GenericRecursive<GField>\nexport type MetaModel = GenericRecursive<GField>\n\ntype PrimitiveField<T> = T extends number ? t.DNumericField\n    : T extends string ? t.DVarcharField\n    : T extends boolean ? t.DBoolField\n    : t.DAnyField\n\nexport type VTypes = 'frame' | 'records' | 'values' | 'grouped' | 'keyed' | 'row'\n\n\ntype FnMap<A extends MetaModel, GF extends t.DMetaField, S extends SelectModel = {}, SV = []> = {\n    row: () => Promise<SV extends [] ? ToPlain<S> : ToPlain<SV>>\n    values: () => PArray<ToPlain<SV>>\n    records: () => PArray<ToPlain<S>>\n    grouped: () => PRecord<ToPlain<S>[]>\n    keyed: () => PRecord<ToPlain<S>>\n    frame: () => PArray<ToPlain<SV extends [infer F] ? F : any>>\n}\n\ntype MSR<A extends MetaModel, GF extends t.DMetaField, S extends SelectModel = {}, SV = []> = MS<'records', GF, A, S, SV>\ntype MSV<A extends MetaModel, GF extends t.DMetaField, S extends SelectModel = {}, SV = []> = MS<'values', GF, A, S, SV>\ntype MSF<A extends MetaModel, GF extends t.DMetaField, S extends SelectModel = {}, SV = []> = MS<'frame', GF, A, S, SV>\n\n\ntype KeyPicker<A extends Record<string, any>, S extends Record<string, any>, Rest = never> = NestedKeyOf<A> | NestedKeyOf<S> | ((p: A & S, D: t.DMetaField) => GField) | Rest\ntype Awaited<T> = T extends PRecord<infer Z> ? (Z extends [infer D] ? D : Z) : T extends PArray<infer X> ? X : T extends Promise<infer M> ? M : never\n// type Awaited<T> = T extends Promise<infer U> ? U extends Array<infer U2> ? U2 : U extends Record<string, infer V> ? V : U : T\n\n\nexport interface MS<V extends VTypes, GF extends t.DMetaField, A extends MetaModel, S extends SelectModel = ShallowModel<A>, SV = []> extends Selectors<S, GF> {\n    returnType: Awaited<ReturnType<this['execute']>>\n    compType: A & S\n\n    execute: FnMap<A, GF, S, SV>[V]\n    exec: this['execute']\n    show: this['execute']\n    dump: (opts?: { state?: boolean }) => this\n\n    orderBy<U_ extends ([KeyPicker<A, S>, DDirection?][])>(...key: U_): MS<V, GF, A, S, SV>\n    orderBy<U extends ('ALL' | KeyPicker<A, S>)>(k: U, d?: DDirection): MS<V, GF, A, S, SV>\n    orderBy<Z>(_callback: (p: A & S, D: GF) => Z, d?: DDirection): MS<V, GF, A, S, SV>\n    groupBy<G extends KeyPicker<A, S, 'ALL'>>(...keys: G[] | G[][] | (['GROUPING SETS', G[][]] | ['CUBE' | 'ROLLUP', G[]])): MS<'grouped', GF, A, S, SV>\n    countBy<G extends (KeyPicker<A, S>)>(key: G): MS<'values', GF, A, S, [string, number]>\n\n    keyBy<G extends (KeyPicker<A, S>)>(key: G): MS<'keyed', GF, A, S, SV>\n    minBy<G extends (KeyPicker<A, S>)>(key: G): MS<'row', GF, A, S, SV>\n    maxBy: this['minBy']\n    where(fn: (p: this['compType'], D: GF) => any): MS<V, GF, A, S, SV>\n    where(rawStr: string): MS<V, GF, A, S, SV>\n    having: this['where']\n    distinctOn<G extends KeyPicker<A, S>>(...key: G[] | G[][]): MS<V, GF, A, S, SV>\n\n    union<V2 extends VTypes, A2 extends MetaModel, S2 extends SelectModel>(a: MS<V2, GF, A2, S2>): MS<V2, GF, A & A2, S & S2>\n    unionAll: this['union']\n    unionByName: this['union']\n    unionAllByName: this['union']\n    except(a: MS<any, any, any, any>): MS<V, GF, A, S, SV>\n    exceptAll: this['except']\n    intersect: this['except']\n    intersectAll: this['except']\n\n    limit: (n: number) => this\n    offset: (n: number) => this\n    context: (cb: Record<string, any>) => this\n    sample: (n: number | `${number}%`) => this\n    toSql(opts?: any): string\n    copyTo: CopyToInterface<A, S>['to'] // Pass available fields to CopyToInterface\n}\n\n\nexport interface UpdateResult<Mods extends Models, T extends keyof Mods & string, C extends StrictCollection[] = [], P extends MetaModel = MergedModel<Mods, C>> {\n    set<U extends SelectModel>(fn: (p: P & Record<string, any>, D: t.DMetaField) => U): UpdateResult<Mods, T, C, P>\n    where<X>(fn: (p: P, D: t.DMetaField) => X): UpdateResult<Mods, T, C, P>\n    where(...callback: string[]): UpdateResult<Mods, T, C, P>\n}\n\ntype ExtractSelectModel<T> = T extends MS<any, any, any, infer S, any> ? S : T extends Record<string, MS<any, any, any, any, any>> ? { [K in keyof T]: ExtractSelectModel<T[K]> } : SelectModel\ntype WithResult<Mods extends Models, T extends keyof Mods & string, Schema, GF extends t.DMetaField> = DBuilderResult<Mods & Record<T, Schema>, T, GF>\ntype WithAccDB<Mods extends Models, T extends keyof Mods & string, Schema, GF extends t.DMetaField> = DBuilderResult<Mods & Record<T, Schema>, T, GF>\ntype MSRecord = Record<string, MS<any, any, any, any, any>>\n\n// type InitialMaterializedResult<C extends StrictCollection[]> = MS<'records', MergedModel<C>>\nexport interface Withor<Mods extends Models, T extends keyof Mods & string, GF extends t.DMetaField = t.DMetaField> {\n    with<O extends MSRecord>(fn: (accDB: DBuilderResult<Mods, T, GF>) => O): WithResult<Mods, T, ExtractSelectModel<O>, GF>\n\n    with<O1 extends MSRecord, O2 extends MSRecord>(\n        fn1: (accDB: DBuilderResult<Mods, T, GF>) => O1,\n        fn2: (accDB: WithAccDB<Mods, T, ExtractSelectModel<O1>, GF>) => O2\n    ): WithResult<Mods, T, ExtractSelectModel<O1 & O2>, GF>\n\n    with<O1 extends MSRecord, O2 extends MSRecord, O3 extends MSRecord>(\n        fn1: (accDB: DBuilderResult<Mods, T, GF>) => O1,\n        fn2: (accDB: WithAccDB<Mods, T, ExtractSelectModel<O1>, GF>) => O2,\n        fn3: (accDB: WithAccDB<Mods, T, ExtractSelectModel<O2>, GF>) => O3\n    ): WithResult<Mods, T, ExtractSelectModel<O1 & O2 & O3>, GF>\n\n    with<O1 extends MSRecord, O2 extends MSRecord, O3 extends MSRecord, O4 extends MSRecord>(\n        fn1: (accDB: DBuilderResult<Mods, T, GF>) => O1,\n        fn2: (accDB: WithAccDB<Mods, T, ExtractSelectModel<O1>, GF>) => O2,\n        fn3: (accDB: WithAccDB<Mods, T, ExtractSelectModel<O2>, GF>) => O3,\n        fn4: (accDB: WithAccDB<Mods, T, ExtractSelectModel<O3>, GF>) => O4\n    ): WithResult<Mods, T, ExtractSelectModel<O1 & O2 & O3 & O4>, GF>\n\n    with<O1 extends MSRecord, O2 extends MSRecord, O3 extends MSRecord, O4 extends MSRecord, O5 extends MSRecord>(\n        fn1: (accDB: DBuilderResult<Mods, T, GF>) => O1,\n        fn2: (accDB: WithAccDB<Mods, T, ExtractSelectModel<O1>, GF>) => O2,\n        fn3: (accDB: WithAccDB<Mods, T, ExtractSelectModel<O2>, GF>) => O3,\n        fn4: (accDB: WithAccDB<Mods, T, ExtractSelectModel<O3>, GF>) => O4,\n        fn5: (accDB: WithAccDB<Mods, T, ExtractSelectModel<O4>, GF>) => O5\n    ): WithResult<Mods, T, ExtractSelectModel<O1 & O2 & O3 & O4 & O5>, GF>\n}\n\n\ninterface Resultor<T> {\n    toSql: (opts?: any) => string,\n    execute: () => Promise<T>\n    exec: this['execute']\n    show: this['execute']\n    dump: (opts?: { state?: boolean }) => this\n}\n\n\n// Option 3: Use constructor check to detect plain objects\nexport type NestedKey42<ObjectType extends Record<string, any>> = {\n    [Key in keyof ObjectType & (string | number)]: ObjectType[Key] extends TFlag | t.DStructField //{ constructor: ObjectConstructor } \n    ? `${Key}.${NestedKey42<ObjectType[Key]>}`\n    : `${Key}`\n}[keyof ObjectType & (string | number)]\n\ntype Split<S extends string, D extends string = \".\"> =\n    S extends `${infer Head}${D}${infer Tail}`\n    ? [Head, ...Split<Tail, D>]\n    : [S];\n\ntype Get<T, K extends readonly string[]> =\n    K extends [infer Head extends keyof T, ...infer Rest extends string[]]\n    ? Get<T[Head], Rest>\n    : T;\n\ntype Project<T, Keys extends readonly string[]> = Flatten<{\n    [K in Keys[number]as K extends `${string}.${infer Leaf}` ? Leaf : K]:\n    Get<T, Split<K>>\n}>;\n\nexport interface Selectors<AV extends MetaModel, GF extends t.DMetaField> {\n\n    // A: select()\n    select(): MSR<AV, GF, ShallowModel<AV>>\n    // B: select('name', 'age')\n    select<U extends readonly (NestedKey42<AV>)[]>(...keys: U):\n        MSR<AV, GF, Project<AV, U>>\n    // { [K in U[number] & keyof P]: P[K] } //MSR<P, GF, { [K in U[number] & keyof P]: P[K] }>\n    // select<U extends (NestedKey42<A> & string)[]>(...keys: U & (NestedKey42<A>)[]): DeepPick<A, MapStringArrayKeepBeforeDot<U>> //MSR<P, GF, { [K in U[number] & keyof P]: P[K] }>\n    // C select(e => [e.name, e.age])\n    select<T______________1, T______________2>(fn: (p: AV, D: GF) => [T______________1, T______________2]): MSV<AV, GF, {}, [T______________1, T______________2]>\n    select<T_________1, T_______2, T________3>(fn: (p: AV, D: GF) => [T_________1, T_______2, T________3]): MSV<AV, GF, {}, [T_________1, T_______2, T________3]>\n    select<T_____1, T_____2, T_____3, T_____4>(fn: (p: AV, D: GF) => [T_____1, T_____2, T_____3, T_____4]): MSV<AV, GF, {}, [T_____1, T_____2, T_____3, T_____4]>\n    select<T___1, T____2, T___3, T___4, T___5>(fn: (p: AV, D: GF) => [T___1, T____2, T___3, T___4, T___5]): MSV<AV, GF, {}, [T___1, T____2, T___3, T___4, T___5]>\n    select<T__1, T__2, T__3, T__4, T__5, T__6>(fn: (p: AV, D: GF) => [T__1, T__2, T__3, T__4, T__5, T__6]): MSV<AV, GF, {}, [T__1, T__2, T__3, T__4, T__5, T__6]>\n    select<T_1, T_2, T_3, T__4, T_5, T_6, T_7>(fn: (p: AV, D: GF) => [T_1, T_2, T_3, T__4, T_5, T_6, T_7]): MSV<AV, GF, {}, [T_1, T_2, T_3, T__4, T_5, T_6, T_7]>\n    select<T_1, T_2, T3, T4, T5, T6, T_7, T_8>(fn: (p: AV, D: GF) => [T_1, T_2, T3, T4, T5, T6, T_7, T_8]): MSV<AV, GF, {}, [T_1, T_2, T3, T4, T5, T6, T_7, T_8]>\n    select<A____, D, E, F, G, H, I, J, _____L>(fn: (p: AV, D: GF) => [A____, D, E, F, G, H, I, J, _____L]): MSV<AV, GF, {}, [A____, D, E, F, G, H, I, J, _____L]>\n    select<A___, C, D, E, F, G, H, I, J, ___L>(fn: (p: AV, D: GF) => [A___, C, D, E, F, G, H, I, J, ___L]): MSV<AV, GF, {}, [A___, C, D, E, F, G, H, I, J, ___L]>\n    select<A__, C, D, E, F, G, H, I, J, K, _L>(fn: (p: AV, D: GF) => [A__, C, D, E, F, G, H, I, J, K, _L]): MSV<AV, GF, {}, [A__, C, D, E, F, G, H, I, J, K, _L]>\n    select<A, B, C, D, E, F, G, H, I, J, K, L>(fn: (p: AV, D: GF) => [A, B, C, D, E, F, G, H, I, J, K, L]): MSV<AV, GF, {}, [A, B, C, D, E, F, G, H, I, J, K, L]>\n    // Cbis: select(e => [e.name, e.age, e.total,... 421 more items])\n    select<T extends readonly GField[]>(fn: (p: AV, D: GF) => [...T]): MSV<AV, GF, {}, T>\n    // D: select(e => e.age)\n    select<U extends DPrimitiveField>(fn: (p: AV, D: GF) => U): MSF<AV, GF, {}, [U]>\n    // F: select(e => `${ e.name }__${ e.total } `)\n    select<U extends Primitive>(fn: (p: AV, D: GF) => U): MSF<AV, GF, {}, [PrimitiveField<U>]>\n    // E: select(e => ({ name: e.name, age: e.age }))\n    // select<U extends TFlag>(fn: (p: AV & Record<string, any>, D: GF) => U): 42 //''\n    select<U extends SelectModel>(fn: (p: AV & Record<string, any>, D: GF) => U):\n        // U extends Record<string, infer FF extends TFlag> ? MSR<AV, GF, Omit<FF, keyof TFlag>> :\n        MSR<AV, GF, FromPlainDict<ShallowModel<U>>>\n\n}\n\n\nexport type FromResultModel<Ressource extends keyof Models, C extends StrictCollection[] = [], GF extends t.DMetaField = t.DMetaField, P extends MetaModel = MergedModel<Models, C>> = FromResult<Models, Ressource, C, GF, P>\nexport type From<Ressource extends keyof Models, S extends StrictCollection[]> = FromResultModel<Ressource, S>\n\ntype ToModel<Mods extends Models, Ressource extends string, Uri extends string, A extends string = DeriveName<Uri>> =\n    MergedModel<Mods, [{ catalog: Ressource; uri: Uri; alias: A }]>\ntype PushCollection<C extends StrictCollection[], Ressource extends string, Uri extends string, A extends string = DeriveName<Uri>> =\n    [...C, { catalog: Ressource; uri: Uri; alias: A }]\n\n\ntype ModKeys<Mods extends Models, Ressource extends keyof Mods & string> = Extract<keyof Mods[Ressource], string> | Extract<keyof Mods[''], string>\n\n\nexport interface FromResult<Mods extends Models, Ressource extends keyof Mods & string, C extends StrictCollection[] = [], GF extends t.DMetaField = t.DMetaField, P extends MetaModel = MergedModel<Mods, C>> extends Selectors<P, GF> {\n    join<K extends ModKeys<Mods, Ressource> /*| (string & {})*/, A extends string = DeriveName<K>>(\n        table: K,\n        alias?: A,\n    ): {\n        using: (o: KeyIntersection<P, ToModel<Mods, Ressource, K, A>>) =>\n            K extends ModKeys<Mods, Ressource> ?\n            FromResult<Mods, Ressource, PushCollection<C, Ressource, K, A>, GF>\n            : FromResult<Mods, Ressource, PushCollection<C, '', '', A>, GF>\n        on: (fn: (p: MergedModel<Mods, PushCollection<C, Ressource, K, A>>, D: GF) => any) =>\n            K extends ModKeys<Mods, Ressource> ?\n            FromResult<Mods, Ressource, PushCollection<C, Ressource, K, A>, GF>\n            : FromResult<Mods, Ressource, PushCollection<C, '', '', A>, GF>\n    },\n\n    leftJoin: this['join']\n    rightJoin: this['join']\n    naturalJoin: this['join']\n    innerJoin: this['join']\n\n    crossJoin<K extends Extract<keyof Mods[Ressource], string> | Extract<keyof Mods[''], string>, A extends string = DeriveName<K>>(table: K, a?: A)\n        : FromResult<Mods, Ressource, PushCollection<C, Ressource, K>, GF>\n\n    execute(): ReturnType<Flatten<MSR<P, GF, ShallowMergedModel<Models, C>>>['execute']>\n    ensureSchemas(): Promise<void>\n}\n\n\n\nexport declare function Buck<T extends keyof Models>(catalog: T, settings?: Partial<t.DSettings>): DBuilderResult<Models, ''>\n\n// Define the return type for DBuilder\nexport interface DBuilderResult<Mods extends Models, Ressource extends keyof Mods & string, GF extends t.DMetaField = t.DMetaField> extends Withor<Mods, Ressource, GF> {\n    ddb: DuckdbCon\n    settings(s: Partial<t.DSettings>): DBuilderResult<Mods, Ressource, GF>\n    fetchTables: () => Promise<[string, any][]>\n\n    macros: <U extends Record<string, (...args: any[]) => any>>(\n        fn: (D: t.DMetaField & Record<string, (...args: any[]) => any>) => U\n    ) => DBuilderResult<Mods, '', U & GF>\n\n    create(s: string, opts?: Partial<{ replace: boolean; ifNotExists: boolean }>): {\n        as<U extends Record<string, any>>(...items: U[]): Resultor<any>\n    }\n\n    update<K1 extends (ModKeys<Mods, Ressource>) & string>(table: K1): UpdateResult<Mods, Ressource, PushCollection<[], Ressource, K1>> & Resultor<any>\n\n    from<K1 extends ModKeys<Mods, Ressource> | (string & {}), A extends string = DeriveName<K1>>(table: K1, alias?: A):\n        K1 extends ModKeys<Mods, Ressource> ?\n        (FromResult<Mods, Ressource, PushCollection<[], Ressource, K1, A>, GF> & MS<'records', GF, MergedModel<Mods, PushCollection<[], Ressource, K1, A>>>)\n        : (FromResult<Mods, Ressource, PushCollection<[], '', '', A>, GF> & MS<'records', GF, MergedModel<Mods, PushCollection<[], '', '', A>>>)\n    // from(table: string): 123\n    // from<K extends keyof Mods['error']>(x: K): Mods['error'][K]\n\n    from<MM extends Mods, TT extends keyof Mods & string, SS extends StrictCollection[]>(obj: FromResult<MM, TT, SS, GF>): FromResult<Mods, TT, SS, GF>\n    from<V1 extends VTypes, A1 extends MetaModel, S1 extends SelectModel = {}>(obj: MS<V1, GF, A1, S1>): MS<V1, GF, A1, S1>\n\n    loadExtensions(...ext: string[]): DBuilderResult<Mods, Ressource, GF> // Use the defined type here\n    // fetchSchema(id: string): Promise<Mods>\n    describe(id: string): Promise<any>\n    run(sql: string): Promise<any>\n}\n\n// Overload for settings only\nexport declare function DBuilder(settings?: Partial<t.DSettings>): DBuilderResult<Models, ''>\nexport declare function DBuilder(): DBuilderResult<Models, ''>\n\n// Updated DBuilder declaration with catalog\nexport declare function DBuilder<T extends TRessource>(catalog: T, settings?: Partial<t.DSettings>):\n    T extends keyof Models ? DBuilderResult<Models, T> : DBuilderResult<Models, ''>\n\n\n\n";export{e as default};
