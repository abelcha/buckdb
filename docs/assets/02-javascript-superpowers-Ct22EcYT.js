const e="// âš¡ BuckDB: JavaScript Superpowers Unleashed!\n// Advanced JavaScript features that compile to perfect SQL\n\nimport { Buck } from '@buckdb/isomorphic'\n\n// Create an in-memory database for our examples\nconst db = Buck(':memory:', { access_mode: 'AUTOMATIC' })\n\n// ================================\n// ðŸŽ¯ SETUP: Create rich sample data\n// ================================\n\n// Create employees table with comprehensive data\nawait db.create('employees', { replace: true })\n    .as([\n        { id: 1, first_name: 'Sarah', last_name: 'Connor', preferred_name: null, salary: 120000, department: 'Engineering', performance_score: 4.5, years_experience: 5, is_manager: true, is_active: true, hire_date: '2019-03-15', email: 'sarah.connor@company.com' },\n        { id: 2, first_name: 'John', last_name: 'Doe', preferred_name: 'Johnny', salary: 85000, department: 'Sales', performance_score: 4.2, years_experience: 3, is_manager: false, is_active: true, hire_date: '2021-06-01', email: 'john.doe@company.com' },\n        { id: 3, first_name: 'Alice', last_name: 'Smith', preferred_name: null, salary: 95000, department: 'Marketing', performance_score: 3.8, years_experience: 4, is_manager: false, is_active: true, hire_date: '2020-09-12', email: 'alice.smith@company.com' },\n        { id: 4, first_name: 'Bob', last_name: 'Johnson', preferred_name: 'Bobby', salary: 110000, department: 'Engineering', performance_score: 4.7, years_experience: 7, is_manager: true, is_active: false, hire_date: '2017-01-20', email: 'bob.johnson@company.com' },\n        { id: 5, first_name: 'Carol', last_name: 'Williams', preferred_name: null, salary: 75000, department: 'HR', performance_score: 4.0, years_experience: 2, is_manager: false, is_active: true, hire_date: '2022-04-10', email: 'carol.williams@company.com' }\n    ])\n    .execute()\n\n// ================================\n// ðŸŽ¯ TERNARY OPERATORS - Conditional logic made beautiful\n// ================================\n\nconst conditionalLogic = await db.from('employees')\n    .select(emp => ({\n        name: emp.first_name + ' ' + emp.last_name,\n        // ðŸ”¥ Ternary operators become SQL CASE statements!\n        salaryTier: emp.salary > 100000 ? 'Senior' : \n                   emp.salary > 60000 ? 'Mid-level' : 'Junior',\n        \n        // ðŸ”¥ Complex conditions with multiple ternaries\n        bonus: emp.department === 'Sales' ? emp.salary * 0.15 :\n               emp.department === 'Engineering' ? emp.salary * 0.12 :\n               emp.salary * 0.08,\n        \n        // ðŸ”¥ Boolean expressions\n        isEligibleForRaise: emp.performance_score > 4.0 && emp.years_experience > 2,\n        \n        // ðŸ”¥ Null coalescing and fallbacks\n        displayName: emp.preferred_name ?? emp.first_name,\n        \n        // ðŸ”¥ Template literals with complex logic\n        employeeCard: `${emp.first_name} ${emp.last_name} - ${\n            emp.is_manager ? 'ðŸ‘‘ Manager' : 'ðŸ‘¤ Employee'\n        } (${emp.department})`\n    }))\n    .where(emp => \n        emp.is_active &&                          // Boolean fields\n        emp.hire_date > '2020-01-01' &&          // Date comparisons\n        (emp.department !== 'Intern' || emp.salary > 0)  // Complex logic\n    )\n    .execute()\n\nconsole.log('Conditional Logic Results:', conditionalLogic)\n\n// ================================\n// ðŸš€ DESTRUCTURING & SPREAD - Modern JS patterns\n// ================================\n\nconst modernJavaScript = await db.from('employees')\n    .select(({ salary, first_name, last_name, department, ...emp }) => ({\n        // ðŸ”¥ Destructuring in action!\n        employeeName: first_name + ' ' + last_name,\n        cost: salary,\n        division: department,\n        \n        // ðŸ”¥ Spread operator magic - include remaining fields\n        id: emp.id,\n        email: emp.email,\n        performance_score: emp.performance_score,\n        \n        // ðŸ”¥ Computed properties\n        salaryRange: salary < 80000 ? 'Entry' :\n                    salary < 100000 ? 'Mid' : 'Senior',\n        \n        // ðŸ”¥ Complex string manipulation\n        emailUsername: first_name.lower() + '.' + last_name.lower(),\n        initials: first_name.substr(0, 1) + last_name.substr(0, 1)\n    }))\n    .execute()\n\nconsole.log('Modern JavaScript Patterns:', modernJavaScript)\n\n// ================================\n// ðŸŽ¨ REGULAR EXPRESSIONS - Pattern matching power\n// ================================\n\n// Create users table for regex examples\nawait db.create('users_data', { replace: true })\n    .as([\n        { id: 1, username: 'alice123', email: 'alice.johnson@gmail.com', phone: '+1-555-123-4567', full_name: 'Alice Johnson' },\n        { id: 2, username: 'bob_dev', email: 'bob.smith@company.co.uk', phone: '555.987.6543', full_name: 'Bob Smith' },\n        { id: 3, username: 'admin', email: 'invalid-email', phone: '123-456-7890', full_name: 'Carol Admin' },\n        { id: 4, username: 'test_user', email: 'test@example.org', phone: '+44-20-7946-0958', full_name: 'Test User' },\n        { id: 5, username: 'charlie99', email: 'charlie@domain.com', phone: '(555) 111-2222', full_name: 'Charlie Brown' }\n    ])\n    .execute()\n\nconst regexMagic = await db.from('users_data')\n    .where(user => \n        user.email.regexp_matches('[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}') &&  // Email validation\n        !user.username.regexp_matches('^(admin|root|test)') &&  // Exclude system accounts\n        user.phone.len() >= 10  // Basic phone length check\n    )\n    .select((user, D) => ({\n        username: user.username,\n        email: user.email,\n        \n        // ðŸ”¥ Extract patterns with regex\n        emailDomain: user.email.regexp_extract('@(.+)$', 1),\n        \n        // ðŸ”¥ Clean and format data\n        cleanPhone: user.phone.regexp_replace('[^\\\\d]', '', 'g'),\n        \n        // ðŸ”¥ Complex validation results\n        isValidUser: user.email.Like('%@%.%') && \n                    user.username.len() >= 3 &&\n                    !user.username.regexp_matches('\\\\d{4,}'),  // No long number sequences\n        \n        // ðŸ”¥ String transformations\n        formattedName: user.full_name.upper(),\n        nameLength: user.full_name.len()\n    }))\n    .execute()\n\nconsole.log('Regex Pattern Matching:', regexMagic)\n\n// ================================\n// ðŸŒŠ CHAINED METHODS - Fluent data transformation\n// ================================\n\n// Create transactions for method chaining examples\nawait db.create('transactions', { replace: true })\n    .as([\n        { id: 1, amount: 1250.75, category: 'ELECTRONICS', merchant_name: 'Best Buy Corp', description: 'Laptop purchase for office', transaction_date: '2024-01-15', status: 'COMPLETED' },\n        { id: 2, amount: 45.99, category: 'food_delivery', merchant_name: '  uber eats  ', description: null, transaction_date: '2024-01-16', status: 'completed' },\n        { id: 3, amount: 299.00, category: 'CLOTHING', merchant_name: 'Nike Store', description: 'Running shoes and gear', transaction_date: '2024-01-17', status: 'COMPLETED' },\n        { id: 4, amount: 12.50, category: 'coffee_shops', merchant_name: 'Starbucks', description: 'Morning coffee', transaction_date: '2024-01-18', status: 'pending' },\n        { id: 5, amount: 150.25, category: 'GAS_STATIONS', merchant_name: 'Shell Gas', description: '', transaction_date: '2024-01-19', status: 'COMPLETED' }\n    ])\n    .execute()\n\nconst chainedOperations = await db.from('transactions')\n    .select(txn => ({\n        // ðŸ”¥ Method chaining on strings\n        categoryClean: txn.category\n            .lower()\n            .regexp_replace('[^a-z]', '', 'g')\n            .substr(0, 15),\n        \n        // ðŸ”¥ Number formatting\n        roundedAmount: txn.amount.round(2),\n        amountString: '$' + txn.amount.round(2),\n        \n        // ðŸ”¥ Date manipulations\n        formattedDate: txn.transaction_date,\n        \n        // ðŸ”¥ Complex nested operations\n        merchantInfo: txn.merchant_name.trim().upper() + ' (' +\n                     txn.category.lower().regexp_replace('[_]', ' ', 'g') + ')',\n        \n        // ðŸ”¥ Conditional chaining with null handling\n        processedDescription: txn.description !== null && txn.description !== '' \n            ? txn.description.trim().substr(0, 50) + '...'\n            : 'No description available',\n            \n        // ðŸ”¥ Status normalization\n        normalizedStatus: txn.status.upper(),\n        \n        // ðŸ”¥ Category formatting\n        displayCategory: txn.category.lower().regexp_replace('[_]', ' ', 'g')\n    }))\n    .where(txn => \n        txn.amount > 0 &&\n        txn.status.lower() === 'completed' &&\n        txn.merchant_name.trim().len() > 0\n    )\n    .execute()\n\nconsole.log('Chained Operations:', chainedOperations)\n\n// ================================\n// ðŸŽª ADVANCED EXPRESSIONS - Complex logic combinations\n// ================================\n\nconst advancedExpressions = await db.from('employees')\n    .select((emp, D) => ({\n        // ðŸ”¥ Nested ternary expressions\n        employeeLevel: emp.is_manager ? 'Manager' :\n                      emp.years_experience > 5 ? 'Senior' :\n                      emp.years_experience > 2 ? 'Mid-level' : 'Junior',\n        \n        // ðŸ”¥ Complex mathematical expressions\n        adjustedSalary: emp.salary * (\n            emp.performance_score > 4.5 ? 1.15 :\n            emp.performance_score > 4.0 ? 1.10 :\n            emp.performance_score > 3.5 ? 1.05 : 1.00\n        ),\n        \n        // ðŸ”¥ Multi-condition boolean logic\n        isHighPerformer: emp.performance_score > 4.2 && \n                        emp.years_experience > 3 && \n                        emp.is_active &&\n                        emp.salary > 70000,\n        \n        // ðŸ”¥ String concatenation with conditions\n        statusBadge: (emp.is_active ? 'ðŸŸ¢ Active' : 'ðŸ”´ Inactive') + \n                    (emp.is_manager ? ' | ðŸ‘‘ Manager' : '') +\n                    (emp.performance_score > 4.5 ? ' | â­ Top Performer' : ''),\n        \n        // ðŸ”¥ Complex email domain logic\n        emailProvider: emp.email.Like('%@gmail.%') ? 'Gmail' :\n                      emp.email.Like('%@company.%') ? 'Corporate' :\n                      emp.email.Like('%@outlook.%') ? 'Outlook' : 'Other',\n        \n        // ðŸ”¥ Date-based calculations\n        tenureYears: D.current_date().year() - D.year(emp),\n        \n        // ðŸ”¥ Performance tier with multiple criteria\n        performanceTier: emp.performance_score > 4.5 && emp.years_experience > 5 ? 'Elite' :\n                        emp.performance_score > 4.0 && emp.years_experience > 3 ? 'High' :\n                        emp.performance_score > 3.5 ? 'Good' : 'Developing'\n    }))\n    .where(emp => emp.is_active)\n    .orderBy(emp => emp.performance_score, 'DESC')\n    .execute()\n\nconsole.log('Advanced Expressions:', advancedExpressions)\n\n/*\nðŸš€ What makes this magical?\n\nâœ¨ COMPILE-TIME SAFETY: TypeScript catches errors before runtime\nâœ¨ INTELLIGENT PARSING: BuckDB understands JavaScript semantics\nâœ¨ SQL OPTIMIZATION: Your JS code becomes optimized SQL queries\nâœ¨ ZERO LEARNING CURVE: Use JavaScript you already know\nâœ¨ POWERFUL ABSTRACTION: Complex SQL concepts in simple JS syntax\n\nðŸŽ¯ Next level: Check out joins, aggregations, and data pipeline examples!\n*/\n\nconsole.log('âš¡ JavaScript superpowers activated in SQL!')\n";export{e as default};
