const e="import * as ts from 'typescript';\nimport { Î£ } from './utils'\ntype Position = { line: number, column: number, charPos: number }\nexport type Extracted = {\n    method: string,\n    base?: string | null,\n    expression: string,\n    children?: Extracted[],\n    /** Array of tuples representing method calls in the chain */\n    chain?: [\n        /** Name of the method being called */\n        methodName: string,\n        /** Array of arguments passed to the method */\n        methodArgs: any[],\n        /** Line number where this method appears in source (optional) */\n        lineNumber?: number\n    ][],\n    start?: Position,\n    end?: Position\n}\ntype Opts = {\n    positions?: boolean,\n    chain?: boolean,\n    targetMethods?: string[] | null\n}\nexport const extractAssignations = (text: string, opts: Opts = {}) => {\n    const sourceFile = ts.createSourceFile('temp.ts', text, ts.ScriptTarget.Latest, true);\n    const assignations = {}\n\n    function visit(node: ts.Node) {\n        if (ts.isVariableStatement(node)) {\n            const declarationList = node.declarationList;\n            declarationList.declarations.forEach(declaration => {\n                if (ts.isVariableDeclaration(declaration) && ts.isCallExpression(declaration.initializer)) {\n                    const name = declaration.name.getText(sourceFile);\n                    // const value = declaration.initializer.getText(sourceFile);\n                    const val = handleCallExpression(sourceFile, declaration.initializer, { targetMethods: null, ...opts })\n                    if (val?.length)\n                        assignations[name] = val[0]\n                    // assignations.push([name, value]);\n                }\n            });\n        }\n        ts.forEachChild(node, visit);\n    }\n\n    ts.forEachChild(sourceFile, visit);\n    return assignations;\n}\n\nconst BuckAssign = {\n    expression: 'Buck()',\n    chain: [['Buck',]]\n}\n\n\nexport const extractReconciledCalls = (testCode: string, opts: Opts = {}) => {\n    const result = extractSpecialCalls(testCode, opts)\n    // console.log(result)\n    const assignations = extractAssignations(testCode, opts)\n    // console.log({ assignations })\n    // console.log(result)\n    // return result\n    return result.map(e => {\n        // console.log('resssssssssssss', e)\n        // console.log('EBVASSSE', e.base)\n        if ((/*e.base === null ||*/ e.base === 'MemoryDB')) {\n            return {\n                ...e,\n                expression: 'Buck().' + e.expression.replace(/MemoryDB\\s*\\./img, ''),\n                chain: [['Buck', [], e.chain[0]?.[2]]].concat(e.chain),\n            }\n        }\n        if (e.base && assignations[e.base]) {\n            return {\n                ...e,\n                expression: e.expression.replace(e.base, assignations[e.base].expression),\n                chain: assignations[e.base].chain.concat(e.chain)\n            }\n        }\n        if (e.base && !assignations[e.base]) {\n            return null\n        }\n        return e\n    }).filter(e => e !== null)\n}\nexport const reconstituteAssignations = (assignations: [string, string][]) => {\n    const assignationMap = new Map<string, string>();\n    const result = new Map<string, string>();\n\n    // First pass: populate the map with variable names and their values\n    assignations.forEach(([name, value]) => {\n        assignationMap.set(name, value);\n    });\n\n    // Second pass: build concatenated expressions for variables that reference others\n    assignations.forEach(([name, value]) => {\n        let finalValue = value;\n        let replaced = true;\n        while (replaced) {\n            replaced = false;\n            for (const [varName, varValue] of assignationMap) {\n                if (finalValue.includes(varName) && varName !== name) {\n                    finalValue = finalValue.replace(new RegExp(`\\\\b${varName}\\\\b`), varValue);\n                    replaced = true;\n                }\n            }\n        }\n        result.set(name, finalValue);\n    });\n\n    return result;\n}\n\nfunction getPosition(sourceFile: ts.SourceFile, node: ts.Node, isStart: boolean = true) {\n    const pos = isStart ? node.getStart(sourceFile) : node.getEnd();\n    const lineAndChar = sourceFile.getLineAndCharacterOfPosition(pos);\n    return {\n        line: lineAndChar.line + 1, // Lines are 0-based in TypeScript, so add 1\n        column: lineAndChar.character + 1, // Characters are 0-based, so add 1\n        charPos: pos\n    };\n}\nfunction isTranscluded(parentPos: Extracted, childPos: Extracted) {\n    return parentPos.start.charPos <= childPos.start.charPos && parentPos.end.charPos >= childPos.end.charPos\n}\n\nconst handleCallExpression = (sourceFile: ts.SourceFile, node: ts.CallExpression, opts: any): Extracted[] => {\n    const expressionText = node.expression.getText(sourceFile);\n    const targetMethods = opts.targetMethods || ['from', 'create'];\n    let method: string | null = null;\n    // let resource: string | null = null;\n    let fullExpression: string = '';\n    const isOK = name => opts.targetMethods === null ? true : targetMethods.includes(name);\n\n    if (ts.isPropertyAccessExpression(node.expression)) {\n        const name = node.expression.name.getText(sourceFile);\n        if (isOK(name)) {\n            method = name;\n            // resource = node.expression.expression.getText(sourceFile).trim();\n\n            // Start with the current node\n            let currentNode: ts.Node = node;\n            // If parent is a property access expression or call expression, go up to capture full chain\n            while (currentNode.parent && (ts.isPropertyAccessExpression(currentNode.parent) || ts.isCallExpression(currentNode.parent))) {\n                currentNode = currentNode.parent;\n            }\n            // const resourceText = node.expression.expression.getText(sourceFile);\n            // const leadingSpaces = ((currentNode as ts.PropertyAccessChain).expression).getChildAt(1).getLeadingTriviaWidth()\n            // console.log({leadingSpaces})\n            // const chain: { method: string, params: any[] }[] = [];\n            // console.log('--------', collectChain(node))\n            // ts.forEachChild(currentNode.expression, (child) => {\n            //     console.log('FEEEEE', [child.getText()])\n            // })\n            // console.log('====>>>=', [(currentNode as ts.PropertyAccessChain).expression.getChildAt(1).getText()])\n            // console.log('====>>>=', nb(currentNode.getChildAt(0).getChildAt(0).getChildAt(0).getChildAt(1)))\n            // console.log('==>', method, [node.   expression.getChildren().map(c => c.getText())])\n            const chainProps = opts.chain !== false ? collectChain(currentNode) : {}\n            fullExpression = currentNode.getText(sourceFile)//.substring(resourceText.length + 1 + leadingSpaces)\n            const positions = opts.positions === false ? {} :\n                { start: getPosition(sourceFile, node, true), end: getPosition(sourceFile, currentNode, false) }\n            return [{ expression: fullExpression, method, ...positions, ...chainProps }]\n        }\n    } else if (ts.isCallExpression(node) && ts.isIdentifier(node.expression) && isOK(expressionText)) {\n        method = expressionText;\n        // resource = null;\n        // Start with the current node\n        let currentNode: ts.Node = node;\n        // If parent is a property access expression or call expression, go up to capture full chain\n        while (currentNode.parent && (ts.isPropertyAccessExpression(currentNode.parent) || ts.isCallExpression(currentNode.parent))) {\n            currentNode = currentNode.parent;\n        }\n        // console.log('=======>', )\n        const chains = opts.chain !== false ? collectChain(currentNode) : {}\n        fullExpression = currentNode.getText(sourceFile);\n        const positions = opts.positions === false ? {} :\n            { start: getPosition(sourceFile, node, true), end: getPosition(sourceFile, currentNode, false) }\n        return [{ expression: fullExpression, ...positions, method, ...chains }]\n    }\n    return []\n}\n\n\nexport const extractSpecialCalls = (text: string, opts: Opts = { positions: true, chain: false }): Extracted[] => {\n    const sourceFile = ts.createSourceFile('temp.ts', text, ts.ScriptTarget.Latest, true);\n    const specialCalls: Extracted[] = [];\n    const pOmiter = (x: Extracted) => {\n        const { start, end, ...rest } = x;\n        return opts.positions === false ? rest : x\n    }\n\n\n    function visit(node: ts.Node) {\n        if (ts.isCallExpression(node)) {\n            const items = handleCallExpression(sourceFile, node, { ...opts, positions: true })\n            // console.log('PUSSSSSSG', items)\n            for (const item of items) {\n                if (specialCalls.length && isTranscluded(specialCalls[specialCalls.length - 1], item)) {\n                    specialCalls[specialCalls.length - 1].children ??= []\n                    specialCalls[specialCalls.length - 1].children.push(item)\n                } else {\n                    specialCalls.push(item)\n                }\n            }\n            // specialCalls.push(...items)\n        }\n        ts.forEachChild(node, visit);\n    }\n\n    ts.forEachChild(sourceFile, visit);\n\n    return specialCalls.map(e => !e.children ? pOmiter(e) : ({\n        ...pOmiter(e),\n        children: e.children.map(pOmiter),\n    }))\n}\nfunction collectChain(node: ts.Node, chain: [string, any[], number?][] = [], opts: Opts = {}) {\n    const pushArgs = (method: string, n: ts.CallExpression) => {\n        chain.unshift([method, n.arguments.map(e => e.getText())])\n        if (opts?.positions !== false)\n            chain[0].push(n.expression.getSourceFile().getLineAndCharacterOfPosition(n.expression.getEnd()).line)\n\n    }\n    if (ts.isCallExpression(node)) {\n        let method = '';\n        if (ts.isPropertyAccessExpression(node.expression)) {\n            method = node.expression.name.getText();\n            pushArgs(method, node)\n            return collectChain(node.expression.expression, chain);\n        } else if (ts.isIdentifier(node.expression)) {\n            method = node.expression.getText();\n            pushArgs(method, node)\n        }\n    } else {\n        return { chain, base: node.getText() }\n    }\n    return { chain, base: null };\n}\n\n\nexport const extractChains = (text: string) => {\n    const sourceFile = ts.createSourceFile('temp.ts', text, ts.ScriptTarget.Latest, true);\n    const chains: { method: string, params: any[] }[] = [];\n\n\n\n    function visit(node: ts.Node) {\n        if (ts.isCallExpression(node)) {\n            if (!node.parent || !ts.isPropertyAccessExpression(node.parent) || !ts.isCallExpression(node.parent.parent)) {\n                // This is the outermost call in the chain\n                // const chain: Extracted['chain'] = [];\n                return collectChain(node);\n                // chains.push(...chain);\n            }\n        }\n        ts.forEachChild(node, visit);\n    }\n\n    ts.forEachChild(sourceFile, visit);\n    return chains;\n}\n\nexport function cleanEval(s: string, i?: number) {\n    try {\n        return new Function(`return ${s}`)()\n    } catch (err) {\n        console.warn('cleanEval error', err)\n        return ''\n    }\n}\n\n// export const getChainStatement = (chain: Extracted['chain']) => {\n//     const f = chain.find(e => e[0] === 'from')?.[1]\n//     if (!f?.length) {\n//         return ''\n//     }\n//     const ffe = cleanEval(f[0])\n//     return typeof ffe === 'string' ? ffe : ''\n// }\n\n// export const getTargetOps = (...extracts: Pick<Extracted, \"chain\" | 'children'>[]) => {\n//     // console.log({ extracts })\n//     const t = [...extracts, ...(extracts.flatMap(z => z.children || []))]\n//         .flatMap(e => e.chain)\n//         .filter(([methodName, params]) => methodName.match(/^(from|leftJoin|rightJoin|naturalJoin|innerJoin)$/))\n//         .map(e => cleanEval(e[1][0]))\n//     return Array.from(new Set(t)) as string\n// }\n// export const getRessourcesExtracts = (...extracts: Pick<Extracted, \"chain\">[]) => {\n//     const b = extracts.map(e => e.chain)\n//         .map(e => cleanEval(e[1][0]))\n//     return Array.from(new Set(b))\n// }\n\n// export const getBuckInstanceInit = (extract: Extracted) => {\n//     return extract.chain.filter(([m]) => m.match(/^(Buck|settings|loadExtensions)$/))\n//         .map(([methodName, params]) => methodName + '(' + params.join(',') + ')')\n// }";export{e as default};
