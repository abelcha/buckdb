const n="\nexport const DuckDBTypeId = {\n  INVALID: 0,\n  BOOLEAN: 1,\n  TINYINT: 2,\n  SMALLINT: 3,\n  INTEGER: 4,\n  BIGINT: 5,\n  UTINYINT: 6,\n  USMALLINT: 7,\n  UINTEGER: 8,\n  UBIGINT: 9,\n  FLOAT: 10,\n  DOUBLE: 11,\n  TIMESTAMP: 12,\n  DATE: 13,\n  TIME: 14,\n  INTERVAL: 15,\n  HUGEINT: 16,\n  UHUGEINT: 32,\n  VARCHAR: 17,\n  BLOB: 18,\n  DECIMAL: 19,\n  TIMESTAMP_S: 20,\n  TIMESTAMP_MS: 21,\n  TIMESTAMP_NS: 22,\n  ENUM: 23,\n  LIST: 24,\n  STRUCT: 25,\n  MAP: 26,\n  ARRAY: 33,\n  UUID: 27,\n  UNION: 28,\n  BIT: 29,\n  TIME_TZ: 30,\n  TIMESTAMP_TZ: 31,\n  ANY: 34,\n  VARINT: 35,\n  SQLNULL: 36\n}\n\nexport const DNumeric = {\n  comptype: 'number',\n  id: 'numeric',\n  able: 'DNumericable',\n  field: 'DNumericField',\n  rawType: 'number',\n}\n\nexport const DVarchar = {\n  id: 'varchar',\n  able: 'DVarcharable',\n  field: 'DVarcharField',\n  rawType: 'string',\n}\n\nexport const DArray = {\n  id: 'array',\n  able: 'DArrayable',\n  field: 'DArrayField',\n  rawType: 'any[]',\n}\nexport const DStruct = {\n  id: 'struct',\n  able: 'DStructable',\n  field: 'DStructField',\n  rawType: 'Record<string,any>',\n}\nexport const DJson = {\n  id: 'json',\n  able: 'DJsonable',\n  field: 'DJsonField',\n  rawType: 'Record<string,any>',\n}\nexport const DBool = {\n  id: 'bool',\n  able: 'DBoolable',\n  field: 'DBoolField',\n  rawType: 'boolean',\n\n}\nexport const DBlob = {\n  id: 'blob',\n  able: 'DBlobable',\n  field: 'DBlobField',\n  rawType: 'Blob',\n\n}\nexport const DDate = {\n  id: 'date',\n  able: 'DDateable',\n  field: 'DDateField',\n  rawType: 'Date',\n\n}\nexport const DMap = {\n  id: 'map',\n  able: 'DMapable',\n  field: 'DMapField',\n  rawType: 'Map<string,any>',\n\n}\nexport const DOther = {\n  id: 'other',\n  able: 'DOtherable',\n  field: 'DOtherField',\n  rawType: 'any',\n}\nexport const DAny = {\n  id: 'any',\n  able: 'DAnyable',\n  field: 'DAnyField',\n  rawType: 'any',\n}\n\nexport const TypeProps = {\n  DNumeric,\n  DVarchar,\n  DArray,\n  DStruct,\n  DJson,\n  DBool,\n  DBlob,\n  DDate,\n  DMap,\n  DOther,\n  DAny,\n}\n\nexport const DuckDBTypeIdMap = {\n  [DuckDBTypeId.INVALID]: 'DAny',\n  [DuckDBTypeId.BOOLEAN]: 'DBool',\n  [DuckDBTypeId.TINYINT]: 'DNumeric',\n  [DuckDBTypeId.SMALLINT]: 'DNumeric',\n  [DuckDBTypeId.INTEGER]: 'DNumeric',\n  [DuckDBTypeId.BIGINT]: 'DNumeric',\n  [DuckDBTypeId.UTINYINT]: 'DNumeric',\n  [DuckDBTypeId.USMALLINT]: 'DNumeric',\n  [DuckDBTypeId.UINTEGER]: 'DNumeric',\n  [DuckDBTypeId.UBIGINT]: 'DNumeric',\n  [DuckDBTypeId.FLOAT]: 'DNumeric',\n  [DuckDBTypeId.DOUBLE]: 'DNumeric',\n  [DuckDBTypeId.TIMESTAMP]: 'DDate',\n  [DuckDBTypeId.DATE]: 'DDate',\n  [DuckDBTypeId.TIME]: 'DDate',\n  [DuckDBTypeId.INTERVAL]: 'DDate',\n  [DuckDBTypeId.HUGEINT]: 'DNumeric',\n  [DuckDBTypeId.UHUGEINT]: 'DNumeric',\n  [DuckDBTypeId.VARCHAR]: 'DVarchar',\n  [DuckDBTypeId.BLOB]: 'DBlob',\n  [DuckDBTypeId.DECIMAL]: 'DNumeric',\n  [DuckDBTypeId.TIMESTAMP_S]: 'DDate',\n  [DuckDBTypeId.TIMESTAMP_MS]: 'DDate',\n  [DuckDBTypeId.TIMESTAMP_NS]: 'DDate',\n  [DuckDBTypeId.ENUM]: 'DVarchar',\n  [DuckDBTypeId.LIST]: 'DArray',\n  [DuckDBTypeId.STRUCT]: 'DStruct',\n  [DuckDBTypeId.MAP]: 'DMap',\n  [DuckDBTypeId.ARRAY]: 'DArray',\n  [DuckDBTypeId.UUID]: 'DVarchar',\n  [DuckDBTypeId.UNION]: 'DAny',\n  [DuckDBTypeId.BIT]: 'DNumeric',\n  [DuckDBTypeId.TIME_TZ]: 'DDate',\n  [DuckDBTypeId.TIMESTAMP_TZ]: 'DDate',\n  [DuckDBTypeId.ANY]: 'DAny',\n  [DuckDBTypeId.VARINT]: 'DNumeric',\n  [DuckDBTypeId.SQLNULL]: 'DAny'\n}\n\nexport const mapTypes = (type: string) => {\n  if (!type) return 'DAny'\n  const t = type.toUpperCase()\n  if (t.match(/^(ANY)$/)) return 'DAny'\n  if (t.match(/(\\[\\]$|^LIST$|^ARRAY$|\\w+\\[\\w+\\])/)) return 'DArray'\n  if (t.match(/\\b((U)?(BIG|HUGE|TINY|SMALL)?INT(EGER)?|DOUBLE|DECIMAL|FLOAT)\\b/)) return 'DNumeric'\n  if (t.match(/^(VARCHAR|CHAR|TEXT)$/)) return 'DVarchar'\n  if (t.match(/^STRUCT/)) return 'DStruct'\n  if (t.match(/^JSON/)) return 'DJson'\n  if (t.match(/^BOOLEAN/)) return 'DBool'\n  if (t.match(/^MAP/)) return 'DMap'\n  // if (t.match(/^BLOB/)) return 'DBlob'\n  if (t.match(/^(DATE|TIME)[\\w\\s]*/)) return 'DDate'\n  return 'DAny'\n}\n\nexport const mapTypesProps = (type: string, details = false) => {\n  const mtype = mapTypes(type)\n  if (mtype === 'DArray' && details === true) {\n    const [_, subtype] = type.match(/^([A-Z]+)\\[\\]$/) || []\n    if (subtype) {\n      const s = mapTypesProps(subtype)\n      const rtn = {\n        ...DArray,\n        rawType: s.rawType + '[]',\n        field: `DArrayField<${mapTypes(subtype)}Field>`,\n      }\n      // console.log({ subtype, rtn })\n      return rtn\n    }\n    return DArray\n  }\n  switch (mtype) {\n    case 'DNumeric':\n      return DNumeric\n    case 'DVarchar':\n      return DVarchar\n    case 'DArray':\n      return DArray\n    case 'DStruct':\n      return DStruct\n    case 'DJson':\n      return DJson\n    case 'DBool':\n      return DBool\n    // case 'DBlob': return DBlob;\n    case 'DDate':\n      return DDate\n    // case 'DMap': return DMap;\n    // case 'DOther': return DOther;\n    // case 'DAny': return DAny;\n    default:\n      return DAny\n  }\n}\n\nexport const NativeMap = {\n  BOOLEAN: 'DBool',\n  NUMERIC: 'DNumeric',\n  STRING: 'DVarchar',\n  DATETIME: 'DDate',\n}\nexport const NativeInverseMap = Object.fromEntries(Object.entries(NativeMap).map(([k, v]) => [v, k]))\n\n// Simpler assertion helpers\nconst basePatternMatcher = {\n  keyword: '',\n  joinWith: ', ',\n  return_type: 'BOOLEAN',\n  params: { val: 'VARCHAR', matcher: 'ANY' } as Record<string, string>,\n}\ntype TPatternMatcher = typeof basePatternMatcher\n\nexport const PatternMatchers: Record<string, TPatternMatcher> = {\n  'Like': { ...basePatternMatcher, keyword: 'LIKE' },\n  // 'NotLike': { ...basePatternMatcher, keyword: 'NOT LIKE' },\n  'Ilike': { ...basePatternMatcher, keyword: 'ILIKE' },\n  // 'NotIlike': { ...basePatternMatcher, keyword: 'NOT ILIKE' },\n  'SimilarTo': { ...basePatternMatcher, keyword: 'SIMILAR TO' },\n  // 'NotSimilarTo': { ...basePatternMatcher, keyword: 'NOT SIMILAR TO' },\n  'Glob': { ...basePatternMatcher, keyword: 'GLOB' },\n  // 'NotGlob': { ...basePatternMatcher, keyword: 'NOT GLOB' },\n  'IsNull': { ...basePatternMatcher, keyword: 'IS NULL', params: { val: 'ANY' } },\n  // 'IsNot': { ...basePatternMatcher, keyword: 'IS NOT', params: { val: 'ANY', matcher: 'ANY' } },\n  'Between': { ...basePatternMatcher, keyword: 'BETWEEN', params: { val: 'INT', col1: 'INT', col2: 'INT' }, joinWith: ' AND ' },\n  'In': { ...basePatternMatcher, keyword: 'IN', joinWith: ', ' },\n  'NotBetween': { ...basePatternMatcher, keyword: 'NOT BETWEEN', params: { val: 'INT', col1: 'INT', col2: 'INT' }, joinWith: ' AND ' },\n}\nexport const DefaultLiteralTypes = ['Bit', 'Integer', 'Timestamp', 'Tinyint', 'Smallint', 'Json', 'Struct', 'Time', 'Timestamp_ms', 'Timestamp_s', 'Float', 'Map', 'Union', 'Blob', 'Date', 'Enum', 'Hugeint', 'Boolean', 'Varchar', 'Uuid', 'Ubigint', 'Bigint', 'Interval', 'Uinteger', 'Usmallint', 'Utinyint', 'Varint', 'Decimal', 'Double', 'Null', 'Timestamp_ns', 'Uhugeint']\n\nexport const LitteralTypesMap = new Map(\n  DefaultLiteralTypes.map(e => [e, e.toUpperCase()] as [string, string])\n    .concat([\n      ['List', ''],\n      ['Array', ''],\n      ['Struct', ''],\n    ]),\n)\n\nexport const LiteralTypes = LitteralTypesMap.keys()\n\nexport const PolyfillNumberMapping = {\n  // 'toExponential': 'toExponential',\n  // 'toFixed': e => `round(${e})::varchar`,\n  // 'toLocaleString': 'toLocaleString',\n  'toPrecision': 'round',\n  // 'toString': 'toString',\n  'valueOf': 'add',\n}\n\nexport const PolyfillStringMapping = {\n  'at': 'array_extract',\n  'charAt': 'array_extract',\n  // 'charCodeAt': body => `array_extract(${body}).ascii()`,\n  // 'codePointAt': body => `array_extract(${body}).ord()`,\n  // 'concat ':\n  'endsWith': 'ends_with',\n  'includes': 'contains',\n  'startsWith': 'starts_with',\n  'indexOf': 'strpos',\n  // 'lastIndexOf': null,\n  // 'isWellFormed': null,\n  // 'toWellFormed': null,\n  // 'localeCompare': null,\n  'toLocaleLowerCase': 'lower',\n  'toLocaleUpperCase': 'upper',\n  'match': 'regexp_matches',\n  'matchAll': 'regexp_matches',\n  'search': 'position',\n  'padEnd': 'rpad',\n  'padStart': 'lpad',\n  'repeat': 'repeat',\n  'replace': 'replace',\n  'replaceAll': 'replace',\n  'slice': 'array_slice',\n  'substring': 'substring',\n  'split': 'string_split',\n  'normalize': 'nfc_normalize',\n  'toLowerCase': 'lower',\n  'toUpperCase': 'upper',\n  'toString': 'format',\n  'valueOf': 'format',\n  'trim': 'trim',\n  'trimEnd': 'rtrim',\n  'trimStart': 'ltrim',\n}\nexport const PolyfillArrayMapping = {\n  'map': `list_transform`,\n  'reduce': `list_reduce`,\n  'join': `array_to_string`,\n  'filter': `list_filter`,\n}\n\nexport const UnmethodMapping = {\n  // 'map': e => `list_transform(${e})`,\n  // 'reduce': e => `array_reduce(${e})`,\n  // 'join': e => `array_to_string(${e})`,\n  // 'filter': e => `list_filter(${e})`,\n  // 'charCodeAt': e => `array_extract(${e}).ascii()`,\n  // 'codePointAt': e => `array_extract(${e}).ord()`,\n} as Record<string, (body: any) => string>\n\n\n\n\nexport const PolyfillMapping = Object.assign(PolyfillNumberMapping, PolyfillStringMapping, PolyfillArrayMapping)\n\n\nexport const AggregateFunctions = 'entropy mode first arg_max list listagg sum bit_or countif min_by min mean max_by max bit_xor corr regr_r2 mad argmax last avg bit_and var_pop bool_or count sem median arg_min stddev product favg fsum argmin'.split(' ')\n\n\n\n\n\n\nexport type DAction = 'select' | 'update' | 'upsert' | 'create'\nexport type DCondition = { condition: string; operator?: 'OR' | 'AND' }\nexport type DSelectee = { field: string; as?: string | number; raw?: string }\nexport type DDirection = 'ASC' | 'DESC' | 'ASC NULLS FIRST' | 'DESC NULLS FIRST' | 'ASC NULLS LAST' | 'DESC NULLS LAST'\nexport type DSetOpType = 'UNION' | 'UNION ALL' | 'UNION BY NAME' | 'UNION ALL BY NAME' | 'EXCEPT' | 'EXCEPT ALL' | 'INTERSECT' | 'INTERSECT ALL'\nexport type DSetOp = { type: DSetOpType, value: string }\nexport type DOrder = { field: string; direction?: DDirection }\nexport type DDatasource = { catalog: string; uri: string; alias?: string; using?: string, joinOn?: string; join?: 'JOIN' | 'LEFT JOIN' | 'RIGHT JOIN' | 'CROSS JOIN' | 'NATURAL JOIN' | 'INNER JOIN' }\nexport type DCopyTo = { uri: string; options?: Record<string, any> }\nexport type DCte = { query: { toState: () => DState, toSQL: () => string } & Record<string, any>; name?: string }\nexport type Parseable = string | Function\nexport const dstate = {\n  copyTo: [] as DCopyTo[],\n  context: {} as Record<string, any>,\n  datasources: [] as DDatasource[],\n  selected: [] as DSelectee[],\n  conditions: [] as DCondition[],\n  having: [] as DCondition[],\n  groupBy: [] as string[],\n  distinctOn: [] as string[],\n  limit: null as number | null,\n  sample: null as number | `${number}%` | null,\n  offset: null as number | null,\n  orderBy: [] as DOrder[],\n  keyBy: null as string | null,\n  countBy: null as string | null,\n  agg: null as string | null,\n  action: 'select' as DAction,\n  updated: [] as DSelectee[],\n  ctes: [] as DCte[],\n  setops: [] as DSetOp[],\n}\n\nexport type DState = typeof dstate\n\nexport const RessourceOps = ['from', 'leftJoin', 'join', 'rightJoin', 'naturalJoin', 'innerJoin']\nexport const InstanceOps = ['Buck', 'settings', 'loadExtensions']\n\nconst compressExtensions = ['.gz', '.zst', '.brotli', '.lz4', '.lzma', '.zlib', '']\nconst fileExtensions = ['parquet', 'csv', 'json', 'orc', 'avro', 'tsv', 'json', 'ndjson', 'jsonl']\nconst dbExtension = ['sqlite', 'sqlite3', 'duckdb', 'ddb', 'db']\n\nexport const ReadableFileRegexp = new RegExp(`\\\\.(${[...fileExtensions, ...dbExtension].join('|')})(${compressExtensions.join('|')})$`)\nexport const DirectoryRegexp = /^[^\\.]+$/";export{n as default};
