const e="import * as t from '.buck/types'\nexport type ObjectToValuesTuple<T> = T extends Record<string, any> ? Array<T[keyof T]> : never\n\nexport type TypeEq<A, B> = (<T>() => T extends A ? 1 : 2) extends (<T>() => T extends B ? 1 : 2) ? true : false\nexport type Flatten<T> = { [KeyType in keyof T]: T[KeyType] } & {}\nexport type ToRecord<T> = T extends readonly any[] ? { [K in keyof T as K extends `${number}` ? K : never]: T[K] }\n  : T\nexport type ExpectEqual<A, B> = (<G>() => G extends A ? 1 : 2) extends (<G>() => G extends B ? 1 : 2) ? (<G>() => G extends B ? 1 : 2) extends (<G>() => G extends A ? 1 : 2) ? true\n  : { error: 'Types are not equal'; expected: B; got: A }\n  : { error: 'Types are not equal'; expected: B; got: A }\n\n// Helper to force TypeScript to evaluate and reveal the error\nexport type Assert<T extends true> = T\n\nexport type IsPlainObject<T> = T extends object\n  ? T extends Array<any> | Map<any, any> | Set<any> | Date | RegExp | Function | Promise<any>\n  ? false\n  : true\n  : false\n\nexport type NestedKeyOf<ObjectType extends Record<string, any>> = {\n  [Key in keyof ObjectType & (string | number)]: ObjectType[Key] extends { [t.sInferred]: infer V } ? `${Key}` : IsPlainObject<ObjectType[Key]> extends true ? `${Key}` | `${Key}.${NestedKeyOf<ObjectType[Key]>}` : `${Key}`\n}[keyof ObjectType & (string | number)]\n\n\nexport type Merge<T, U> = { [K in keyof T | keyof U]: K extends keyof U ? U[K] : K extends keyof T ? T[K] : never }\nexport type TripleMerge<T, U, V> = { [K in keyof T | keyof U | keyof V]: K extends keyof V ? V[K] : K extends keyof U ? U[K] : K extends keyof T ? T[K] : never }\n\nexport type Strish = string | {}\nexport type Primitive = null | undefined | string | number | boolean | symbol | bigint\nexport type IsPrimitive<T> = [T] extends [Primitive] ? true : false\n\nexport type KeyIntersection<A, B> = {\n  [K in keyof A & keyof B]: K\n}[keyof A & keyof B]\n\n\n\nexport type PArray<X> = Promise<X[]>\nexport type PRecord<X> = Promise<Record<string, X>>\n\nexport type FirstElement<T> = T extends [infer F, ...any[]] ? F : never\n";export{e as default};
