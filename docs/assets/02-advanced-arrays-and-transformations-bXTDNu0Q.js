const n="// 🚀 BuckDB: Advanced Arrays & Transformations\n// Real working examples based on actual BuckDB capabilities\n\nimport { Buck, MemoryDB } from '@buckdb/isomorphic'\nimport { duckdb_functions } from '@buckdb/tf'\n\n// ================================\n// 🎯 ARRAY OPERATIONS - JavaScript patterns that work!\n// ================================\n\n// Array methods and transformations using working BuckDB syntax\nconst arrayOperationsResult = await MemoryDB.from(duckdb_functions())\n    .select((e, D) => ({\n        function_name: e.function_name,\n\n        \n        // 🔥 Array filtering using array_filter\n        filtered_parts: e.function_name\n            .str_split('_')\n            .array_filter(part => part.len() > 3),\n\n\n        // 🔥 template literals + Conditional\n        summary:\n            e.function_type === 'scalar'\n                ? `⚡ XSCALAR: ${e.function_name} (${e.function_name.len()})`\n                : `OTHER: 📊 ${e.function_type.upper()}: ${e.function_name}`,\n\n        // 🔥 Array creation and manipulation\n        sample_array: D.Array(['prefix', 'main', 'suffix'])\n            .map(item => item + '_' + e.function_name),\n\n        // 🔥 Array contains checks\n        has_underscore: e.function_name.str_split('').array_contains('_'),\n    }))\n    .where(e => e.function_name.SimilarTo(/^[a-z_]+$/i))  // Only functions with underscores\n    .limit(5)\n    .execute() satisfies {\n        function_name: string\n        name_parts: string[]\n        uppercase_parts: string[]\n        filtered_parts: string[]\n        processed_name: string[]\n        sample_array: string[]\n        has_underscore: boolean\n    }[]\n\nconsole.log('Array operations:', arrayOperationsResult)\n\n// ================================\n// 🏗️ WITH CLAUSES (CTEs) - Build complex queries step by step\n// ================================\n\n// WITH clauses for complex multi-step transformations\nconst withClauseResult = await Buck().with(\n    // Step 1: Create a filtered dataset\n    (accDB) => ({\n        filtered_functions: accDB.from('duckdb_functions()')\n            .select('function_name', 'function_oid', 'function_type', 'description')\n            .where(f => f.function_name.len() > 5)\n    }),\n\n    // Step 2: Add computed columns\n    accDB => ({\n        enhanced_functions: accDB.from('filtered_functions')\n            .select(e => ({\n                original_name: e.function_name,\n                name_length: e.function_name.len(),\n                type_category: e.function_type === 'scalar' ? 'SCALAR' : 'OTHER',\n                has_description: !e.description.IsNull()\n            }))\n    })\n).from('enhanced_functions')\n    .select()\n    .execute() satisfies {\n        original_name: string\n        name_length: number\n        type_category: string\n        has_description: boolean\n    }[]\n\nconsole.log('WITH clause result:', withClauseResult.slice(0, 3))\n\n// ================================\n// 🔗 UNION & EXCEPT OPERATIONS - Combine datasets intelligently\n// ================================\n\n// Union different datasets with compatible schemas\nconst unionResult = await MemoryDB.from('duckdb_functions()')\n    .select(f => ({ name: f.function_name, category: 'function' }))\n    .where(f => f.function_type === 'scalar')\n    .limit(3)\n    .union(\n        MemoryDB.from('duckdb_types()')\n            .select(t => ({\n                name: t.logical_type,\n                category: 'type'\n            }))\n            .limit(3)\n    )\n    .execute() satisfies {\n        name: string\n        category: string\n    }[]\n\nconsole.log('Union result:', unionResult)\n\n\n\n\n\n\n\n// Except operations - find differences between datasets\nconst exceptResult = await MemoryDB.from('duckdb_functions()')\n    .select(f => ({ name: f.function_name }))\n    .where(f => f.function_name.len() < 10)\n    .except(\n        MemoryDB.from('duckdb_functions()')\n            .select(f => ({ name: f.function_name }))\n            .where(f => f.function_name.Like('%string%'))\n    )\n    .limit(5)\n    .execute() satisfies {\n        name: string\n    }[]\n\nconsole.log('Except result:', exceptResult)\n\n\n\n\n\n\n// ================================\n// 🎭 COMPLEX CONDITIONAL EXPRESSIONS - Advanced type inference\n// ================================\n\n// Complex conditional logic with proper type inference\nconst conditionalTypesResult = await MemoryDB.from('duckdb_functions()')\n    .select((e, D) => ({\n        function_name: e.function_name,\n\n        // 🔥 Mixed type conditionals - string | number\n        flexible_result: e.function_name === 'sum' ? 42 : e.function_name,\n\n        // 🔥 Number conditionals with explicit typing\n        id_category: e.function_oid > 100 ? 'HIGH_ID' : 'LOW_ID',\n\n        // 🔥 Complex nested conditionals\n        complexity_score: e.function_name.len() > 15 ? 'VERY_COMPLEX' :\n            e.function_name.len() > 10 ? 'COMPLEX' :\n                e.function_name.len() > 5 ? 'MEDIUM' : 'SIMPLE',\n        // 🔥 Template literals in conditionals\n        status_message: e.function_name.len() > 10\n            ? `Long function: ${e.function_name}`\n            : `Short: ${e.function_name}`,\n    }))\n    .where(e => (\n        e.function_name.Like('%agg%') || e.function_name.Like('%sum%')\n    ))\n    .limit(5)\n    .execute() satisfies {\n        function_name: string\n        flexible_result: string | number\n        id_category: string\n        complexity_score: string\n        status_message: string\n    }[]\n\nconsole.log('Conditional types:', conditionalTypesResult)\n\n// ================================\n// 🏭 STRUCT OPERATIONS - Complex nested data\n// ================================\n\n// Working with structured data using D.Struct\nconst structOperationsResult = await MemoryDB.from('duckdb_functions()')\n    .select((e, D) => ({\n        function_name: e.function_name,\n\n        // 🔥 Create complex nested structures\n        metadata: D.Struct({\n            name: e.function_name,\n            details: {\n                length: e.function_name.len(),\n                type: e.function_type,\n                has_underscore: e.function_name.Like('%_%')\n            },\n            tags: ['function', 'database', 'operation']\n        }),\n\n        // 🔥 Dynamic struct creation\n        analysis: D.Struct({\n            complexity: e.function_name.len() > 10 ? 'HIGH' : 'LOW',\n            score: e.function_name.len() * 2,\n            categories: [e.function_type, 'utility']\n        }),\n\n        // 🔥 Simple property access\n        name_length: e.function_name.len(),\n    }))\n    .limit(3)\n    .execute() satisfies {\n        function_name: string\n        metadata: {\n            name: string\n            details: {\n                length: number\n                type: string\n                has_underscore: boolean\n            }\n            tags: string[]\n        }\n        analysis: {\n            complexity: string\n            score: number\n            categories: string[]\n        }\n        name_length: number\n    }[]\n\nconsole.log('Struct operations:', structOperationsResult)\n\n// ================================\n// 🔄 ARRAY TRANSFORMATIONS - Advanced processing\n// ================================\n\n// Advanced array transformations and reductions\nconst arrayTransformationsResult = await MemoryDB.from('duckdb_functions()')\n    .select((e, D) => ({\n        function_name: e.function_name,\n\n        // 🔥 Array transformations with D.array_transform\n        char_analysis: D.array_transform(e.function_name.str_split(''),\n            char => ({\n                character: char,\n                is_vowel: D.Array(['a', 'e', 'i', 'o', 'u']).array_contains(char.lower()),\n                length: char.len()\n            })\n        ),\n\n        // 🔥 Array filtering with conditions\n        vowels_only: e.function_name.str_split('')\n            .array_filter(char => D.Array(['a', 'e', 'i', 'o', 'u']).array_contains(char.lower())),\n\n        // 🔥 Array reductions using reduce\n        total_char_count: e.function_name.str_split('')\n            .map(char => char.len())\n            .reduce((acc, curr) => acc + curr, 0),\n\n        // 🔥 Complex array operations\n        processed_segments: D.Array(['prefix', 'main', 'suffix'])\n            .map(segment => segment + '_processed')\n            .filter(result => result.len() < 20),\n    }))\n    .where(e => e.function_name.len() < 15)  // Keep examples manageable\n    .limit(3)\n    .execute() satisfies {\n        function_name: string\n        char_analysis: { character: string; is_vowel: boolean; length: number }[]\n        vowels_only: string[]\n        total_char_count: number\n        processed_segments: string[]\n    }[]\n\nconsole.log('Array transformations:', arrayTransformationsResult)\n\n// ================================\n// 🎨 TEMPLATE LITERALS - Advanced string composition\n// ================================\n\n// Complex template literal usage\nconst templateLiteralsResult = await MemoryDB.from('duckdb_functions()')\n    .select((e, D) => ({\n        // 🔥 Multi-line template literals\n        detailed_description: `Function: ${e.function_name}\nType: ${e.function_type}\nLength: ${e.function_name.len()} characters\nCategory: ${e.function_name.len() > 10 ? 'Complex' : 'Simple'}\nStatus: ${e.description.IsNull() ? 'No docs' : 'Documented'}`,\n\n        // 🔥 Conditional template literals\n        summary: e.function_type === 'scalar'\n            ? `⚡ SCALAR: ${e.function_name} (${e.function_name.len()})`\n            : `📊 ${e.function_type.upper()}: ${e.function_name}`,\n\n        // 🔥 Complex expressions in templates\n        analysis_report: `${e.function_name} | Score: ${e.function_name.len() * 2} | ${e.function_name.Like('%_%') ? 'Multi-word' : 'Single-word'\n            } | ${e.function_type}`,\n    }))\n    .limit(3)\n    .execute() satisfies {\n        detailed_description: string\n        summary: string\n        analysis_report: string\n    }[]\n\nconsole.log('Template literals:', templateLiteralsResult)\n\n// ================================\n// 🚀 MIXED RESULT TYPES - Flexible returns\n// ================================\n\n// Different return types based on query structure\nconst mixedResultsArray = await MemoryDB.from('duckdb_functions()')\n    .select(e => e.function_name.len() > 10 ? 42 : 'short')\n    .limit(5)\n    .execute() satisfies (number | string)[]\n\nconst mixedResultsTuple = await MemoryDB.from('duckdb_functions()')\n    .select(e => [e.function_name, e.function_name.len()])\n    .limit(3)\n    .execute() satisfies [string, number][]\n\nconst mixedResultsString = await MemoryDB.from('duckdb_functions()')\n    .select(e => `${e.function_name}: ${e.function_name.len()}`)\n    .limit(3)\n    .execute() satisfies string[]\n\nconsole.log('Mixed results:', { mixedResultsArray, mixedResultsTuple, mixedResultsString })\n\n// ================================\n// 🎯 ADVANCED GROUPING PATTERNS\n// ================================\n\n// GroupBy with array aggregations - returns Record<string, T[]>\nconst advancedGrouping = await MemoryDB.from('duckdb_functions()')\n    .select((e, D) => ({\n        function_type: e.function_type,\n        function_names: D.array_agg(e.function_name),\n        avg_length: D.avg(e.function_name.len()),\n        count: D.count(),\n        samples: D.array_agg(e.function_name).slice(0, 3)\n    }))\n    .groupBy('function_type')\n    .having(e => e.avg_length > 5)\n    .execute() satisfies Record<string, {\n        function_type: string\n        function_names: string[]\n        avg_length: number\n        count: number\n        samples: string[]\n    }[]>\n\nconsole.log('Advanced grouping keys:', Object.keys(advancedGrouping).slice(0, 3))\n\n// ================================\n// 🔧 SPECIAL OPERATIONS\n// ================================\n\n// keyBy creates Record<string, T> lookup structures\nconst lookupTable = await MemoryDB.from('duckdb_functions()')\n    .select((e, D) => ({\n        function_name: e.function_name,\n        details: D.array_agg(e.description),\n        metadata: {\n            type: e.function_type,\n            length: e.function_name.len()\n        }\n    }))\n    .keyBy('function_name')\n    .execute() satisfies Record<string, {\n        function_name: string\n        details: string[]\n        metadata: {\n            type: string\n            length: number\n        }\n    }>\n\nconsole.log('Lookup table sample keys:', Object.keys(lookupTable).slice(0, 3))\n\n// distinctOn for unique values with additional criteria\nconst distinctFunctions = await MemoryDB.from('duckdb_functions()')\n    .select(e => ({\n        function_type: e.function_type,\n        first_function: e.function_name,\n        length: e.function_name.len()\n    }))\n    .distinctOn('function_type', e => e.function_name.len())\n    .execute() satisfies {\n        function_type: string\n        first_function: string\n        length: number\n    }[]\n\nconsole.log('Distinct functions:', distinctFunctions)\n\n/*\n🚀 Advanced BuckDB Features Showcased:\n\n✨ ARRAY OPERATIONS: str_split, array_transform, array_filter with real syntax\n✨ WITH CLAUSES: Multi-step CTEs for complex transformations  \n✨ UNION/EXCEPT: Combine and compare datasets elegantly\n✨ CONDITIONAL TYPES: Advanced type inference with mixed returns\n✨ STRUCT OPERATIONS: Nested object creation and manipulation\n✨ ARRAY TRANSFORMATIONS: Complex array processing with map/filter/reduce\n✨ TEMPLATE LITERALS: Multi-line string composition with expressions\n✨ MIXED RETURNS: Flexible result types (arrays, tuples, strings)\n✨ GROUPING PATTERNS: Record<string, T[]> and Record<string, T> structures\n✨ SPECIAL OPS: keyBy, distinctOn for advanced data manipulation\n✨ TYPE SAFETY: Every operation maintains TypeScript type safety\n\n🎯 Next: Explore joins, window functions, and analytical operations!\n*/\n\nconsole.log('🎉 Advanced transformations mastered!')\n";export{n as default};
