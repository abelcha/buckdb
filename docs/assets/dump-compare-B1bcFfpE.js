const n="const terminalColWidth = parseFloat(await Bun.$`tput cols`.text())\n\nconst printClamped = (str, clampedLength) => str.length > clampedLength ? (str.substring(0, clampedLength - 1) + 'â€¦') : str.padEnd(clampedLength, ' ');\n\nexport function dumpSideBySide(...expressions: string[]): void {\n  if (expressions.length < 2) {\n    throw new Error('At least 2 expressions are required for side-by-side comparison');\n  }\n\n  const terminalWidth = process.stdout.columns || 80;\n  \n  // Calculate individual column widths based on content (with padding)\n  const padding = 2; // 1 space on each side\n  const columnWidths = expressions.map(expr => {\n    const lines = expr.split('\\n');\n    return Math.max(...lines.map(line => line.length)) + padding;\n  });\n  \n  // Calculate total needed width (content + separators + borders)\n  const separatorWidth = 1; // '|'\n  const borderWidth = 2; // '|' on each side\n  const totalNeededWidth = columnWidths.reduce((sum, width) => sum + width, 0) + \n                          (expressions.length - 1) * separatorWidth + \n                          borderWidth;\n  \n  // Use the minimum of total needed width and terminal width\n  const boxWidth = Math.min(totalNeededWidth, terminalWidth);\n  \n  // Recalculate column widths if we need to fit within terminal\n  let finalColumnWidths: number[];\n  if (totalNeededWidth > terminalWidth) {\n    const availableWidth = terminalWidth - (expressions.length - 1) * separatorWidth - borderWidth;\n    const totalContentWidth = columnWidths.reduce((sum, width) => sum + width, 0);\n    finalColumnWidths = columnWidths.map(width => \n      Math.max(padding + 3, Math.floor((width / totalContentWidth) * availableWidth)) // Ensure minimum width\n    );\n  } else {\n    finalColumnWidths = columnWidths;\n  }\n\n  // Split expressions into lines\n  const expressionLines = expressions.map(expr => expr.split('\\n'));\n  const maxLines = Math.max(...expressionLines.map(lines => lines.length));\n\n  // Create top border\n  const topBorderParts = finalColumnWidths.map(width => '-'.repeat(width));\n  console.log('+' + topBorderParts.join('+') + '+');\n\n  // Print each line\n  for (let i = 0; i < maxLines; i++) {\n    const lineParts: string[] = [];\n    \n    for (let j = 0; j < expressions.length; j++) {\n      const line = expressionLines[j][i] || '';\n      const maxContentWidth = finalColumnWidths[j] - padding;\n      const clampedLine = line.length > maxContentWidth \n        ? line.substring(0, maxContentWidth - 3) + '...'\n        : line;\n      const paddedLine = (' ' + clampedLine).padEnd(finalColumnWidths[j] - 1) + ' ';\n      lineParts.push(paddedLine);\n    }\n    \n    console.log('|' + lineParts.join('|') + '|');\n  }\n\n  // Create bottom border\n  const bottomBorderParts = finalColumnWidths.map(width => '-'.repeat(width));\n  console.log('+' + bottomBorderParts.join('+') + '+');\n}\n\nif (import.meta.main) {\n\n    // Example with 2 parameters (original functionality)\n    dumpSideBySide(`\nBuck().from('duckdb_functions()')\n    .select()\n    .where(e =>\n        e.function_name.Like('%str%') &&\n        e.function_name.len().Between(3, 12) &&\n        !e.description.IsNull()\n    )\n    `, `\nFROM duckdb_functions()\n    SELECT *\n    WHERE\n        (function_name LIKE '%str%' AND\n        function_name.len() BETWEEN 3 AND 12 AND\n        description IS NOT NULL)`);\n\n    // Example with 3 parameters\n    dumpSideBySide(\n        `Buck().from('users')\n    .select('name', 'age')\n    .where(u => u.age > 18)`,\n\n        `SELECT name, age\n    FROM users\n    WHERE age > 18`,\n\n        `db.users.find(\n        { age: { $gt: 18 } },\n        { name: 1, age: 1 }\n    )`\n    );\n\n    // Example with 4 parameters\n    dumpSideBySide(\n        `// JavaScript\nconst result = data\n    .filter(x => x > 5)\n    .map(x => x * 2)`,\n\n        `-- SQL\nSELECT value * 2\nFROM data\nWHERE value > 5`,\n\n        `# Python\nresult = [\n    x * 2 for x in data\n    if x > 5\n]`,\n\n        `// Rust\nlet result: Vec<i32> = data\n    .iter()\n    .filter(|&&x| x > 5)\n    .map(|&x| x * 2)\n    .collect();`\n    )\n    /*\n                                                    |                                                                                                              \n    Buck().from('duckdb_functions()')               | FROM duckdb_functions()                                                                                      \n        .select()                                   |     SELECT *                                                                                                 \n        .where(e =>                                 |     WHERE                                                                                                    \n            e.function_name.Like('%str%') &&        |         (function_name LIKE '%str%' AND                                                                      \n            e.function_name.len().Between(3, 12) && |         function_name.len() BETWEEN 3 AND 12 AND                                                             \n            !e.description.IsNull()                 |         description IS NOT NULL)                                                                             \n        )                                           |                                                                                                              \n                   \n    */\n}\n";export{n as default};
