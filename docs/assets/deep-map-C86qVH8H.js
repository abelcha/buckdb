const e='import * as t from ".buck/types";\n\ntype Assert<T extends true> = T;\ntype ExpectEqual<A, B> = (<G>() => G extends A ? 1 : 2) extends (<G>() => G extends B ? 1 : 2) ? (<G>() => G extends B ? 1 : 2) extends (<G>() => G extends A ? 1 : 2) ? true\n  : { error: "Types are not equal"; expected: B; got: A }\n  : { error: "Types are not equal"; expected: B; got: A };\n\n// Original NestedKeyOf - recurses into all objects (includes prototype methods)\nexport type NestedKeyOf<ObjectType extends Record<string, any>> = {\n  [Key in keyof ObjectType & (string | number)]: ObjectType[Key] extends object\n  ? `${Key}` | `${Key}.${NestedKeyOf<ObjectType[Key]>}`\n  : `${Key}`\n}[keyof ObjectType & (string | number)]\n\n// Option 1: Exclude common built-in types (Array, Map, Set, Date, etc.)\nexport type NestedKeyOf1<ObjectType extends Record<string, any>> = {\n  [Key in keyof ObjectType & (string | number)]: ObjectType[Key] extends Array<any> | Map<any, any> | Set<any> | Date | RegExp | Function\n  ? `${Key}`\n  : ObjectType[Key] extends object\n  ? `${Key}` | `${Key}.${NestedKeyOf1<ObjectType[Key]>}`\n  : `${Key}`\n}[keyof ObjectType & (string | number)]\n\n// Option 2: Only recurse into plain objects (Record<string, any>) that aren\'t built-ins\nexport type NestedKeyOf2<ObjectType extends Record<string, any>> = {\n  [Key in keyof ObjectType & (string | number)]: ObjectType[Key] extends Record<string, any>\n  ? ObjectType[Key] extends Array<any> | Map<any, any> | Set<any> | Date | RegExp | Function\n  ? `${Key}`\n  : `${Key}` | `${Key}.${NestedKeyOf2<ObjectType[Key]>}`\n  : `${Key}`\n}[keyof ObjectType & (string | number)]\n\n\n\n// Option 4: Check if it has a prototype that\'s not Object.prototype (more strict)\ntype IsPlainObject<T> = T extends object\n  ? T extends Array<any> | Map<any, any> | Set<any> | Date | RegExp | Function | Promise<any>\n  ? false\n  : true\n  : false\n\nexport type NestedKeyOf4<ObjectType extends Record<string, any>> = {\n  [Key in keyof ObjectType & (string | number)]: IsPlainObject<ObjectType[Key]> extends true\n  ? `${Key}` | `${Key}.${NestedKeyOf4<ObjectType[Key]>}`\n  : `${Key}`\n}[keyof ObjectType & (string | number)]\n\n// Option 5: More comprehensive built-in type exclusion\nexport type NestedKeyOf5<ObjectType extends Record<string, any>> = {\n  [Key in keyof ObjectType & (string | number)]: ObjectType[Key] extends\n  | Array<any>\n  | Map<any, any>\n  | Set<any>\n  | WeakMap<any, any>\n  | WeakSet<any>\n  | Date\n  | RegExp\n  | Function\n  | Promise<any>\n  | Error\n  | Number\n  | String\n  | Boolean\n  ? `${Key}`\n  : ObjectType[Key] extends object\n  ? `${Key}` | `${Key}.${NestedKeyOf5<ObjectType[Key]>}`\n  : `${Key}`\n}[keyof ObjectType & (string | number)]\n\n// type nativ = ToJSON<Source>\ntype res1 =\n  & Assert<ExpectEqual<ToPlain<t.DVarcharField>, string>>\n  & Assert<ExpectEqual<ToPlain<string>, string>>\n  & Assert<ExpectEqual<ToPlain<t.DNumericField>, number>>\n  & Assert<ExpectEqual<ToPlain<t.DBoolField>, boolean>>\n  & Assert<ExpectEqual<ToPlain<t.DDateField>, Date>>\n  & Assert<ExpectEqual<ToPlain<t.DAnyField>, any>>\n  & Assert<ExpectEqual<ToPlain<t.DMapField>, Map<any, any>>>\n  & Assert<ExpectEqual<ToPlain<t.DArrayField<t.DNumericField>>, number[]>>\n  & Assert<ExpectEqual<ToPlain<t.DArrayField<t.DArrayField<t.DNumericField>>>, number[][]>>\n  & Assert<ExpectEqual<ToPlain<t.DNumericField[]>, number[]>>\n  & Assert<ExpectEqual<ToPlain<{ xx: t.DNumericField }[]>, { xx: number }[]>>\n  & Assert<ExpectEqual<ToPlain<{ xx: { zz: t.DNumericField }[] }>, { xx: { zz: number }[] }>>\n  & Assert<\n    ExpectEqual<\n      ToPlain<\n        t.DStructField<{ xx: t.DArrayField<t.DStructField<{ zz: t.DNumericField }>> }>\n      >,\n      { xx: { zz: number }[] }\n    >\n  >\n  & Assert<\n    ExpectEqual<\n      ToPlain<\n        t.DStructField<{ xx: t.DStructField<{ zz: t.DVarcharField }>[] }>\n      >,\n      { xx: { zz: string }[] }\n    >\n  >\n  & Assert<\n    ExpectEqual<\n      ToPlain<\n        t.DStructField<{ xx: t.DStructField<string> }>\n      >,\n      { xx: string }\n    >\n  >\n  & Assert<\n    ExpectEqual<\n      ToPlain<\n        t.DStructField<{ xx: t.DStructField<{ zz: t.DStructField<{}> }> }>\n      >,\n      { xx: { zz: {} } }\n    >\n  >\n  & Assert<\n    ExpectEqual<\n      ToPlain<\n        t.DStructField<{ xx: t.DStructField<{ zz: t.DStructField<{}> }> }>\n      >,\n      { xx: { zz: {} } }\n    >\n  >\n  & Assert<\n    ExpectEqual<\n      ToPlain<\n        t.DStructField<{ xx: t.DStructField<{ zz: t.DStructField<{ u: t.DNumericField[] }> }> }>\n      >,\n      { xx: { zz: { u: number[] } } }\n    >\n  >\n  & Assert<ExpectEqual<ToPlain<null>, null>>\n  & Assert<ExpectEqual<ToPlain<undefined>, undefined>>\n  & Assert<ExpectEqual<ToPlain<[t.DVarcharField, t.DNumericField]>, [string, number]>>;\n\nexport type ToPlain<T> =\n  /* 1. arrays first so we “peel off” outer [] layers  */\n  T extends null | undefined ? T\n  : T extends readonly [any, ...any[]] ? { [K in keyof T]: ToPlain<T[K]> } // tuple handling\n  : T extends t.DArrayField<infer U> ? ToPlain<U>[]\n  : T extends Array<infer U> ? ToPlain<U>[]\n  // /* 2. structs: rebuild an object, recursing on every member */\n  : T extends t.DStructField<infer S> ? { [K in keyof S]: ToPlain<S[K]> }\n  // /* 3. primitive wrappers */\n  : T extends t.DVarcharField | t.DJsonField | string ? string\n  : T extends t.DNumericField | number ? number\n  : T extends t.DBoolField | boolean ? boolean\n  : T extends t.DDateField | Date ? Date\n  : T extends t.DMapField ? Map<any, any>\n  : T extends Map<any, any> ? T\n  : T extends t.DAnyField ? any\n  // : T extends { [Symbol(\'__V\')]: never } ? never :\n  : T extends object ? { [K in keyof T]: ToPlain<T[K]> }\n  /* 4. everything else is a mistake */\n  : never;\n\nexport type UnPlain<T> =\n  T extends t.DArrayField<infer U> ? t.DArrayField<UnPlain<U>>\n  : T extends Array<infer U> ? t.DArrayField<UnPlain<U>>\n  : T extends string ? t.DVarcharField\n  : T extends number ? t.DNumericField\n  : T extends boolean ? t.DBoolField\n  // : T extends object ? t.DStructField<{ [K in keyof T]: UnPlain<T[K]> }>\n  : T\nexport type FromPlainDict<T extends object> = { [K in keyof T]: UnPlain<T[K]> }\n\nexport type FromPlain<T> =\n  T extends t.DArrayField<infer U> ? t.DArrayField<FromPlain<U>>\n  : T extends Array<infer U> ? t.DArrayField<FromPlain<U>>\n  : T extends t.DStructField ? { [K in keyof T]: FromPlain<T[K]> }\n  : T extends t.DVarcharField | string ? t.DVarcharField\n  : T extends t.DMapField | Map<any, any> ? t.DMapField\n  : T extends t.DNumericField | number ? t.DNumericField\n  : T extends t.DBoolField | boolean ? t.DBoolField\n  : T extends t.DDateField | Date ? t.DDateField\n  : T extends t.DAnyField ? t.DAnyField\n  : T extends object ? t.DStructField<{ [K in keyof T]: FromPlain<T[K]> }>\n  : never;\ntype res2 =\n  & Assert<ExpectEqual<FromPlain<string>, t.DVarcharField>>\n  & Assert<ExpectEqual<FromPlain<number>, t.DNumericField>>\n  & Assert<ExpectEqual<FromPlain<{ xx: number }>, t.DStructField<{ xx: t.DNumericField }>>>\n  & Assert<ExpectEqual<FromPlain<{ xx: number }[]>, t.DArrayField<t.DStructField<{ xx: t.DNumericField }>>>>\n  & Assert<ExpectEqual<FromPlain<[number, string]>, t.DArrayField<t.DVarcharField | t.DNumericField>>> // ??\n  & Assert<\n    ExpectEqual<\n      FromPlain<{ xx: { zz: 12; xx: "123" }[] }>,\n      t.DStructField<{ xx: t.DArrayField<t.DStructField<{ zz: t.DNumericField; xx: t.DVarcharField }>> }>\n    >\n  > & Assert<\n    ExpectEqual<\n      ToPlain<t.DArrayField<t.DStructField<{ id: t.DVarcharField; value: t.DNumericField }>>>,\n      { id: string; value: number }[]\n    >\n  >;\n';export{e as default};
