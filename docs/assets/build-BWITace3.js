const e="import * as t from '.buck/types'\nimport { DuckdbCon } from '@buckdb/core'\nimport { DBuilder } from './build.types'\nimport { dump, formalize, serializeCreate, toSql } from './formalise'\nimport { serializeSchema } from './interface-generator'\nimport { parse, parseObject } from './parser'\nimport { DCte, DDatasource, DOrder, DSelectee, dstate, DState, Parseable } from './typedef'\nimport { deriveName, isBucket, keyBy, last, upperFirst, wrap, Σ } from './utils'\n\nexport const deriveState = (s: DState, kmap: Record<keyof DState | string, any | any[]>, format = (e: any) => e) => {\n    return Object.entries(kmap).reduce((acc, [key, values]) => {\n        if (!Array.isArray(values)) {\n            return { ...acc, [key]: values }\n        }\n        const newVals = values.map(v => formalize(v, s.context)).map(format)\n        return Object.assign(acc, { [key]: (s[key as keyof DState] as any[] || []).concat(newVals) })\n    }, s) as DState\n}\n\nconst parseArgs = (args: any[]) => {\n    const handle = typeof args[0] === 'string' ? args[0] : ''\n    const opts = (typeof args[0] === 'object' ? args[0] : (args[1] || {})) as Partial<t.DSettings>\n    return { handle, opts }\n}\n\nexport const builder = (Ddb: new (...args: any[]) => DuckdbCon) =>\n    function database(...args: any[]) {\n        const { handle, opts } = parseArgs(args)\n        const ddb = new Ddb(handle, opts)\n        if (opts && Object.keys(opts).length && ddb.type === 'wasm') {\n            ddb.lazySettings(opts)\n\n        }\n        if (handle && handle !== ':memory:' && ddb.type in Σ('remote', 'wasm') && !isBucket(handle)) {\n            ddb.lazyAttach(handle, deriveName(handle), { readonly: ddb.type === 'wasm' })\n        }\n        const fromRes = (state: DState) => {\n            const _join = (joinType: DDatasource['join'] = 'JOIN') =>\n                function (table: any, alias: any) {\n                    const rep = ({ joinOn, using }: Record<string, any>) => fromRes(deriveState(state, { datasources: [{ catalog: handle, uri: table, alias, join: joinType, joinOn, using }] }))\n                    return {\n                        using: (using: string) => rep({ using }),\n                        on: (on: Function) => rep({ joinOn: parse(on) }),\n                    }\n                }\n            const _where = (operator = 'AND') =>\n                function (...conditions: Parseable[]) {\n                    return fromRes(deriveState(state, { conditions: conditions.map(v => formalize(v, state.context)) }, condition => ({ condition, operator })))\n                }\n            const execute = async function (props: Record<string, any> = {}) {\n                // console.log(state)\n                const formatAGG = (e: Promise<any>) => state.agg ? e.then(resp => resp[0]) : e\n                const str = toSql(Object.assign(state, props))\n                if (state.ctes.length) {\n                    const ctEntries = state.ctes.map(e => [e.name, e.query.toState().datasources])\n                    const fnamed = ctEntries.map(x => x[0])\n                    const cteDS = ctEntries.flatMap(z => (z[1] as any).concat(...state.datasources).filter(e => !fnamed.includes(e.uri)))\n                    for await (const dt of cteDS) {\n                        await ddb.ensureSchema(dt.uri)\n                    }\n                } else {\n                    for await (const dt of state.datasources) {\n                        await ddb.ensureSchema(dt.uri)\n                    }\n                }\n                if (state.selected.length === 1) {\n                    const [{ as, raw, field }] = state.selected\n                    if ((as === null && !raw && field) || raw) {\n                        return ddb.query(str, { rows: true, ...props }).then(resp => resp.map(e => e[0]))\n                    }\n                }\n                if (state.selected.length && state.selected.every((e) => typeof e.as === 'number')) {\n                    return formatAGG(ddb.query(str, { rows: true, ...props }))\n                }\n                if (state?.keyBy) {\n                    return ddb.query(str, props).then(resp => keyBy(resp, state.keyBy as string))\n                }\n                return formatAGG(ddb.query(str, props))\n            }\n            return {\n                ddb,\n                join: _join('JOIN'),\n                leftJoin: _join('LEFT JOIN'),\n                rightJoin: _join('RIGHT JOIN'),\n                crossJoin: (a, b) => _join('CROSS JOIN')(a, b).using(undefined),\n                naturalJoin: _join('NATURAL JOIN'),\n                innerJoin: _join('INNER JOIN'),\n                set: function (...keys: Parseable[]) {\n                    const updated = keys.flatMap(k => {\n                        if (typeof k === 'function') {\n                            const parsed = parseObject(k, state.context)\n                            return parsed.map(([value, key, raw]) => ({ field: key, as: value, raw })) as DSelectee[]\n                        } else return { field: k }\n                    })\n                    return fromRes({ ...state, updated })\n                },\n                select: function (...keys: Parseable[]) {\n                    const selected = keys.flatMap(k => {\n                        if (typeof k === 'function') {\n                            const parsed = parseObject(k, state.context)\n                            return parsed.map(([as, field, raw]) => ({ as, field, raw })) as DSelectee[]\n                        }\n                        return { field: k }\n                    })\n                    return fromRes({ ...state, selected })\n                },\n                copyTo: function (uri: string, options: Record<string, any> = {}) {\n                    return fromRes({ ...state, copyTo: [...state.copyTo, { uri, options }] })\n                },\n                where: _where('AND'),\n                or: _where('OR'),\n                and: _where('AND'),\n                // Updated orderBy: Accepts single Parseable field, uses 'direction'\n                orderBy: function (...params: any[]) {\n                    if (params.length <= 2 && params.every(p => !Array.isArray(p))) {\n                        params = [params]\n                    }\n                    const nworder = (params as string[][]).map(([field, direction]) => ({ field: formalize(field), direction }))\n                    return fromRes({ ...state, orderBy: [...(state.orderBy || []), ...nworder] as DOrder[] }) // Use 'direction'\n                },\n                context: function (context: Record<string, any>) {\n                    return fromRes({ ...state, context: { ...state.context, ...context } })\n                },\n                groupBy: function (...groupBy: Parseable[]) {\n                    return fromRes(deriveState(state, { groupBy }))\n                },\n                distinctOn: function (...distinctOn: Parseable[]) {\n                    return fromRes(deriveState(state, { distinctOn }))\n                },\n                keyBy: function (gp: Parseable) {\n                    const keyBy = formalize(gp, state.context)\n                    if (!state.selected.find(e => e.field === keyBy)) {\n                        state.selected.push({ field: keyBy })\n                    }\n                    return fromRes(deriveState({ ...state, selected: state.selected, keyBy }, { groupBy: [gp] }))\n                },\n                minBy: function (...fields: Parseable[]) {\n                    // return this.orderBy(fields, 'ASC').limit(10)\n                    return fromRes(deriveState({ ...state, agg: 'min', limit: 1 }, { orderBy: fields }, field => ({ field, direction: 'ASC' })))\n                },\n                countBy: function (gp: Parseable) {\n                    const countBy = formalize(gp, state.context)\n                    if (!state.selected.find(e => e.field === countBy)) {\n                        state.selected.push({ field: countBy, as: 0 })\n                    }\n                    if (!state.selected.find(e => e.raw === countBy)) {\n                        state.selected.push({ field: 'count(*)::int', as: 1 })\n                    }\n                    return fromRes(deriveState({ ...state, selected: state.selected, countBy }, { groupBy: [gp], orderBy: [{ field: 'count(*)', direction: 'DESC' }] }))\n                },\n                maxBy: function (...fields: Parseable[]) {\n                    return fromRes(deriveState({ ...state, agg: 'max', limit: 1 }, { orderBy: fields }, field => ({ field, direction: 'DESC' })))\n                },\n                having: function (...having: Parseable[]) {\n                    return fromRes(deriveState(state, { having }, condition => ({ condition, operator: 'AND' })))\n                },\n                limit: function (limit: number) {\n                    return fromRes({ ...state, limit })\n                },\n                sample: function (sample: any) {\n                    return fromRes({ ...state, sample })\n                },\n                offset: function (offset: number) {\n                    return fromRes({ ...state, offset })\n                },\n                ensureSchemas: async function () {\n                    for await (const dt of state.datasources) {\n                        await ddb.ensureSchema(dt.uri)\n                    }\n                },\n                union: (q) => fromRes({ ...state, setops: state.setops.concat({ type: 'UNION', value: q.toSql() }) }),\n                unionAll: (q) => fromRes({ ...state, setops: state.setops.concat({ type: 'UNION ALL', value: q.toSql() }) }),\n                unionByName: (q) => fromRes({ ...state, setops: state.setops.concat({ type: 'UNION BY NAME', value: q.toSql() }) }),\n                unionAllByName: (q) => fromRes({ ...state, setops: state.setops.concat({ type: 'UNION ALL BY NAME', value: q.toSql() }) }),\n                except: (q) => fromRes({ ...state, setops: state.setops.concat({ type: 'EXCEPT', value: q.toSql() }) }),\n                exceptAll: (q) => fromRes({ ...state, setops: state.setops.concat({ type: 'EXCEPT ALL', value: q.toSql() }) }),\n                intersect: (q) => fromRes({ ...state, setops: state.setops.concat({ type: 'INTERSECT', value: q.toSql() }) }),\n                intersectAll: (q) => fromRes({ ...state, setops: state.setops.concat({ type: 'INTERSECT ALL', value: q.toSql() }) }),\n                exec: execute,\n                execute,\n                toState: () => state,\n                dump: (opts: any) => { dump(state, opts); return fromRes(state) },\n                show: async function (opts: any) {\n                    return this.dump(opts).execute().then(e => {\n                        // @ts-ignore\n                        BigInt.prototype.toJSON = function () { return this.toString() }\n                        if (opts?.json) console.log(JSON.stringify(e, null, 2))\n                        if (opts?.js) console.log(e[0])\n                        else console.table(e.slice(0, 10))\n                        // console[opts?.table === false ? 'log' : 'table'](e);\n                        return e\n                    })\n                },\n                toSql: function (props = { pretty: false }) {\n                    return toSql(Object.assign(state, props))\n                },\n            }\n        }\n        return {\n            ddb,\n            run: (sql: string) => ddb.run(sql),\n            settings: function (s: Partial<t.DSettings>) {\n                ddb.lazySettings(s)\n                return this\n            },\n            fetchTables: async function (id: string) {\n                const resp = await ddb.query(`SELECT * FROM duckdb_tables()`)\n                return Object.fromEntries(resp.map(e => [upperFirst(e.table_name), serializeSchema(e.sql)]))\n            },\n            loadExtensions: function (...ext: t.DExtensions[]) {\n                ddb.lazyExtensions(...ext as string[])\n                return this\n            },\n            macros: function (obj: any) {\n                ddb.lazyMacros(obj)\n                return this\n            },\n            with: function (...arr: (() => any)[]) {\n                // @ts-ignore\n                const ctes = arr.flatMap(x => Object.entries(x(this))).map(([k, v], i) => ({ name: k, query:v }) as DCte)\n                return {\n                    from: (table: string, alias?: string) =>\n                        fromRes({ ...dstate, ctes, action: 'select', datasources: [{ catalog: handle, uri: table, alias: alias }] }),\n                }\n            },\n            describe: (uri: string) => ddb.describe(uri),\n            from: (table: string, alias?: string) =>\n                fromRes({ ...dstate, action: 'select', datasources: [{ catalog: handle, uri: table, alias: alias }] }),\n            update: (table: string, alias?: string) =>\n                fromRes({ ...dstate, action: 'update', datasources: [{ catalog: handle, uri: table, alias: alias }] }),\n            create: (table: string, p: Partial<{ replace: boolean; ifNotExists: boolean }> = {}) => ({\n                toSql: () => table,\n                as: (...items: any[]) => ({\n                    toSql: () => serializeCreate(table, items, p),\n                    execute: () => ddb.run(serializeCreate(table, items, p))\n                        .then(() => ddb.ensureSchema(table)),\n                }),\n            }),\n        }\n        // } as unknown as typeof DBuilder\n        // return fromRes as unknown as typeof DBuilder\n    } as unknown as typeof DBuilder\n";export{e as default};
