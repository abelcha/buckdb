const n="import { builder } from './src/build'\nimport { delta_scan, parquet_scan, read_csv, read_json, read_json_objects, read_parquet, read_text, read_xlsx } from './io'\nexport { delta_scan, parquet_scan, read_csv, read_json, read_json_objects, read_parquet, read_text, read_xlsx }\n// @ts-ignore\n// import type * as DuckdbTyped from '@duckdb/duckdb-wasm/dist/types/src/index'\n// // @ts-ignore\n// import * as _Duckdb from 'https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.28.1-dev106.0/+esm'\nimport { BuckDBBase } from './core'\nimport { isBucket } from './src/utils'\n// const Duckdb = _Duckdb as typeof DuckdbTyped\n\nclass BuckDBWasm extends BuckDBBase {\n    readonly type = 'wasm' as const\n    _db: DuckdbTyped.AsyncDuckDB = null\n    _con: DuckdbTyped.AsyncDuckDBConnection | null = null\n    _initPromise: Promise<void> | null = null\n\n    private _initDB(): Promise<void> {\n        // If initialization is already in progress or done, return the existing promise/resolved promise\n        if (this._initPromise) {\n            return this._initPromise\n        }\n        if (this._db && this._con) {\n            return Promise.resolve()\n        }\n\n        // Start initialization\n        this._initPromise = (async () => {\n            const JSDELIVR_BUNDLES = Duckdb.getJsDelivrBundles()\n            const bundle = await Duckdb.selectBundle(JSDELIVR_BUNDLES)\n\n            const worker_url = URL.createObjectURL(\n                new Blob([`importScripts(\"${bundle.mainWorker}\");`], { type: 'text/javascript' }),\n            )\n\n            const worker = new Worker(worker_url)\n            const logger = new Duckdb.VoidLogger()\n            const db = new Duckdb.AsyncDuckDB(logger, worker)\n\n            await db.instantiate(bundle.mainModule, bundle.pthreadWorker)\n            URL.revokeObjectURL(worker_url)\n            const path = isBucket(this.handle) ? ':memory:' : (this.handle || ':memory:')\n            await db.open({\n                path,\n                useDirectIO: true,\n                // accessMode: Duckdb.DuckDBAccessMode.READ_ONLY,\n                filesystem: {\n                    allowFullHTTPReads: true,\n                },\n                query: { castTimestampToDate: true, castBigIntToDouble: true },\n            })\n\n            this._db = db\n            this._con = await this._db.connect()\n            // @ts-ignore\n            window.db = this._con\n            // Don't clear the promise here, let it stay resolved\n        })()\n\n        return this._initPromise\n    }\n\n    async ensureSchema(uri: string) {\n        // todo\n    }\n\n    private async _executeQueuedCommands(): Promise<void> {\n        if (!this._con) throw new Error('Database connection not initialized.')\n        const cmds = this.queue.flush()\n        if (cmds.length > 0) {\n            for await (const cmd of cmds) {\n                // Use query for setup commands like attach, extensions, settings\n                // send might be slightly more appropriate for non-select, but query works\n                await this._con.query(cmd)\n            }\n        }\n    }\n\n    async query<T = Record<string, any>>(sql: string, opts: { rows?: boolean; withSchema?: boolean } = {}): Promise<T[]> {\n        await this._initDB()\n        await this._executeQueuedCommands() // Ensure setup commands run first\n        if (!this._con) throw new Error('Database connection not initialized.') // Should be initialized now\n\n        const reader = await this._con.query(sql)\n        let rtn = reader.toArray().map(e => e.toJSON() as T)\n\n        if (opts?.rows) {\n            rtn = rtn.map(row => Object.values(row)) as T[]\n        }\n        if (opts?.withSchema && !sql.trim().toUpperCase().startsWith('COPY')) {\n            const schemaReader = await this._con.query('DESCRIBE ' + sql)\n            const schema = schemaReader.toArray().map(e => e.toJSON())\n            console.log({ schema })\n            Object.defineProperty(rtn, 'schema', { value: schema, enumerable: false })\n        }\n        return rtn\n    }\n\n    async run(sql: string): Promise<void> {\n        await this._initDB()\n        await this._executeQueuedCommands() // Ensure setup commands run first\n        if (!this._con) throw new Error('Database connection not initialized.') // Should be initialized now\n\n        await this._con.send(sql)\n    }\n\n    async close(): Promise<void> {\n        // Only close if initialized\n        if (this._initPromise) {\n            await this._initPromise // Ensure init finishes before closing\n        }\n        if (this._con) {\n            await this._con.close()\n            this._con = null\n        }\n        if (this._db) {\n            await this._db.terminate()\n            this._db = null\n        }\n        this._initPromise = null // Reset init state\n    }\n}\n\n// Create a single instance for export\n\n// Pass the instance to the builder\nexport const Buck = builder(BuckDBWasm)\n\n// Maintain existing export pattern\nexport const MemoryDB = Buck('')\nexport const from = MemoryDB.from\n\n// Optional: Export the instance or class\n// export { BuckDBWasm, buckDBWasmInstance };\n";export{n as default};
