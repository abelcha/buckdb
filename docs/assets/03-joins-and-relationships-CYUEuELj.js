const n="// ðŸ”— BuckDB: Joins & Relationships Made Beautiful\n// Complex data relationships with simple JavaScript syntax\n\nimport { Buck, MemoryDB } from '@buckdb/isomorphic'\n\n// Use the memory database with DuckDB's built-in system tables\nconst db = MemoryDB\n\n// ================================\n// ðŸŽ¯ BASIC JOINS - Connect system tables effortlessly\n// ================================\n\n// Join DuckDB functions with their types - real system data!\nconst functionTypes = await MemoryDB.from('duckdb_functions()')\n    .join('duckdb_types()', 'types').on(({ duckdb_functions, types }) => \n        duckdb_functions.return_type === types.logical_type\n    )\n    .select(({ duckdb_functions, types }) => ({\n        // ðŸ”¥ Access fields from multiple tables\n        functionName: duckdb_functions.function_name,\n        returnType: duckdb_functions.return_type,\n        typeCategory: types.type_category,\n        \n        // ðŸ”¥ Cross-table calculations\n        complexity: duckdb_functions.function_name.len() + types.logical_type.len(),\n        \n        // ðŸ”¥ Conditional logic across tables\n        isStringFunction: types.logical_type === 'VARCHAR' ? 'Text Processing' : 'Other',\n        \n        // ðŸ”¥ Template literals with multiple table data\n        summary: `${duckdb_functions.function_name}() -> ${types.logical_type} (${types.type_category})`\n    }))\n    .where(({ duckdb_functions }) => \n        duckdb_functions.function_name.Like('%string%') ||\n        duckdb_functions.function_name.Like('%text%')\n    )\n    .limit(10)\n    .execute()\n\nconsole.log('Function-Type Relationships:', functionTypes)\n\n// ================================\n// ðŸŒŸ ADVANCED JOINS - Multiple tables with complex logic\n// ================================\n\n// Join functions, types, and settings for comprehensive analysis\nconst systemAnalysis = await MemoryDB.from('duckdb_functions()', 'f')\n    .join('duckdb_types()', 't').on(({ f, t }) => f.return_type === t.logical_type)\n    .join('duckdb_settings()', 's').on(({ f, s }) =>\n        f.function_name.upper().includes(s.name.upper())\n    )\n    .select(({ f, t, s }, D) => ({\n        // ðŸ”¥ Complex field access\n        functionName: f.function_name,\n        returnType: t.logical_type,\n        settingName: s.name,\n        \n        // ðŸ”¥ Advanced string operations\n        namePattern: f.function_name.regexp_extract(/[a-z]+/, 0),\n        settingPattern: s.name.regexp_replace(/_/g, '-'),\n        \n        // ðŸ”¥ Mathematical calculations\n        nameLength: f.function_name.len(),\n        similarity: f.function_name.levenshtein(s.name),\n        \n        // ðŸ”¥ Complex conditions with multiple tables\n        isCompatible: f.function_name.len() > 5 && \n                     t.logical_type !== 'UNKNOWN' &&\n                     s.input_type === 'VARCHAR',\n        \n        // ðŸ”¥ Nested ternary operations\n        category: f.function_type === 'scalar' ? 'Simple' :\n                 f.function_type === 'aggregate' ? 'Advanced' : 'Complex',\n        \n        // ðŸ”¥ Cross-table template literals\n        description: `Function ${f.function_name} returns ${t.logical_type} - relates to setting ${s.name}`\n    }))\n    .where(({ f, t, s }) => \n        f.function_name.len() > 3 &&\n        t.logical_type !== 'UNKNOWN' &&\n        s.name.len() > 2\n    )\n    .orderBy(({ f }) => f.function_name.len(), 'DESC')\n    .limit(15)\n    .execute()\n\nconsole.log('System Analysis:', systemAnalysis)\n\n// ================================\n// ðŸš€ SELF-JOINS - Advanced relationship discovery\n// ================================\n\n// Find functions that share similar characteristics\nconst functionSimilarity = await MemoryDB.from('duckdb_functions()', 'f1')\n    .join('duckdb_functions()', 'f2').on(({ f1, f2 }) => \n        f1.function_name !== f2.function_name &&\n        f1.function_type === f2.function_type &&\n        f1.return_type === f2.return_type\n    )\n    .select(({ f1, f2 }, D) => ({\n        // ðŸ”¥ Comparing similar functions\n        function1: f1.function_name,\n        function2: f2.function_name,\n        sharedType: f1.function_type,\n        sharedReturn: f1.return_type,\n        \n        // ðŸ”¥ String distance calculations\n        nameSimilarity: f1.function_name.levenshtein(f2.function_name),\n        \n        // ðŸ”¥ Advanced string analysis\n        commonPrefix: f1.function_name[1.3] === f2.function_name[1.3] ? 'Similar Start' : 'Different',\n        \n        // ðŸ”¥ Complex similarity scoring\n        similarityScore: f1.function_name.levenshtein(f2.function_name) / \n                        D.greatest(f1.function_name.len(), f2.function_name.len()),\n        \n        // ðŸ”¥ Pattern analysis\n        bothHaveUnderscore: f1.function_name.Like('%_%') && f2.function_name.Like('%_%'),\n        \n        // ðŸ”¥ Multi-criteria comparison\n        relationship: f1.function_name.levenshtein(f2.function_name) < 3 ? 'Very Similar' :\n                     f1.function_name.levenshtein(f2.function_name) < 6 ? 'Somewhat Similar' : 'Different'\n    }))\n    .where(({ f1, f2 }, D) => \n        f1.function_name.levenshtein(f2.function_name) < 8 &&\n        f1.function_name.len() > 4 &&\n        f2.function_name.len() > 4\n    )\n    .orderBy(({ f1, f2 }) => f1.function_name.levenshtein(f2.function_name))\n    .limit(20)\n    .execute()\n\nconsole.log('Function Similarities:', functionSimilarity)\n\n// ================================\n// ðŸŽª AGGREGATED JOINS - Statistical analysis across tables\n// ================================\n\n// Analyze function distribution by type and return type\nconst functionDistribution = await MemoryDB.from('duckdb_functions()', 'f')\n    .join('duckdb_types()', 't').on(({ f, t }) => f.return_type === t.logical_type)\n    .select(({ f, t }, D) => ({\n        functionType: f.function_type,\n        returnType: t.logical_type,\n        typeCategory: t.type_category,\n        \n        // ðŸ”¥ Aggregation functions\n        functionCount: D.count(),\n        avgNameLength: D.avg(f.function_name.len()),\n        maxNameLength: D.max(f.function_name.len()),\n        minNameLength: D.min(f.function_name.len()),\n        \n        // ðŸ”¥ String aggregations\n        longestName: D.max_by(f.function_name, f.function_name.len()),\n        shortestName: D.min_by(f.function_name, f.function_name.len()),\n        \n        // ðŸ”¥ Complex aggregated calculations\n        totalComplexity: D.sum(f.function_name.len() + t.logical_type.len()),\n        avgComplexity: D.avg(f.function_name.len() + t.logical_type.len()),\n        \n        // ðŸ”¥ Statistical measures\n        nameVariance: D.var_pop(f.function_name.len()),\n        \n        // ðŸ”¥ Conditional aggregations\n        longNameCount: D.count().filter(f.function_name.len() > 10)\n    }))\n    .groupBy('ALL')\n    .having(({ f }, D) => D.count() > 2)  // Only groups with multiple functions\n    .orderBy(({ f }, D) => D.count(), 'DESC')\n    .limit(15)\n    .execute()\n\nconsole.log('Function Distribution Analysis:', functionDistribution)\n\n// ================================\n// ðŸŒŠ OUTER JOINS - Handle missing relationships gracefully\n// ================================\n\n// Left join to find functions without matching types (edge cases)\nconst functionsWithoutTypes = await MemoryDB.from('duckdb_functions()', 'f')\n    .leftJoin('duckdb_types()', 't').on(({ f, t }) => f.return_type === t.logical_type)\n    .select(({ f, t }, D) => ({\n        functionName: f.function_name,\n        declaredReturnType: f.return_type,\n        \n        // ðŸ”¥ Handle nullable data from LEFT JOIN\n        actualType: t.logical_type ?? 'UNMAPPED',\n        typeExists: !!t?.logical_type ? 'EXIST' : 'NOPE',\n        \n        // ðŸ”¥ Conditional expressions with nulls\n        typeStatus: t.logical_type ? `Mapped to ${t.logical_type}` : 'No type mapping found',\n        \n        // ðŸ”¥ Complex null handling\n        category: !t.logical_type ? 'Orphaned Function' :\n                 t.type_category === 'NUMERIC' ? 'Number Function' :\n                 t.type_category === 'STRING' ? 'Text Function' : 'Other Function',\n        \n        // ðŸ”¥ Null-safe operations\n        typeLength: t?.logical_type?.len() ?? 0,\n    }))\n    .where(({ f, t }) => \n        f.function_name.len() > 3 &&\n        (t?.logical_type.IsNull() || t?.logical_type.len() > 2)\n    )\n    .orderBy(({ t }) => t?.logical_type.IsNull() ? 0 : 1)  // Unmapped first\n    .limit(25)\n    .execute()\n\nconsole.log('Functions Without Type Mappings:', functionsWithoutTypes)\n\n// ================================\n// ðŸŽ¯ CONDITIONAL JOINS - Dynamic relationship building\n// ================================\n\n// Join based on complex conditions and pattern matching\nconst dynamicRelationships = await MemoryDB.from('duckdb_functions()', 'f')\n    .join('duckdb_settings()', 's').on(({ f, s }) => \n        // ðŸ”¥ Complex join conditions with multiple criteria\n        f.function_name.regexp_matches('[a-z]+_[a-z]+') &&\n        s.name.regexp_matches('[a-z]+_[a-z]+') &&\n        f.function_name.substr(0, 4) === s.name.substr(0, 4)\n    )\n    .select(({ f, s }, D) => ({\n        functionName: f.function_name,\n        settingName: s.name,\n        \n        // ðŸ”¥ Pattern-based analysis\n        sharedPrefix: f.function_name.substr(0, 4),\n        functionPattern: f.function_name.regexp_extract('([a-z]+)_([a-z]+)', 0),\n        settingPattern: s.name.regexp_extract('([a-z]+)_([a-z]+)', 0),\n        \n        // ðŸ”¥ Advanced similarity metrics\n        editDistance: f.function_name.levenshtein(s.name),\n        jaroWinkler: f.function_name.jaro_winkler_similarity(s.name),\n        \n        // ðŸ”¥ Semantic relationship scoring\n        relationshipStrength: \n            f.function_name.levenshtein(s.name) < 5 ? 'Strong' :\n            f.function_name.levenshtein(s.name) < 10 ? 'Moderate' : 'Weak',\n        \n        // ðŸ”¥ Context-aware descriptions\n        relationship: `${f.function_name} function relates to ${s.name} setting with ${f.function_name.levenshtein(s.name)} edit distance`\n    }))\n    .where(({ f, s }) => \n        f.function_name.levenshtein(s.name) < 15 &&\n        f.function_name.len() > 5 &&\n        s.name.len() > 5\n    )\n    .orderBy(({ f, s }) => f.function_name.levenshtein(s.name))\n    .limit(20)\n    .execute()\n\nconsole.log('Dynamic Relationships:', dynamicRelationships)\n\n/*\nðŸš€ What makes BuckDB joins magical?\n\nâœ¨ NATURAL SYNTAX: JavaScript arrow functions for join conditions\nâœ¨ MULTI-TABLE ACCESS: Clean destructuring of joined table data  \nâœ¨ CROSS-TABLE OPERATIONS: Calculations and logic spanning multiple tables\nâœ¨ SMART TYPE INFERENCE: TypeScript knows your joined data structure\nâœ¨ FLEXIBLE CONDITIONS: Complex join logic with regex, math, and string ops\nâœ¨ NULL HANDLING: Graceful handling of outer joins and missing data\nâœ¨ AGGREGATION POWER: Statistical analysis across related tables\n\nðŸŽ¯ Next: Explore aggregations, window functions, and data transformations!\n*/\n\nconsole.log('ðŸ”— Master-level joins accomplished!')\n";export{n as default};
