const n="\n\nimport { describe, it, expect } from 'bun:test';\nimport { styleText } from \"node:util\"\n// console.log(styleText('magenta', 'lol'))\n\n// console.log({  })\n\nimport { alignExpressionWithSql } from './realign';\nimport { dumpSideBySide } from './dump-compare';\n\n\nconst expectAlignment = (sqlized: string, expression: string, expected: string) => {\n    sqlized = sqlized.trim();\n    expression = expression.trim();\n    expected = expected.trim();\n    const aligned = alignExpressionWithSql(expression, sqlized).trim();\n    // dumpSideBySideideBySide(expression, aligned);\n    // dumpSideBySide(expression, expected, aligned)\n    if (aligned !== expected) {\n        console.log('###########')\n        dumpSideBySide(expression, expected, aligned)\n    }\n    expect(aligned.split('\\n')).toEqual(expected.split('\\n'));\n}\n\nit('fsimrep', () =>\n    expectAlignment(`\nWITH  repo_pairs AS (FROM 'file:///Volumes/dev/fsimrep/starbase/*.parquet' AS a\n JOIN 'file:///Volumes/dev/fsimrep/starlite.parquet' AS r1 USING (repo)\n JOIN 'file:///Volumes/dev/fsimrep/starbase/*.parquet' AS b ON (a.login = b.login AND a.repo is distinct from b.repo)\n JOIN 'file:///Volumes/dev/fsimrep/starlite.parquet' AS r2 ON (b.repo = r2.repo)\n SELECT \n \n	login:       a.login,\n	date:        a.date,\n	repo_a:      a.repo,\n	repo_b:      b.repo,\n	repo_a_stars: r1.c,\n	repo_b_stars: r2.c\n WHERE (a.repo = 'uwdata/mosaic')),  similarity_metrics AS (FROM repo_pairs\n SELECT \n \n	repo_a:              repo_a,\n	repo_b:              repo_b,\n	common_users:        count(Distinct(login)),\n	total_stars:         repo_b_stars,\n	earliest_common_star: min(date),\n	latest_common_star:  max(date),\n	jaccard_similarity:  count(Distinct(login)) / COALESCE(repo_b_stars, NULL)\n GROUP BY (repo_a, repo_b, repo_b_stars)\n HAVING (count(Distinct(login)) >= 5)),  results AS (FROM similarity_metrics\n SELECT \n *,\n	full_name:       repo_b,\n	similarity_score: jaccard_similarity.round(3)\n WHERE (jaccard_similarity > 0)\n ORDER BY jaccard_similarity DESC) FROM results LEFT JOIN 'file:///Volumes/dev/fsimrep/repos.parquet' AS x USING (full_name) SELECT   full_name:       ('https://github.com/' || full_name), similarity_score: results.similarity_score.round(3), common_users:    common_users, total_stars:     stargazers_count, desc:            COALESCE(description, ''), topics:          COALESCE(topics, []) ORDER BY similarity_score DESC LIMIT 100`, `\nBuck('file:///Volumes/dev/fsimrep').with(\n    db => ({\n        repo_pairs: db.from('starbase/*.parquet', 'a')\n            .join('starlite.parquet', 'r1').using('repo')\n            .join('starbase/*.parquet', 'b').on(({ a, b }) => a.login === b.login && a.repo !== b.repo)\n            .join('starlite.parquet', 'r2').on(e => e.b.repo === e.r2.repo)\n            .select(({ r2, a, b, r1 }) => ({\n                login: a.login,\n                date: a.date,\n                repo_a: a.repo,\n                repo_b: b.repo,\n                repo_a_stars: r1.c,\n                repo_b_stars: r2.c\n            }))\n            .where(({ a }) => a.repo === 'uwdata/mosaic')\n    }),\n    db => ({\n        similarity_metrics: db.from('repo_pairs')\n            .select((e, D) => ({\n                repo_a: e.repo_a,\n                repo_b: e.repo_b,\n                common_users: D.count(D.Distinct(e.login)),\n                total_stars: e.repo_b_stars,\n                earliest_common_star: D.min(e.date),\n                latest_common_star: D.max(e.date),\n                jaccard_similarity: D.count(D.Distinct(e.login)) / (e.repo_b_stars ?? null)\n            }))\n            .groupBy('repo_a', 'repo_b', 'repo_b_stars')\n            .having((e, D) => D.count(D.Distinct(e.login)) >= 5)\n    }),\n    db => ({\n        results: db.from('similarity_metrics')\n            .select((e, D) => ({\n                ...e,\n                full_name: e.repo_b,\n                similarity_score: e.jaccard_similarity.round(3),\n            }))\n            .where(e => e.jaccard_similarity > 0)\n            .orderBy('jaccard_similarity', 'DESC')\n    })\n\n)\n    .from('results')\n    .leftJoin('repos.parquet', 'x').using('full_name')\n    .select((e, D) => ({\n        full_name: 'https://github.com/' + e.full_name,\n        similarity_score: e.results.similarity_score.round(3),\n        common_users: e.common_users,\n        total_stars: e.stargazers_count,\n        desc: e.description ?? '',\n        topics: e.topics ?? [],\n    }))\n    .orderBy('similarity_score', 'DESC')\n    .limit(100)`, `\nWITH\n\n        repo_pairs AS (FROM 'file:///Volumes/dev/fsimrep/starbase/*.parquet' AS a\n            JOIN 'file:///Volumes/dev/fsimrep/starlite.parquet' AS r1 USING (repo)\n            JOIN 'file:///Volumes/dev/fsimrep/starbase/*.parquet' AS b ON (a.login = b.login AND a.repo is distinct from b.repo)\n            JOIN 'file:///Volumes/dev/fsimrep/starlite.parquet' AS r2 ON (b.repo = r2.repo)\n            SELECT\n                login: a.login,\n                date: a.date,\n                repo_a: a.repo,\n                repo_b: b.repo,\n                repo_a_stars: r1.c,\n                repo_b_stars: r2.c\n\n            WHERE (a.repo = 'uwdata/mosaic')),\n\n\n        similarity_metrics AS (FROM repo_pairs\n            SELECT\n                repo_a: repo_a,\n                repo_b: repo_b,\n                common_users: count(Distinct(login)),\n                total_stars: repo_b_stars,\n                earliest_common_star: min(date),\n                latest_common_star: max(date),\n                jaccard_similarity: count(Distinct(login)) / COALESCE(repo_b_stars, NULL)\n\n            GROUP BY (repo_a, repo_b, repo_b_stars)\n            HAVING (count(Distinct(login)) >= 5)),\n\n\n        results AS (FROM similarity_metrics\n            SELECT *,\n\n                full_name: repo_b,\n                similarity_score: jaccard_similarity.round(3)\n\n            WHERE (jaccard_similarity > 0)\n            ORDER BY jaccard_similarity DESC)\n\n\n\n    FROM results\n    LEFT JOIN 'file:///Volumes/dev/fsimrep/repos.parquet' AS x USING (full_name)\n    SELECT\n        full_name: ('https://github.com/' || full_name),\n        similarity_score: results.similarity_score.round(3),\n        common_users: common_users,\n        total_stars: stargazers_count,\n        desc: COALESCE(description, ''),\n        topics: COALESCE(topics, [])\n\n    ORDER BY similarity_score DESC\n    LIMIT 100`))\n// ====================\n\nit('realign 01-getting-started.ts #0', () =>\n    expectAlignment(`\nFROM Stations SELECT  *`, `\nBuck('s3://a1738/files').from('Stations')`, `\nFROM Stations SELECT *`))\n// ====================\nit('42', () =>\n    expectAlignment(`\nFROM duckdb_functions() SELECT  * WHERE (function_name LIKE '%str%' AND function_name.len() BETWEEN 3 AND 12 AND description IS NOT NULL)`, `\nBuck().from('duckdb_functions()')\n    .select()\n    .where(e =>\n        e.function_name.Like('%str%') &&\n        e.function_name.len().Between(3, 12) &&\n        !e.description.IsNull()\n    )\n    `, `\nFROM duckdb_functions()\n    SELECT *\n    WHERE\n        (function_name LIKE '%str%' AND\n        function_name.len() BETWEEN 3 AND 12 AND\n        description IS NOT NULL)`))\n// ====================\n// it('s0', () => )\n\n// it('s1', () =>\n//     expectAlignment(`\n// FROM duckdb_functions() SELECT   function_name: function_name, function_type: function_type`, `\n// Buck().from('duckdb_functions()')\n//     .select(e => ({\n//         function_name: e.function_name,\n\n//         function_type: e.function_type,\n//     }))\n//     `, `\n// FROM duckdb_functions()\n//     SELECT\n//         function_name: function_name,\n\n//         function_type: function_type\n// `))\n\n// it('s2', () =>\n//     expectAlignment(`\n// FROM duckdb_functions() SELECT   function_name: nnn.xxx(), function_type: function_type`, `\n// Buck().from('duckdb_functions()')\n//     .select(e => ({\n//         function_name: e.function_name,\n//     // toto\n//         function_type: e.function_type,\n//     }))\n//     `, `\n// FROM duckdb_functions()\n//     SELECT\n//         function_name: nnn.xxx(),\n\n//         function_type: function_type\n// `))\n\n\n// it('realign 01-getting-started.ts #[0]', () =>\n//     expectAlignment(`\n// FROM duckdb_functions() SELECT   function_name: function_name, function_type: function_type`, `\n// Buck().from('duckdb_functions()')\n//     .select(e => ({\n//         function_name: e.function_name,\n//         function_type: e.function_type,\n//     }))\n//     `, `\n// FROM duckdb_functions()\n//     SELECT\n//         function_name: function_name,\n//         function_type: function_type\n// `))\n// // ====================\n// it('realign 01-getting-started.ts #[1]', () =>\n//     expectAlignment(`\n// FROM duckdb_functions() SELECT   function_name: function_name, function_type: function_type, name_length:  function_name.len() WHERE (function_name LIKE '%sum%' AND function_name.len() BETWEEN 3 AND 15)`, `\n// Buck().from('duckdb_functions()')\n//     .select(e => ({\n//         function_name: e.function_name,\n//         function_type: e.function_type,\n//         name_length: e.function_name.len(),\n//     }))\n//     .where(e => e.function_name.Like('%sum%') && e.function_name.len().Between(3, 15))\n//     `, `\n// FROM duckdb_functions()\n//     SELECT\n//         function_name: function_name,\n//         function_type: function_type,\n//         name_length: function_name.len()\n\n//     WHERE (function_name LIKE '%sum%' AND function_name.len() BETWEEN 3 AND 15)\n// `))\n// // ====================\n// it('realign 01-getting-started.ts #[2]', () =>\n//     expectAlignment(`\n// FROM duckdb_functions() SELECT   function_name, function_type, function_name.len() WHERE (description IS NOT NULL) LIMIT 5`, `\n// Buck().from('duckdb_functions()')\n//     .select(e => [e.function_name, e.function_type, e.function_name.len()])\n//     .where(e => !e.description.IsNull())\n//     .limit(5)\n//     `, `\n// FROM duckdb_functions()\n//     SELECT function_name, function_type, function_name.len()\n//     WHERE (description IS NOT NULL)\n//     LIMIT 5\n// `))\n// // ====================\n// it('realign 01-getting-started.ts #[3]', () =>\n//     expectAlignment(`\n// FROM duckdb_functions() SELECT   function_name: function_name WHERE (function_name LIKE '%array%') LIMIT 3`, `\n// Buck().from('duckdb_functions()')\n//     .select(e => ({\n//         function_name: e.function_name,\n//     }))\n//     .where(\"function_name LIKE '%array%'\")\n//     .limit(3)\n//     `, `\n// FROM duckdb_functions()\n//     SELECT\n//         function_name: function_name\n\n//     WHERE (function_name LIKE '%array%')\n//     LIMIT 3\n// `))\n// ====================\nit('realign 01-getting-started.ts #4', () =>\n    expectAlignment(`\nFROM duckdb_functions() SELECT   original:     function_name, upper_name:   function_name.upper(), name_length:  function_name.len(), prefix_3:     function_name[0:3], suffix_3:     function_name[-3], starts_with_a: function_name.starts_with('a') WHERE (function_name.len() < 10) LIMIT 5`, `\nBuck().from('duckdb_functions()')\n    .select(e => ({\n        original: e.function_name,\n        upper_name: e.function_name.upper(),\n        name_length: e.function_name.len(),\n        prefix_3: e.function_name[0.3],\n        suffix_3: e.function_name[-3],\n        starts_with_a: e.function_name.starts_with('a')\n    }))\n    .where(e => e.function_name.len() < 10)\n    .limit(5)\n    `, `\nFROM duckdb_functions()\n    SELECT\n        original: function_name,\n        upper_name: function_name.upper(),\n        name_length: function_name.len(),\n        prefix_3: function_name[0:3],\n        suffix_3: function_name[-3],\n        starts_with_a: function_name.starts_with('a')\n\n    WHERE (function_name.len() < 10)\n    LIMIT 5`))\n// ====================\nit('realign 01-getting-started.ts #5', () =>\n    expectAlignment(`\nFROM duckdb_functions() SELECT   function_count: count(), shortest_name:  min(function_name), avg_name_length: avg(function_name.len()) GROUP BY function_type`, `\nBuck().from('duckdb_functions()')\n    .select((e, D) => ({\n        function_count: D.count(),\n        shortest_name: D.min(e.function_name),\n        avg_name_length: D.avg(e.function_name.len()),\n    }))\n    .groupBy('function_type')\n    `, `\nFROM duckdb_functions()\n    SELECT\n        function_count: count(),\n        shortest_name: min(function_name),\n        avg_name_length: avg(function_name.len())\n\n    GROUP BY function_type`))\n// ====================\nit('realign 01-getting-started.ts #6', () =>\n    expectAlignment(`\nFROM duckdb_functions() SELECT   function_name: function_name, function_type: function_type, name_length:  function_name.len() ORDER BY function_name.len() ASC LIMIT 1`, `\nBuck().from('duckdb_functions()')\n    .select(e => ({\n        function_name: e.function_name,\n        function_type: e.function_type,\n        name_length: e.function_name.len(),\n    }))\n    .minBy(e => e.function_name.len())\n    `, `\nFROM duckdb_functions()\n    SELECT\n        function_name: function_name,\n        function_type: function_type,\n        name_length: function_name.len()\n\n    ORDER BY function_name.len() ASC LIMIT 1`))\n// ====================\nit('realign 01-getting-started.ts #7', () =>\n    expectAlignment(`\nFROM duckdb_functions() SELECT   function_name: function_name, function_type: function_type WHERE (function_type = 'scalar') USING SAMPLE 10 LIMIT 3`, `\nBuck().from('duckdb_functions()')\n    .select(e => ({\n        function_name: e.function_name,\n        function_type: e.function_type,\n    }))\n    .where(e => e.function_type === 'scalar')\n    .sample(10)\n    .limit(3)\n    `, `\nFROM duckdb_functions()\n    SELECT\n        function_name: function_name,\n        function_type: function_type\n\n    WHERE (function_type = 'scalar')\n    USING SAMPLE 10\n    LIMIT 3`))\n// ====================\nit('realign 01-getting-started.ts #8', () =>\n    expectAlignment(`\nFROM duckdb_functions() SELECT   function_name:  function_name, name_length:    function_name.len(), length_squared: function_name.len() * function_name.len(), length_plus_ten: function_name.len() + 10, length_mod_3:   function_name.len() % 3 WHERE (function_name.len() BETWEEN 5 AND 15) LIMIT 5`, `\nBuck().from('duckdb_functions()')\n    .select(e => ({\n        function_name: e.function_name,\n        name_length: e.function_name.len(),\n        length_squared: e.function_name.len() * e.function_name.len(),\n        length_plus_ten: e.function_name.len() + 10,\n        length_mod_3: e.function_name.len() % 3,\n    }))\n    .where(e => e.function_name.len().Between(5, 15))\n    .limit(5)\n    `, `\nFROM duckdb_functions()\n    SELECT\n        function_name: function_name,\n        name_length: function_name.len(),\n        length_squared: function_name.len() * function_name.len(),\n        length_plus_ten: function_name.len() + 10,\n        length_mod_3: function_name.len() % 3\n\n    WHERE (function_name.len() BETWEEN 5 AND 15)\n    LIMIT 5`))\n// ====================\nit('realign 01-getting-started.ts #9', () =>\n    expectAlignment(`\nFROM duckdb_functions() SELECT   function_name: function_name, category:     (CASE WHEN (function_type = 'scalar') THEN 'SCALAR_FUNC' ELSE 'OTHER_FUNC' END), size_category: (CASE WHEN (function_name.len() > 10) THEN 'LONG' ELSE (CASE WHEN (function_name.len() > 5) THEN 'MEDIUM' ELSE 'SHORT' END) END), mixed_result: (CASE WHEN (function_name = 'sum') THEN 42 ELSE function_name END) LIMIT 5`, `\nBuck().from('duckdb_functions()')\n    .select(e => ({\n        function_name: e.function_name,\n        category: e.function_type === 'scalar' ? 'SCALAR_FUNC' : 'OTHER_FUNC',\n        size_category: e.function_name.len() > 10 ? 'LONG' :\n            e.function_name.len() > 5 ? 'MEDIUM' : 'SHORT',\n        mixed_result: e.function_name === 'sum' ? 42 : e.function_name,\n    }))\n    .limit(5)\n    `, `\nFROM duckdb_functions()\n    SELECT\n        function_name: function_name,\n        category: (CASE WHEN (function_type = 'scalar') THEN 'SCALAR_FUNC' ELSE 'OTHER_FUNC' END),\n        size_category: (CASE WHEN\n            (function_name.len() > 10) THEN 'LONG' ELSE (CASE WHEN (function_name.len() > 5) THEN 'MEDIUM' ELSE 'SHORT' END) END),\n        mixed_result: (CASE WHEN (function_name = 'sum') THEN 42 ELSE function_name END)\n\n    LIMIT 5`))\n// ====================\nit('realign 01-getting-started.ts #10', () =>\n    expectAlignment(`\nFROM duckdb_functions() SELECT   metadata: {name: function_name, type: function_type, analysis: {length: function_name.len(), category: (CASE WHEN (function_name.len() > 10) THEN 'long' ELSE 'short' END), first_char: function_name[0:1]}} WHERE (function_type = 'scalar') LIMIT 3`, `\nBuck().from('duckdb_functions()')\n    .select(e => ({\n        metadata: {\n            name: e.function_name,\n            type: e.function_type,\n            analysis: {\n                length: e.function_name.len(),\n                category: e.function_name.len() > 10 ? 'long' : 'short',\n                first_char: e.function_name[0.1],\n            },\n        },\n    }))\n    .where(e => e.function_type === 'scalar')\n    .limit(3)\n    `, `\nFROM duckdb_functions()\n    SELECT\n        metadata:\n            {name: function_name,\n            type: function_type,\n            analysis:\n                {length: function_name.len(),\n                category: (CASE WHEN (function_name.len() > 10) THEN 'long' ELSE 'short' END),\n                first_char: function_name[0:1]}}\n\n\n\n    WHERE (function_type = 'scalar')\n    LIMIT 3`))\n// ====================\nit('realign 01-getting-started.ts #11', () =>\n    expectAlignment(`\nFROM duckdb_functions() SELECT   function_name: function_name, name_length:  function_name.len(), function_type: function_type WHERE (function_name LIKE '%str%' AND function_name.len() BETWEEN 3 AND 12 AND description IS NOT NULL)`, `\nBuck().from('duckdb_functions()')\n    .select(e => ({\n        function_name: e.function_name,\n        name_length: e.function_name.len(),\n        function_type: e.function_type,\n    }))\n    .where(e =>\n        e.function_name.Like('%str%') &&\n        e.function_name.len().Between(3, 12) &&\n        !e.description.IsNull()\n    )\n    `, `\nFROM duckdb_functions()\n    SELECT\n        function_name: function_name,\n        name_length: function_name.len(),\n        function_type: function_type\n\n    WHERE\n        (function_name LIKE '%str%' AND\n        function_name.len() BETWEEN 3 AND 12 AND\n        description IS NOT NULL)`))\n// ====================\nit('realign 01-getting-started.ts #12', () =>\n    expectAlignment(`\nFROM duckdb_functions() SELECT   description:  ('Function \"' || function_name || '\" is of type ' || function_type), simple_concat: (function_name || '_func'), detailed_info: ('Name: ' || function_name || ', Length: ' || function_name.len()) WHERE (function_type = 'scalar') LIMIT 3`, `\nBuck().from('duckdb_functions()')\n        .select(e => ({\n            // Template literal style\n            description: \\`Function \"\\${e.function_name}\" is of type \\${e.function_type}\\`,\n\n            // Plus operator concatenation\n            simple_concat: e.function_name + '_func',\n\n            // Mixed operations\n            detailed_info: 'Name: ' + e.function_name + ', Length: ' + e.function_name.len(),\n        }))\n        .where(e => e.function_type === 'scalar')\n        .limit(3)\n        `, `\nFROM duckdb_functions()\n        SELECT\n\n            description: ('Function \"' || function_name || '\" is of type ' || function_type),\n\n\n            simple_concat: (function_name || '_func'),\n\n\n            detailed_info: ('Name: ' || function_name || ', Length: ' || function_name.len())\n\n        WHERE (function_type = 'scalar')\n        LIMIT 3`))\n// ====================\nit('realign 01-getting-started.ts #13', () =>\n    expectAlignment(`\nFROM duckdb_functions() SELECT   function_type:  function_type, total_functions: count(), function_names: array_agg(function_name), avg_name_length: avg(function_name.len()), longest_name:   max(function_name), shortest_name:  min(function_name) GROUP BY function_type`, `\nBuck().from('duckdb_functions()')\n    .select((e, D) => ({\n        function_type: e.function_type,\n        total_functions: D.count(),\n        function_names: D.array_agg(e.function_name),\n        avg_name_length: D.avg(e.function_name.len()),\n        longest_name: D.max(e.function_name),\n        shortest_name: D.min(e.function_name),\n    }))\n    .groupBy('function_type')\n    `, `\nFROM duckdb_functions()\n    SELECT\n        function_type: function_type,\n        total_functions: count(),\n        function_names: array_agg(function_name),\n        avg_name_length: avg(function_name.len()),\n        longest_name: max(function_name),\n        shortest_name: min(function_name)\n\n    GROUP BY function_type`))\n// ====================\nit('realign 01-getting-started.ts #14', () =>\n    expectAlignment(`\nFROM duckdb_functions() JOIN duckdb_types() AS types ON (true) SELECT   function_name: duckdb_functions.function_name, type_name:    types.logical_type, combination:  (duckdb_functions.function_name || '_' || types.logical_type) WHERE (duckdb_functions.function_type = 'scalar' AND types.logical_type LIKE '%INT%') LIMIT 5`, `\nBuck().from('duckdb_functions()')\n    .join('duckdb_types()', 'types').on((a, b) => true) // Cross join\n    .select(e => ({\n        function_name: e.duckdb_functions.function_name,\n        type_name: e.types.logical_type,\n        combination: e.duckdb_functions.function_name + '_' + e.types.logical_type,\n    }))\n    .where(e => e.duckdb_functions.function_type === 'scalar' && e.types.logical_type.Like('%INT%'))\n    .limit(5)\n    `, `\nFROM duckdb_functions()\n    JOIN duckdb_types() AS types ON (true)\n    SELECT\n        function_name: duckdb_functions.function_name,\n        type_name: types.logical_type,\n        combination: (duckdb_functions.function_name || '_' || types.logical_type)\n\n    WHERE (duckdb_functions.function_type = 'scalar' AND types.logical_type LIKE '%INT%')\n    LIMIT 5`))\n// ====================\n";export{n as default};
