const e="import { DuckDBArrayValue, DuckDBBitValue, DuckDBBlobValue, DuckDBDateValue, DuckDBDecimalValue, DuckDBIntervalValue, DuckDBListValue, DuckDBMapValue, DuckDBResult, DuckDBStructValue, DuckDBTimestampMillisecondsValue, DuckDBTimestampNanosecondsValue, DuckDBTimestampSecondsValue, DuckDBTimestampTZValue, DuckDBTimestampValue, DuckDBTimeTZValue, DuckDBTimeValue, DuckDBTypeId, DuckDBUnionValue, DuckDBUUIDValue, DuckDBValue, type DuckDBConnection, type DuckDBInstance } from '@duckdb/node-api'\nimport { delta_scan, parquet_scan, read_csv, read_json, read_json_objects, read_parquet, read_text, read_xlsx } from './io'\nexport { delta_scan, parquet_scan, read_csv, read_json, read_json_objects, read_parquet, read_text, read_xlsx }\nimport { DSettings } from './.buck/types'\nimport { builder } from './src/build'\nimport { generateInterface, serializeDescribe, serializeSchema } from './src/interface-generator'\nimport { readFileSync, writeFileSync } from 'node:fs'\nimport { BuckDBBase, CommandQueue, DuckdbCon } from './core'\nimport { deriveName, isBucket, Dict } from './src/utils'\n\nimport { DuckDBTypeIdMap } from './src/typedef'\nimport { omit, pick, zipObject } from 'es-toolkit'\nimport { DuckDBResultReader } from '@duckdb/node-api/lib/DuckDBResultReader'\n\n\nconst InitConfigKeys = ['s3_access_key_id', 's3_secret_access_key', 's3_region', 's3_session_token']\nfunction mapDuckDBTypeToSchema(typeInfo: any): string | Record<string, any> {\n    const baseType = DuckDBTypeIdMap[typeInfo.typeId] || 'DAny'\n\n    if (typeInfo.typeId === DuckDBTypeId.LIST || typeInfo.typeId === DuckDBTypeId.ARRAY) {\n        if (typeInfo.valueType) {\n            return {\n                __type: 'array',\n                elementType: mapDuckDBTypeToSchema(typeInfo.valueType)\n            }\n        }\n        return baseType\n    }\n\n    if (typeInfo.typeId === DuckDBTypeId.STRUCT) {\n        const struct: Record<string, any> = { __type: 'struct' }\n        if (typeInfo.entryNames && typeInfo.entryTypes) {\n            typeInfo.entryNames.forEach((name: string, i: number) => {\n                struct[name] = mapDuckDBTypeToSchema(typeInfo.entryTypes[i])\n            })\n        }\n        return struct\n    }\n\n    return baseType\n}\nclass JsonModelTable {\n    constructor(\n        private jsonContent: Dict = JSON.parse(readFileSync('./.buck/models.json', 'utf-8'))\n    ) {\n    }\n    hasSchema(ressource: string, uri: string) {\n        return this.jsonContent[ressource]?.[uri] ? true : false\n    }\n    writeSchema(ressource: string, uri: string, schemaJson: Record<string, any>) {\n        if (!this.jsonContent[ressource]) {\n            this.jsonContent[ressource] = {}\n        }\n        this.jsonContent[ressource][uri] = schemaJson\n        const tsfile = generateInterface(this.jsonContent)\n        writeFileSync('./.buck/models.json', JSON.stringify(this.jsonContent, null, 2))\n        writeFileSync('./.buck/models.ts', tsfile)\n    }\n    writeResultSchema(ressource: string, uri: string, result: DuckDBResult) {\n        return this.writeSchema(ressource, uri, zipObject(result.columnNames(), result.columnTypes().map(mapDuckDBTypeToSchema)))\n    }\n    writeDescribedSchema(ressource: string, uri: string, described: Record<string, any>) {\n        this.writeSchema(ressource, uri, serializeDescribe(described as any))\n    }\n}\n\nconst jsonModelTable = new JsonModelTable()\n\nconst mapValueRec = (value: DuckDBValue) => {\n    if (value instanceof DuckDBListValue) {\n        return value.items.map(mapValueRec)\n    } else if (value instanceof DuckDBDecimalValue) {\n        return value.toDouble()\n    }\n    else if (value instanceof DuckDBDateValue) {\n        return value.toString()\n    }\n    else if (value instanceof DuckDBMapValue) {\n        return new Map(value.entries.map(x => [x.key, x.value]))\n    } else if (value instanceof DuckDBStructValue) {\n        const rtn = {}\n        for (const [key, val] of Object.entries(value.entries)) {\n            rtn[key] = mapValueRec(val)\n        }\n        return rtn\n    } else if (value instanceof DuckDBUUIDValue) {\n        return value.toString()\n    } else if (typeof value === 'bigint') {\n        return Number(value)\n    } else if (value instanceof DuckDBTimestampValue || value instanceof DuckDBTimeValue || value instanceof DuckDBTimeTZValue || value instanceof DuckDBTimestampTZValue) {\n        return new Date(Number(value.micros) * 1e-6)\n    } else if (value instanceof DuckDBTimestampSecondsValue) {\n        return new Date(Number(value.seconds))\n    } else if (value instanceof DuckDBTimestampMillisecondsValue) {\n        return new Date(Number(value.millis) * 1e-3)\n    } else if (value instanceof DuckDBTimestampNanosecondsValue) {\n        return new Date(Number(value.nanos) / 1e-9)\n    } else if (value instanceof DuckDBBlobValue) {\n        return value.bytes\n    } else if (value instanceof DuckDBBitValue) {\n        return value.data\n    } else if (value instanceof DuckDBIntervalValue) {\n        return value.toString()\n    } else if (value instanceof DuckDBArrayValue) {\n        return value.items.map(mapValueRec)\n    } else if (value instanceof DuckDBUnionValue) {\n        // todo, why isnt that an \n        return mapValueRec(value.value)\n    } else {\n        return value\n    }\n}\n\n\nfunction buildResult(reader: DuckDBResultReader) {\n    const rows = reader.getRows()\n    // @ts-ignore\n    const columnNames = reader.result.columnNames()\n    const rtn: Dict[] = []\n    for (let item of rows) {\n        const row = {}\n        for (const [i, name] of columnNames.entries()) {\n            const value = item[i]\n            row[name] = mapValueRec(value)\n        }\n        rtn.push(row)\n    }\n    return rtn\n}\n\n\nclass BuckDBNode extends BuckDBBase {\n    readonly type = 'node' as const\n    private _instance: DuckDBInstance\n    private _connection: DuckDBConnection\n    private _initPromise: Promise<void> | null = null\n    public isBucket: boolean = false\n\n    constructor(\n        handle?: string,\n        settings?: Partial<DSettings>,\n    ) {\n        super(handle, settings)\n        this.isBucket = !!isBucket(handle)\n        this._instance = null as unknown as DuckDBInstance\n        this._connection = null as unknown as DuckDBConnection\n    }\n\n    private _initDB(): Promise<void> {\n        if (this._initPromise) {\n            return this._initPromise\n        }\n        if (this._instance && this._connection) {\n            return Promise.resolve()\n        }\n\n        this._initPromise = (async () => {\n            const { DuckDBInstance } = await import('@duckdb/node-api')\n            let h = this.handle || ':memory:'\n            if (isBucket(this.handle)) {\n                this.lazySettings({ file_search_path: this.handle })\n                h = ':memory:'\n            }\n            const configSettings = pick(this.settings, InitConfigKeys)\n            this.lazySettings(omit(this.settings, InitConfigKeys))\n            this._instance = await DuckDBInstance.create(h, configSettings as any)\n            this._connection = await this._instance.connect()\n        })()\n\n        return this._initPromise\n    }\n\n    async upsertSchema(model: string, schema: Record<string, string>) {\n        // await this._initDB();\n        // const tableFile = Bun.file(`./.buck/models.json`);\n        // const tableContent = await tableFile.json();\n        // if (!tableContent[this.handle || '']) {\n        //     tableContent[this.handle || ''] = {};\n        // }\n        // tableContent[this.handle || ''][model] = schema;\n        // await tableFile.write(JSON.stringify(tableContent, null, 2));\n        // const tsfile = generateInterface(tableContent);\n        // await Bun.file('./.buck/models.ts').write(tsfile);\n    }\n\n    async ensureSchema(_uri: string) {\n        const uri = this.getSchemaUri(_uri)\n        const h = this.handle || ''\n        if (jsonModelTable.hasSchema(h, uri)) {\n            return\n        }\n        const describeResp = await this.describe(_uri)\n        jsonModelTable.writeDescribedSchema(h, uri, describeResp)\n    }\n\n\n    async query(sql: string, opts: Record<string, any> = {}) {\n        await this._initDB()\n        const cmds = this.queue.flush()\n        for (const cmd of cmds) {\n            await this._connection.run(cmd)\n        }\n        const run = await this._connection.run(sql)\n        const reader = new DuckDBResultReader(run as any);\n        await reader.readAll()\n        if (opts?.rows) {\n            return reader.getRowsJson()\n        }\n        return buildResult(reader)\n    }\n\n    async run(sql: string) {\n        await this._initDB()\n        return this._connection.run(sql)\n    }\n}\n\n\n\n\nexport const Buck = builder(BuckDBNode)\nexport const MemoryDB = Buck('')\nexport const from = MemoryDB.from\n";export{e as default};
