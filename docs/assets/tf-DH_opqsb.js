const e="import { __serialize } from './src/serializer'\ntype RetCon<T extends string> = `${T}()`\n// type RetCon1<S extends string, F = null> = F extends null ? `${S}()` : `${S}${SerializeValue<)`\n// type RetCon<S extends string, F1, F2> = `${S}(${SerializeValue<F1>},${SerializeValue<F2>})`\n// type RetCon<S extends string, F1, F2, F3> = `${S}(${SerializeValue<F1>},${SerializeValue<)`\n\nexport interface TFMetadata {\n    /** @description Provides metadata about columns in the DuckDB instance including database name, schema, table info, column properties, and data type details */\n    duckdb_columns(): RetCon<'duckdb_columns'>;\n    /** @description Provides metadata about constraints (CHECK, FOREIGN KEY, PRIMARY KEY, NOT NULL, UNIQUE) in the DuckDB instance */\n    duckdb_constraints(): RetCon<'duckdb_constraints'>;\n    /** @description Lists accessible databases including attached databases, with details like path, type, and readonly status */\n    duckdb_databases(): RetCon<'duckdb_databases'>;\n    /** @description Provides metadata about dependencies between database objects */\n    duckdb_dependencies(): RetCon<'duckdb_dependencies'>;\n    /** @description Provides metadata about available extensions including load status, version, and installation details */\n    duckdb_extensions(): RetCon<'duckdb_extensions'>;\n    /** @description Provides metadata about external file cache */\n    duckdb_external_file_cache(): RetCon<'duckdb_external_file_cache'>;\n    /** @description Provides metadata about functions including type, parameters, return type, and macro definitions */\n    duckdb_functions(): RetCon<'duckdb_functions'>;\n    /** @description Provides metadata about secondary indexes including uniqueness constraints and SQL definitions */\n    duckdb_indexes(): RetCon<'duckdb_indexes'>;\n    /** @description Provides metadata about DuckDB's keywords and reserved words */\n    duckdb_keywords(): RetCon<'duckdb_keywords'>;\n    /** @description Provides information on the contexts of DuckDB log entries */\n    duckdb_log_contexts(): RetCon<'duckdb_log_contexts'>;\n    /** @description Returns a table of DuckDB log entries with timestamps, levels, and messages */\n    duckdb_logs(): RetCon<'duckdb_logs'>;\n    /** @description Provides metadata about DuckDB's buffer manager memory usage */\n    duckdb_memory(): RetCon<'duckdb_memory'>;\n    /** @description Provides metadata about available optimization rules that can be selectively disabled */\n    duckdb_optimizers(): RetCon<'duckdb_optimizers'>;\n    /** @description Provides metadata about prepared statements in the current session */\n    duckdb_prepared_statements(): RetCon<'duckdb_prepared_statements'>;\n    /** @description Provides metadata about database schemas including internal status and properties */\n    duckdb_schemas(): RetCon<'duckdb_schemas'>;\n    /** @description Lists secret types supported in the current DuckDB session */\n    duckdb_secret_types(): RetCon<'duckdb_secret_types'>;\n    /** @description Provides metadata about available secrets with optional redaction of sensitive information @description @param redact Whether to redact sensitive information in the output */\n    duckdb_secrets(): RetCon<'duckdb_secrets'>;\n    /** @description Provides metadata about sequences including range, cycle, and current value details */\n    duckdb_sequences(): RetCon<'duckdb_sequences'>;\n    /** @description Provides metadata about available settings including current values and descriptions */\n    duckdb_settings(): RetCon<'duckdb_settings'>;\n    /** @description Provides a sample of table data @description @param col0 The table name to sample from */\n    duckdb_table_sample<T extends string>(col0: T): RetCon<'duckdb_table_sample'>;\n    /** @description Provides metadata about base tables including column count, constraints, and SQL definitions */\n    duckdb_tables(): RetCon<'duckdb_tables'>;\n    /** @description Provides metadata about temporary files written to disk by DuckDB */\n    duckdb_temporary_files(): RetCon<'duckdb_temporary_files'>;\n    /** @description Provides metadata about available data types including aliases, categories, and properties */\n    duckdb_types(): RetCon<'duckdb_types'>;\n    /** @description Provides metadata about variables in the current session */\n    duckdb_variables(): RetCon<'duckdb_variables'>;\n    /** @description Provides metadata about views including column count and SQL definitions */\n    duckdb_views(): RetCon<'duckdb_views'>;\n}\n\nexport interface TFPragma {\n    /** Collations are used to define the sort order of strings. */\n    pragma_collations(): RetCon<'pragma_collations'>;\n    /** Provides the current database size in bytes. */\n    pragma_database_size(): RetCon<'pragma_database_size'>;\n    /** Provides metadata information. */\n    pragma_metadata_info(col0?: string): RetCon<'pragma_metadata_info'>;\n    /** Provides platform information via PRAGMA. */\n    pragma_platform(): RetCon<'pragma_platform'>;\n    /** Provides R-tree index metadata via PRAGMA. */\n    pragma_rtree_index_info(): RetCon<'pragma_rtree_index_info'>;\n    /** Shows a PRAGMA setting or value. */\n    pragma_show(col0: string): RetCon<'pragma_show'>;\n    /** Provides storage metadata for a table via PRAGMA. */\n    pragma_storage_info(col0: string): RetCon<'pragma_storage_info'>;\n    /** Provides information about table columns via PRAGMA. */\n    pragma_table_info(col0: string): RetCon<'pragma_table_info'>;\n    /** Returns the user agent string of the DuckDB build. */\n    pragma_user_agent(): RetCon<'pragma_user_agent'>;\n    /** Returns the version of the DuckDB engine. */\n    pragma_version(): RetCon<'pragma_version'>;\n}\nexport interface TFBase {\n    /** @description Scans an Apache Arrow stream (dumb interface) and creates a temporary view. @description @param pointer1 Connection on which to execute the scan @description @param pointer2 Name of the temporary view to create @description @param pointer3 Arrow stream pointer wrapper */\n    arrow_scan_dumb<T1, T2, T3>(pointer1: T1, pointer2: T2, pointer3: T3): RetCon<'arrow_scan_dumb'>;\n    /** @description Checks a regex-based SQL parser pattern for validity. @description @param pattern Parser pattern to check */\n    check_peg_parser(pattern: string): RetCon<'check_peg_parser'>;\n    /** @description Creates a checkpoint file at the specified path. @description @param path Optional path to save checkpoint */\n    checkpoint(path?: string): RetCon<'checkpoint'>;\n    /** @description Forces creation of a checkpoint, even if unnecessary. @description @param path Optional path to save checkpoint */\n    force_checkpoint(path?: string): RetCon<'force_checkpoint'>;\n    /** @description Generates a series of values between start and end with an optional step increment. @description @param start Start of series @description @param end End of series @description @param step Step increment */\n    generate_series(start: number, end?: number, step?: number): RetCon<'generate_series'>;\n    /** @description Finds files matching a glob pattern. @description @param pattern File pattern to match */\n    glob(pattern: string): RetCon<'glob'>;\n    /** @description Returns list of ICU calendar names for localization. */\n    icu_calendar_names(): RetCon<'icu_calendar_names'>;\n    /** @description Expands each element in a JSON value into separate rows. @description @param json JSON value or string @description @param path Optional JSON path expression */\n    json_each(json: string | object, path?: string): RetCon<'json_each'>;\n    /** @description Executes a serialized SQL command represented in JSON. @description @param sql Serialized SQL JSON object */\n    json_execute_serialized_sql(sql: object): RetCon<'json_execute_serialized_sql'>;\n    /** @description Produces a tree representation of a JSON structure as rows. @description @param json JSON value or string @description @param path Optional JSON path expression */\n    json_tree(json: string | object, path?: string): RetCon<'json_tree'>;\n    /** @description Probes Parquet file bloom filters for presence of a value. @description @param files File paths or patterns @description @param column Column to probe @description @param value Value to check */\n    parquet_bloom_probe(files: string, column: string, value: any): RetCon<'parquet_bloom_probe'>;\n    /** @description Retrieves metadata information for Parquet files. @description @param files File paths or patterns */\n    parquet_file_metadata(files: string): RetCon<'parquet_file_metadata'>;\n    /** @description Retrieves key-value metadata for Parquet files. @description @param files File paths or patterns */\n    parquet_kv_metadata(files: string): RetCon<'parquet_kv_metadata'>;\n    /** @description Retrieves block and schema metadata for Parquet files. @description @param files File paths or patterns */\n    parquet_metadata(files: string): RetCon<'parquet_metadata'>;\n    /** @description Reads Parquet file schema definitions. @description @param files File paths or patterns */\n    parquet_schema(files: string): RetCon<'parquet_schema'>;\n    /** @description Returns list of PostgreSQL timezone names supported. */\n    pg_timezone_names(): RetCon<'pg_timezone_names'>;\n    /** @description Executes a SQL query and returns a result set. @description @param sql SQL query string */\n    query<T>(sql: string): RetCon<'query'>;\n    /** @description Executes a table-valued SQL query. @description @param tables Table identifiers or expressions @description @param validate Optional validation flag */\n    query_table<T>(tables: string, validate?: boolean): RetCon<'query_table'>;\n    /** @description Generates a half-open range of values from start to end with an optional step. @description @param start Start of range @description @param end End of range @description @param step Step increment */\n    range(start: number, end?: number, step?: number): RetCon<'range'>;\n    /** @description Repeats a single value into a column for a specified count. @description @param value Value to repeat @description @param count Number of repetitions */\n    repeat<T>(value: T, count: number): RetCon<'repeat'>;\n    /** @description Repeats a row of values numRows times. @description @param numRows Number of rows to generate */\n    repeat_row<T extends any[]>(numRows: number, ...values: T): RetCon<'repeat_row'>;\n    /** @description Provides SQL auto-completion suggestions for a partial query. @description @param sql Partial SQL string */\n    sql_auto_complete(sql: string): RetCon<'sql_auto_complete'>;\n    /** @description Computes summary statistics for the specified table. @description @param table Table identifier or expression */\n    summary<T>(table: T): RetCon<'summary'>;\n    /** @description Generates a dataset covering all data types for testing. @description @param useLargeEnum Whether to include large enum types */\n    test_all_types(useLargeEnum?: boolean): RetCon<'test_all_types'>;\n    /** @description Tests vectorized types by generating a test dataset. @description @param vector Input vector to test @description @param allFlat Whether to flatten all arguments @description @param args Additional arguments */\n    test_vector_types<T1, T2>(vector: T1[], allFlat: boolean, ...args: T2[]): RetCon<'test_vector_types'>;\n    /** @description Unnests an array into individual rows. @description @param array Array value to unnest */\n    unnest<T>(array: T[]): RetCon<'unnest'>;\n    /** @description Retrieves a secret by type and name. @description @param type Secret type identifier @description @param name Secret name identifier */\n    which_secret(type: string, name: string): RetCon<'which_secret'>;\n}\nexport interface TFExtensions {\n    /** @description Scans an Apache Arrow stream and creates a temporary view with the given name. @description @param pointer1 Connection on which to execute the scan @description @param pointer2 Name of the temporary view to create @description @param pointer3 Arrow stream wrapper */\n    arrow_scan<T1, T2, T3>(pointer1: T1, pointer2: T2, pointer3: T3): RetCon<'arrow_scan'>;\n    /** @description Loads AWS credentials using the AWS Default Credentials Provider Chain. @description @deprecated @description @param credentials Credentials or profile name to load @description @param redactSecret Whether to redact the secret in the output @description @param setRegion Whether to set the AWS region after loading credentials */\n    load_aws_credentials(credentials: string, redactSecret?: boolean, setRegion?: boolean): RetCon<'load_aws_credentials'>;\n    /** register_geoarrow_extensions() @description Registers GeoArrow extensions for spatial data support. */\n    register_geoarrow_extensions(): RetCon<'register_geoarrow_extensions'>;\n    /** @description Returns all nodes within an R-tree index for debugging, profiling, or inspection. @description @param index Name of the R-tree index */\n    rtree_index_dump(index: string): RetCon<'rtree_index_dump'>;\n    /** rtree_index_scan() */\n    rtree_index_scan(): RetCon<'rtree_index_scan'>;\n    /** seq_scan() */\n    seq_scan(): RetCon<'seq_scan'>;\n    /** shapefile_meta(files) */\n    shapefile_meta(files: string): RetCon<'shapefile_meta'>;\n    /** sqlite_attach(path, overwrite) @description Attaches a SQLite database file for read/write via SQLite extension. @description @deprecated Use ATTACH SQL syntax instead. @description @param path Path to SQLite file. @description @param overwrite Whether to overwrite existing attachment. */\n    sqlite_attach(path: string, overwrite?: boolean): RetCon<'sqlite_attach'>;\n    /** sqlite_query(database, query) */\n    sqlite_query<T1, T2>(database: T1, query: T2): RetCon<'sqlite_query'>;\n    /** sqlite_scan(database, table) @description Scans a table from an attached SQLite database file. @description @param database Path to SQLite database file. @description @param table Name of the table to scan. */\n    sqlite_scan<T1, T2>(database: T1, table: T2): RetCon<'sqlite_scan'>;\n    /** ST_Drivers() @description Returns the list of supported GDAL drivers and file formats. @description Note that not all drivers have been thoroughly tested; some may require additional options. */\n    ST_Drivers(): RetCon<'ST_Drivers'>;\n    /** ST_GeneratePoints(box, count, seed) @description Generates random points within the specified bounding box. @description @param box Bounding box (min_x, min_y, max_x, max_y) as BOX_2D. @description @param count Number of points to generate. @description @param seed Optional random seed. */\n    ST_GeneratePoints(box: [number, number, number, number], count: number, seed?: number): RetCon<'ST_GeneratePoints'>;\n}\n\nexport interface TableFunctions extends TFMetadata, TFPragma, TFBase, TFExtensions {\n\n}\n\n// export const variableTF = [\n//     'duckdb_table_sample',\n//     'query',\n//     'query_table',\n//     'repeat',\n//     'repeat_row',\n//     'summary',\n//     'unnest',\n// ]\n\n\n\nconst TF = new Proxy({}, {\n    get(target, prop, receiver) {\n        const methodName = prop.toString()\n        return (...args: any) => `${methodName}(${(args).map(__serialize).join(',')})`\n    },\n}) as unknown as TableFunctions\n\nexport const duckdb_columns = TF.duckdb_columns\nexport const duckdb_constraints = TF.duckdb_constraints\nexport const duckdb_databases = TF.duckdb_databases\nexport const duckdb_dependencies = TF.duckdb_dependencies\nexport const duckdb_extensions = TF.duckdb_extensions\nexport const duckdb_external_file_cache = TF.duckdb_external_file_cache\nexport const duckdb_functions = TF.duckdb_functions\nexport const duckdb_indexes = TF.duckdb_indexes\nexport const duckdb_keywords = TF.duckdb_keywords\nexport const duckdb_log_contexts = TF.duckdb_log_contexts\nexport const duckdb_logs = TF.duckdb_logs\nexport const duckdb_memory = TF.duckdb_memory\nexport const duckdb_optimizers = TF.duckdb_optimizers\nexport const duckdb_prepared_statements = TF.duckdb_prepared_statements\nexport const duckdb_schemas = TF.duckdb_schemas\nexport const duckdb_secret_types = TF.duckdb_secret_types\nexport const duckdb_secrets = TF.duckdb_secrets\nexport const duckdb_sequences = TF.duckdb_sequences\nexport const duckdb_settings = TF.duckdb_settings\n// export const duckdb_table_sample = TF.duckdb_table_sample\nexport const duckdb_tables = TF.duckdb_tables\nexport const duckdb_temporary_files = TF.duckdb_temporary_files\nexport const duckdb_types = TF.duckdb_types\nexport const duckdb_variables = TF.duckdb_variables\nexport const duckdb_views = TF.duckdb_views\nexport const pragma_collations = TF.pragma_collations\nexport const pragma_database_size = TF.pragma_database_size\nexport const pragma_metadata_info = TF.pragma_metadata_info\nexport const pragma_platform = TF.pragma_platform\nexport const pragma_rtree_index_info = TF.pragma_rtree_index_info\nexport const pragma_show = TF.pragma_show\nexport const pragma_storage_info = TF.pragma_storage_info\nexport const pragma_table_info = TF.pragma_table_info\nexport const pragma_user_agent = TF.pragma_user_agent\nexport const pragma_version = TF.pragma_version\nexport const arrow_scan_dumb = TF.arrow_scan_dumb\nexport const check_peg_parser = TF.check_peg_parser\nexport const checkpoint = TF.checkpoint\nexport const force_checkpoint = TF.force_checkpoint\nexport const generate_series = TF.generate_series\nexport const glob = TF.glob\nexport const icu_calendar_names = TF.icu_calendar_names\nexport const json_each = TF.json_each\nexport const json_execute_serialized_sql = TF.json_execute_serialized_sql\nexport const json_tree = TF.json_tree\nexport const parquet_bloom_probe = TF.parquet_bloom_probe\nexport const parquet_file_metadata = TF.parquet_file_metadata\nexport const parquet_kv_metadata = TF.parquet_kv_metadata\nexport const parquet_metadata = TF.parquet_metadata\nexport const parquet_schema = TF.parquet_schema\nexport const pg_timezone_names = TF.pg_timezone_names\n// export const query = TF.query\n// export const query_table = TF.query_table\nexport const range = TF.range\n// export const repeat = TF.repeat\n// export const repeat_row = TF.repeat_row\nexport const sql_auto_complete = TF.sql_auto_complete\n// export const summary = TF.summary\nexport const test_all_types = TF.test_all_types\nexport const test_vector_types = TF.test_vector_types\nexport const unnest = TF.unnest\nexport const which_secret = TF.which_secret\nexport const arrow_scan = TF.arrow_scan\nexport const load_aws_credentials = TF.load_aws_credentials\nexport const register_geoarrow_extensions = TF.register_geoarrow_extensions\nexport const rtree_index_dump = TF.rtree_index_dump\nexport const rtree_index_scan = TF.rtree_index_scan\nexport const seq_scan = TF.seq_scan\nexport const shapefile_meta = TF.shapefile_meta\nexport const sqlite_attach = TF.sqlite_attach\nexport const sqlite_query = TF.sqlite_query\nexport const sqlite_scan = TF.sqlite_scan\nexport const ST_Drivers = TF.ST_Drivers\nexport const ST_GeneratePoints = TF.ST_GeneratePoints";export{e as default};
