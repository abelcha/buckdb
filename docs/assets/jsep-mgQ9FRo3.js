const n="export interface JsepError extends Error {\n    index: number\n    description: string\n}\n\n// Define Expression types based on Jsep static constants\nexport type NodeType =\n    | 'Compound'\n    | 'SequenceExpression'\n    | 'Identifier'\n    | 'MemberExpression'\n    | 'Literal'\n    | 'ThisExpression'\n    | 'CallExpression'\n    | 'UnaryExpression'\n    | 'BinaryExpression'\n    | 'ArrayExpression'\n    | 'ObjectExpression'\n    | 'Property'\n    | 'SpreadElement'\n    | 'ArrowFunctionExpression'\n    | 'TaggedTemplateExpression'\n    | 'TemplateLiteral'\n    | 'TemplateElement'\n    | 'ConditionalExpression'\n\nexport interface BaseExpression {\n    type: NodeType\n    optional?: boolean\n    subMemberExpression?: boolean\n    isProperty?: boolean\n}\n\nexport interface CompoundExpression extends BaseExpression {\n    type: 'Compound'\n    body: Expression[]\n}\n\nexport interface SequenceExpression extends BaseExpression {\n    type: 'SequenceExpression'\n    expressions: Expression[]\n}\n\nexport interface Identifier extends BaseExpression {\n    type: 'Identifier'\n    name: string\n}\n\nexport interface MemberExpression extends BaseExpression {\n    type: 'MemberExpression'\n    computed: boolean\n    accessor: string // '.' or '['\n    object: Expression\n    property: Identifier | Expression // Identifier or Literal usually, but can be any Expression if computed\n    optional?: boolean\n}\n\nexport interface Literal extends BaseExpression {\n    type: 'Literal'\n    value: string | number | boolean | null | RegExp // Allow RegExp\n    valueType: 'string' | 'number' | 'boolean' | 'null' | 'RegExp' // Type of the value\n    raw: string\n}\nexport interface Property extends BaseExpression {\n    type: 'Property'\n    key: Identifier\n    value: Expression\n    computed: boolean\n    optional?: boolean\n    shorthand?: boolean // Add missing optional property\n}\n\nexport interface ObjectExpression extends BaseExpression {\n    type: 'ObjectExpression'\n    properties: (Property | Expression | SpreadElement)[] // Allow SpreadElement etc.\n}\n\nexport interface ThisExpression extends BaseExpression {\n    type: 'ThisExpression'\n}\n\nexport interface CallExpression extends BaseExpression {\n    type: 'CallExpression'\n    arguments: (Expression | null)[]\n    callee: MemberExpression | Expression\n    optional?: boolean\n}\n\nexport interface UnaryExpression extends BaseExpression {\n    type: 'UnaryExpression'\n    operator: string\n    argument: Expression\n    prefix: boolean\n}\n\nexport interface BinaryExpression extends BaseExpression {\n    type: 'BinaryExpression'\n    operator: string\n    left: Expression\n    right: Expression\n    parenthesis: boolean\n}\n\nexport interface ArrowFunctionExpression extends BaseExpression {\n    type: 'ArrowFunctionExpression'\n    params: (ObjectExpression | Identifier | MemberExpression)[] | null // Allow null for () => ...\n    body: Expression\n}\n\nexport interface ArrayExpression extends BaseExpression {\n    type: 'ArrayExpression'\n    elements: (Expression | null)[]\n}\nexport interface SpreadElement extends BaseExpression {\n    type: 'SpreadElement'\n    argument: Identifier & Expression\n}\n\n// Add Template Element interface\nexport interface TemplateElement extends BaseExpression {\n    type: 'TemplateElement'\n    value: {\n        raw: string\n        cooked: string | null // Cooked can be null if invalid escape sequence\n    }\n    tail: boolean\n}\n\n// Add Template Literal interface\nexport interface TemplateLiteral extends BaseExpression {\n    type: 'TemplateLiteral'\n    quasis: TemplateElement[]\n    expressions: Expression[]\n}\n\n// Add Tagged Template Expression interface\nexport interface TaggedTemplateExpression extends BaseExpression {\n    type: 'TaggedTemplateExpression'\n    tag: Expression\n    quasi: TemplateLiteral\n}\n\nexport interface ConditionalExpression extends BaseExpression {\n    type: 'ConditionalExpression'\n    tag: Expression\n    quasi: TemplateLiteral\n    consequent: Expression\n    alternate: Expression\n    test: BinaryExpression | UnaryExpression | Expression\n}\n\n// Union type for all possible expressions\nexport type Expression =\n    | CompoundExpression\n    | SequenceExpression\n    | Identifier\n    | MemberExpression\n    | Literal\n    | ThisExpression\n    | CallExpression\n    | UnaryExpression\n    | BinaryExpression\n    | ArrayExpression\n    | ObjectExpression\n    | Property\n    | ArrowFunctionExpression\n    | SpreadElement\n    | TaggedTemplateExpression // Add Template Literal types to main union\n    | TemplateLiteral\n    | TemplateElement\n    | ConditionalExpression\n\n// Type for the hook environment\ninterface HookEnv {\n    context: Jsep\n    node?: Expression | null // Only allow Expression or null based on actual usage\n}\n\n// Type for binary operator info used in stack\ninterface BinaryOpInfo {\n    value: string\n    prec: number\n    right_a: boolean // right associative\n}\n\n// Type for hook callbacks\ntype HookCallback = (this: Jsep, env: HookEnv) => void\n\nclass Hooks {\n    // Index signature to allow string indexing for hook names\n    [key: string]: HookCallback[] | undefined | ((name: string | string[] | Record<string, HookCallback>, callback?: HookCallback, first?: boolean) => void) | ((name: string, env: HookEnv) => void)\n\n    add(name: string | string[] | Record<string, HookCallback>, callback?: HookCallback, first?: boolean): void {\n        if (typeof name === 'object' && !Array.isArray(name)) {\n            // Multiple hook callbacks, keyed by name\n            const hookMap = name // Rename for clarity\n            const isFirstArg = callback // The second arg is 'first' in this overload\n            for (const hookName in hookMap) {\n                // Pass the actual callback from the map and the correct 'first' value\n                // @ts-ignore\n                this.add(hookName, hookMap[hookName], isFirstArg)\n            }\n        } else {\n            const names = Array.isArray(name) ? name : [name]\n            names.forEach((n) => {\n                const currentHooks = this[n] || []\n                if (callback && Array.isArray(currentHooks)) { // Type guard for array push\n                    currentHooks[first ? 'unshift' : 'push'](callback)\n                    this[n] = currentHooks // Reassign if necessary (though push modifies in place)\n                } else if (!this[n]) {\n                    this[n] = callback ? [callback] : []\n                }\n            })\n        }\n    }\n\n    run(name: string, env: HookEnv): void { // Use specific HookEnv type\n        const callbacks = this[name]\n        if (Array.isArray(callbacks)) {\n            callbacks.forEach((callback: HookCallback) => { // Use specific HookCallback type\n                callback.call(env.context, env) // Ensure context is Jsep instance\n            })\n        }\n    }\n}\n\ninterface JSEPPlugin {\n    name: string\n    init(jsxp: typeof Jsep): void\n}\n\nclass Plugins {\n    jsep: typeof Jsep // Use typeof Jsep\n    registered: Record<string, JSEPPlugin> // Use specific JSEPPlugin type\n\n    constructor(jsep: typeof Jsep) { // Use typeof Jsep\n        this.jsep = jsep\n        this.registered = {}\n    }\n\n    register(...plugins: JSEPPlugin[]) { // Use specific JSEPPlugin type\n        plugins.forEach((plugin) => {\n            if (typeof plugin !== 'object' || !plugin.name || !plugin.init) {\n                throw new Error('Invalid JSEP plugin format')\n            }\n            if (this.registered[plugin.name]) {\n                // already registered. Ignore.\n                return\n            }\n            plugin.init(this.jsep)\n            this.registered[plugin.name] = plugin\n        })\n    }\n}\n\nexport class Jsep {\n    // Instance properties\n    expr: string\n    index: number\n\n    // Static properties (defined below class)\n    static version: string\n    static unary_ops: Record<string, 1>\n    static binary_ops: Record<string, number>\n    static right_associative: Set<string>\n    static additional_identifier_chars: Set<string>\n    static literals: Record<string, boolean | null | number | string | RegExp> // Allow RegExp\n    static this_str: string\n    static max_unop_len: number\n    static max_binop_len: number\n    static hooks: Hooks\n    static plugins: Plugins\n\n    // Node Type constants (defined below class)\n    static COMPOUND: 'Compound'\n    static SEQUENCE_EXP: 'SequenceExpression'\n    static IDENTIFIER: 'Identifier'\n    static MEMBER_EXP: 'MemberExpression'\n    static LITERAL: 'Literal'\n    static THIS_EXP: 'ThisExpression'\n    static CALL_EXP: 'CallExpression'\n    static UNARY_EXP: 'UnaryExpression'\n    static BINARY_EXP: 'BinaryExpression'\n    static ARRAY_EXP: 'ArrayExpression'\n    // Added template types to NodeType union\n    static TAGGED_TEMPLATE_EXPRESSION: 'TaggedTemplateExpression'\n    static TEMPLATE_LITERAL: 'TemplateLiteral'\n    static TEMPLATE_ELEMENT: 'TemplateElement'\n\n    // Char Code constants (defined below class)\n    static TAB_CODE: number\n    static LF_CODE: number\n    static CR_CODE: number\n    static SPACE_CODE: number\n    static PERIOD_CODE: number\n    static COMMA_CODE: number\n    static SQUOTE_CODE: number\n    static DQUOTE_CODE: number\n    static OPAREN_CODE: number\n    static CPAREN_CODE: number\n    static OBRACK_CODE: number\n    static CBRACK_CODE: number\n    static QUMARK_CODE: number\n    static SEMCOL_CODE: number\n    static COLON_CODE: number\n    static BTICK_CODE: number // `\n    static OCURLY_CODE: number // {\n    static CCURLY_CODE: number // }\n    static FSLASH_CODE: number // /\n    static BSLASH_CODE: number // \\\n    static USCORE_CODE: number // _\n\n    static addUnaryOp(op_name: string): typeof Jsep {\n        Jsep.max_unop_len = Math.max(op_name.length, Jsep.max_unop_len)\n        Jsep.unary_ops[op_name] = 1\n        return Jsep\n    }\n    static addBinaryOp(op_name: string, precedence: number, isRightAssociative: boolean = false): typeof Jsep {\n        Jsep.max_binop_len = Math.max(op_name.length, Jsep.max_binop_len)\n        Jsep.binary_ops[op_name] = precedence\n        if (isRightAssociative) {\n            Jsep.right_associative.add(op_name)\n        } else {\n            Jsep.right_associative.delete(op_name)\n        }\n        return Jsep\n    }\n\n    static addIdentifierChar(char: string): typeof Jsep {\n        Jsep.additional_identifier_chars.add(char)\n        return Jsep\n    }\n\n    static addLiteral(literal_name: string, literal_value: boolean | null | number | string | RegExp): typeof Jsep { // Use specific types\n        Jsep.literals[literal_name] = literal_value\n        return Jsep\n    }\n\n    static removeUnaryOp(op_name: string): typeof Jsep {\n        delete Jsep.unary_ops[op_name]\n        if (op_name.length === Jsep.max_unop_len) {\n            Jsep.max_unop_len = Jsep.getMaxKeyLen(Jsep.unary_ops)\n        }\n        return Jsep\n    }\n\n    static removeAllUnaryOps(): typeof Jsep {\n        Jsep.unary_ops = {}\n        Jsep.max_unop_len = 0\n        return Jsep\n    }\n\n    static removeIdentifierChar(char: string): typeof Jsep {\n        Jsep.additional_identifier_chars.delete(char)\n        return Jsep\n    }\n\n    static removeBinaryOp(op_name: string): typeof Jsep {\n        delete Jsep.binary_ops[op_name]\n        if (op_name.length === Jsep.max_binop_len) {\n            Jsep.max_binop_len = Jsep.getMaxKeyLen(Jsep.binary_ops)\n        }\n        Jsep.right_associative.delete(op_name)\n        return Jsep\n    }\n\n    static removeAllBinaryOps(): typeof Jsep {\n        Jsep.binary_ops = {}\n        Jsep.max_binop_len = 0\n        return Jsep\n    }\n\n    static removeLiteral(literal_name: string): typeof Jsep {\n        delete Jsep.literals[literal_name]\n        return Jsep\n    }\n\n    static removeAllLiterals(): typeof Jsep {\n        Jsep.literals = {}\n        return Jsep\n    }\n\n    get char(): string {\n        return this.expr.charAt(this.index)\n    }\n\n    get code(): number {\n        return this.expr.charCodeAt(this.index)\n    }\n\n    constructor(expr: string) {\n        // Create new Jsep instance with expression string\n        // `index` stores the character number we are currently at\n        // All of the gobbles below will modify `index` as we move along\n        this.expr = expr\n        this.index = 0\n    }\n\n    // Static top-level parser\n    static parse(expr: string): Expression {\n        return (new Jsep(expr)).parse()\n    }\n\n    // Assuming this utility function exists\n    static getMaxKeyLen(obj: Record<string, unknown>): number {\n        return Math.max(0, ...Object.keys(obj).map(k => k.length))\n    }\n\n    // Check if character code is a decimal digit (0-9)\n    static isDecimalDigit(ch: number): boolean {\n        return (ch >= 48 && ch <= 57) // 0...9\n    }\n    static binaryPrecedence(op_val: string): number {\n        return Jsep.binary_ops[op_val] || 0\n    }\n\n    static isIdentifierStart(ch: number): boolean {\n        return (ch >= 65 && ch <= 90) // A-Z\n            || (ch >= 97 && ch <= 122) // a-z\n            || (ch >= 128 && !Jsep.binary_ops[String.fromCharCode(ch)]) // non-ASCII not an op\n            || (Jsep.additional_identifier_chars.has(String.fromCharCode(ch)))\n    }\n\n    static isIdentifierPart(ch: number): boolean {\n        return Jsep.isIdentifierStart(ch) || Jsep.isDecimalDigit(ch)\n    }\n\n    throwError(message: string): never {\n        const error = new Error(`${message} at character ${this.index}`) as JsepError\n        error.index = this.index\n        error.description = message\n        throw error\n    }\n\n    /**\n     * Run a given hook\n     */\n    runHook(name: string, node?: Expression | null): Expression | null { // Allow null return\n        const callbacks = Jsep.hooks[name]\n        if (Array.isArray(callbacks)) { // Check hook exists and is array\n            const env: HookEnv = { context: this, node: node || null } // Use HookEnv type\n            Jsep.hooks.run(name, env)\n            // Ensure undefined is not returned, only Expression or null\n            return env.node === undefined ? null : env.node\n        }\n        return node || null // Return original node or null\n    }\n\n    /**\n     * Runs a given hook until one returns a node\n     */\n    searchHook(name: string): Expression | undefined { // Allow undefined return\n        const callbacks = Jsep.hooks[name]\n        if (Array.isArray(callbacks)) { // Check if callbacks is an array\n            const env: HookEnv = { context: this, node: undefined }\n            // Use Array.prototype.some for efficiency\n            callbacks.some((callback: HookCallback) => {\n                callback.call(env.context, env)\n                return !!env.node // Stop searching once node is found\n            })\n            // Ensure node is Expression or undefined, not null\n            return env.node ? env.node : undefined\n        }\n        return undefined // Return undefined if hook doesn't exist or callbacks is not an array\n    }\n\n    gobbleSpaces(): void {\n        let ch = this.code\n        while (\n            ch === Jsep.SPACE_CODE\n            || ch === Jsep.TAB_CODE\n            || ch === Jsep.LF_CODE\n            || ch === Jsep.CR_CODE\n        ) {\n            ch = this.expr.charCodeAt(++this.index)\n        }\n        this.runHook('gobble-spaces')\n    }\n\n    parse(): Expression {\n        this.runHook('before-all')\n        const nodes = this.gobbleExpressions()\n\n        // Handle case where gobbleExpressions returns empty array (e.g., empty input)\n        if (nodes.length === 0) {\n            this.throwError('Empty expression')\n        }\n\n        const node: Expression = nodes.length === 1\n            ? nodes[0]\n            : {\n                type: Jsep.COMPOUND,\n                body: nodes,\n            }\n\n        // Ensure node is not null before passing to runHook\n        const finalNode = node ? this.runHook('after-all', node) : null\n        if (!finalNode) {\n            // This should ideally not happen if the input expression was valid\n            // and hooks didn't clear the node, but handle it defensively.\n            this.throwError('Parser finished with no expression node.')\n        }\n        // After the check, finalNode is guaranteed to be Expression.\n        return finalNode\n    }\n    /*	 * top-level parser (but can be reused within as well)*/\n\n    /**\n     * top-level parser (but can be reused within as well)\n     */\n    gobbleExpressions(untilICode?: number): Expression[] {\n        const nodes: Expression[] = [] // Ensure nodes array type\n        let ch_i: number\n        let node: Expression | null\n\n        while (this.index < this.expr.length) {\n            ch_i = this.code\n\n            if (ch_i === Jsep.SEMCOL_CODE || ch_i === Jsep.COMMA_CODE) {\n                this.index++ // ignore separators\n            } else {\n                // Try to gobble each expression individually\n                node = this.gobbleExpression() // Can return null\n                if (node) { // Check if node is not null\n                    nodes.push(node)\n                    // If we weren't able to find a binary expression and are out of room, then\n                    // the expression passed in probably has too much\n                } else if (this.index < this.expr.length) {\n                    if (ch_i === untilICode) {\n                        break\n                    }\n                    this.throwError('Unexpected \"' + this.char + '\"')\n                } else {\n                    // End of expression string reached after trying to gobble an expression\n                    break\n                }\n            }\n        }\n\n        return nodes\n    }\n    /** 	 * The main parsing function. */\n    gobbleExpression(): Expression | null { // Allow null return\n        let node = this.searchHook('gobble-expression') || this.gobbleBinaryExpression()\n        this.gobbleSpaces()\n        // runHook can return null, so the final return type must accommodate that\n        node = this.runHook('after-expression', node)\n        // runHook now correctly returns Expression | null\n        return node\n    }\n\n    /**\n     * Search for the operation portion of the string (e.g. `+`, `===`)\n     * Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)\n     * and move down from 3 to 2 to 1 character until a matching binary operation is found\n     * then, return that binary operation\n     */\n    gobbleBinaryOp(): string | boolean {\n        this.gobbleSpaces()\n        let to_check = this.expr.substr(this.index, Jsep.max_binop_len)\n        let tc_len = to_check.length\n\n        while (tc_len > 0) {\n            // Don't accept a binary op when it is an identifier.\n            // Binary ops that start with a identifier-valid character must be followed\n            // by a non identifier-part valid character\n            if (\n                Jsep.binary_ops.hasOwnProperty(to_check) && (\n                    !Jsep.isIdentifierStart(this.code)\n                    || (this.index + to_check.length < this.expr.length && !Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))\n                )\n            ) {\n                this.index += tc_len\n                return to_check\n            }\n            to_check = to_check.substr(0, --tc_len)\n        }\n        return false\n    }\n    /**\n     * This function is responsible for gobbling an individual expression,\n     * e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`\n     */\n    // Can return any Expression type if no binary op is found\n    gobbleBinaryExpression(): Expression | null {\n        let node: Expression | undefined | null // Allow undefined during processing\n        let biop: string | boolean\n        let prec: number\n        let stack: (Expression | BinaryOpInfo)[] = [] // Initialize stack type\n        let biop_info: BinaryOpInfo\n        let left: Expression | null\n        let right: Expression | null\n        let i: number\n        let cur_biop: string | boolean\n\n        // First, try to get the leftmost thing\n        // Then, check to see if there's a binary operator operating on that leftmost thing\n        // Don't gobbleBinaryOp without a left-hand-side\n        left = this.gobbleToken() // gobbleToken can return null\n        if (!left) {\n            return null // Return null if no left side\n        }\n        biop = this.gobbleBinaryOp() // biop can be string or false\n\n        // If there wasn't a binary operator (biop is false), just return the leftmost node\n        if (biop === false) {\n            return left\n        }\n\n        // Otherwise, we need to start a stack to properly place the binary operations in their precedence structure\n        // Type guard to ensure biop is a string here\n        if (typeof biop !== 'string') {\n            // This should theoretically not happen based on the check above, but satisfies TS\n            this.throwError('Internal error: Invalid binary operator state.')\n        }\n        biop_info = { value: biop, prec: Jsep.binaryPrecedence(biop), right_a: Jsep.right_associative.has(biop) }\n\n        right = this.gobbleToken() // Can return null\n\n        if (!right) {\n            this.throwError('Expected expression after ' + biop)\n        }\n\n        stack = [left, biop_info, right] // left and right are Expression | null\n\n        // Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)\n        while ((cur_biop = this.gobbleBinaryOp())) { // Assign to cur_biop, check truthiness\n            // Type guard: cur_biop must be string here\n            if (typeof cur_biop !== 'string') break\n\n            prec = Jsep.binaryPrecedence(cur_biop)\n\n            if (prec === 0) {\n                this.index -= cur_biop.length // Use cur_biop length\n                break\n            }\n\n            biop_info = { value: cur_biop, prec, right_a: Jsep.right_associative.has(cur_biop) }\n\n            // Reduce: make a binary expression from the three topmost entries.\n            const comparePrev = (prev: BinaryOpInfo) =>\n                biop_info.right_a && prev.right_a\n                    ? prec > prev.prec\n                    : prec <= prev.prec\n\n            while (stack.length > 2 && comparePrev(stack[stack.length - 2] as BinaryOpInfo)) {\n                right = stack.pop() as Expression // Assert Expression type after check\n                const current_op_info = stack.pop() as BinaryOpInfo // Assert BinaryOpInfo\n                left = stack.pop() as Expression // Assert Expression type\n\n                node = {\n                    type: Jsep.BINARY_EXP,\n                    operator: current_op_info.value,\n                    left: left, // Ensure left is Expression\n                    right: right, // Ensure right is Expression\n                    parenthesis: false,\n                }\n                stack.push(node)\n            }\n\n            const nextToken = this.gobbleToken() // Can return null\n\n            if (!nextToken) {\n                this.throwError('Expected expression after ' + cur_biop)\n            }\n\n            stack.push(biop_info, nextToken)\n        }\n\n        // Combine remaining stack items\n        let finalNode = stack.pop() // Could be Expression or BinaryOpInfo initially\n\n        while (stack.length > 1) {\n            const opInfo = stack.pop() as BinaryOpInfo // Assert BinaryOpInfo\n            const leftNode = stack.pop() as Expression // Assert Expression\n\n            if (!finalNode || typeof finalNode === 'boolean' || !('type' in finalNode)) {\n                // Handle cases where finalNode might not be a valid Expression (though unlikely here)\n                this.throwError('Internal error: Invalid stack state during binary expression reduction.')\n            }\n\n            finalNode = {\n                type: Jsep.BINARY_EXP,\n                operator: opInfo.value,\n                left: leftNode,\n                right: finalNode as Expression, // Assert finalNode is Expression\n                parenthesis: false,\n            }\n        }\n\n        // Final node should be the single remaining Expression on the stack\n        return finalNode as Expression | null // Cast final result, could be null if input was empty\n    }\n    /**\n     * An individual part of a binary expression:\n     * e.g. `foo.bar(baz)`, `1`, `\"abc\"`, `(a % 2)` (because it's in parenthesis)\n     */\n    gobbleToken(): Expression | null { // Allow null return\n        let ch: number\n        let to_check: string\n        let tc_len: number\n        let node: Expression | undefined | null // Allow undefined/null during processing\n\n        this.gobbleSpaces()\n        node = this.searchHook('gobble-token') // Can return undefined\n        if (node) {\n            // runHook now correctly returns Expression | null\n            return this.runHook('after-token', node)\n        }\n\n        ch = this.code\n\n        if (Jsep.isDecimalDigit(ch) || ch === Jsep.PERIOD_CODE) {\n            // Char code 46 is a dot `.` which can start off a numeric literal\n            return this.gobbleNumericLiteral()\n        }\n\n        if (ch === Jsep.SQUOTE_CODE || ch === Jsep.DQUOTE_CODE) {\n            // Single or double quotes\n            node = this.gobbleStringLiteral()\n        } else if (ch === Jsep.OBRACK_CODE) {\n            node = this.gobbleArray()\n        } else {\n            to_check = this.expr.substr(this.index, Jsep.max_unop_len)\n            tc_len = to_check.length\n\n            while (tc_len > 0) {\n                // Don't accept an unary op when it is an identifier.\n                // Unary ops that start with a identifier-valid character must be followed\n                // by a non identifier-part valid character\n                if (\n                    Jsep.unary_ops.hasOwnProperty(to_check) && (\n                        !Jsep.isIdentifierStart(this.code)\n                        || (this.index + to_check.length < this.expr.length && !Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))\n                    )\n                ) {\n                    this.index += tc_len\n                    const argument = this.gobbleToken()\n                    if (!argument) {\n                        this.throwError('missing unaryOp argument')\n                    }\n                    // runHook now correctly returns Expression | null\n                    return this.runHook('after-token', {\n                        type: Jsep.UNARY_EXP,\n                        operator: to_check,\n                        argument,\n                        prefix: true,\n                    })\n                }\n\n                to_check = to_check.substr(0, --tc_len)\n            }\n\n            if (Jsep.isIdentifierStart(ch)) {\n                const idNode = this.gobbleIdentifier() // Store in temp var\n                node = idNode // Assign to node\n                if (Jsep.literals.hasOwnProperty(idNode.name)) {\n                    const literalValue = Jsep.literals[idNode.name]\n                    // Check value is not undefined before assigning\n                    if (literalValue !== undefined) {\n                        node = {\n                            type: Jsep.LITERAL,\n                            value: literalValue,\n                            // @ts-ignore-next-line\n                            valueType: typeof literalValue,\n                            raw: idNode.name,\n                        }\n                    }\n                    // If literalValue is undefined, node remains the Identifier\n                } else if (idNode.name === Jsep.this_str) {\n                    node = { type: Jsep.THIS_EXP }\n                }\n            } else if (ch === Jsep.OPAREN_CODE) { // open parenthesis\n                node = this.gobbleGroup()\n            }\n        }\n\n        if (!node) {\n            // runHook now correctly returns Expression | null\n            return this.runHook('after-token', node || null) // Pass null explicitly if node is null/undefined\n        }\n\n        node = this.gobbleTokenProperty(node) // Can return null\n        // runHook now correctly returns Expression | null\n        return this.runHook('after-token', node || null) // Pass null explicitly if node is null/undefined\n    }\n    /**\n     * An individual part of a binary expression:\n     * e.g. `foo.bar(baz)`, `1`, `\"abc\"`, `(a % 2)` (because it's in parenthesis)\n     */\n    gobbleTokenProperty(node: Expression): Expression {\n        this.gobbleSpaces()\n\n        let ch = this.code\n        while (ch === Jsep.PERIOD_CODE || ch === Jsep.OBRACK_CODE || ch === Jsep.OPAREN_CODE || ch === Jsep.QUMARK_CODE) {\n            let optional\n            if (ch === Jsep.QUMARK_CODE) {\n                if (this.expr.charCodeAt(this.index + 1) !== Jsep.PERIOD_CODE) {\n                    break\n                }\n                optional = true\n                this.index += 2\n                this.gobbleSpaces()\n                ch = this.code\n            }\n            this.index++\n\n            if (ch === Jsep.OBRACK_CODE) {\n                const propertyExpr = this.gobbleExpression() // Can return null\n                if (!propertyExpr) {\n                    this.throwError('Expected expression within []')\n                }\n                node = {\n                    type: Jsep.MEMBER_EXP,\n                    accessor: '[',\n                    computed: true,\n                    object: node,\n                    property: propertyExpr as Identifier, // Cast to Identifier\n                }\n                // No need to check node.property existence after assignment\n                this.gobbleSpaces()\n                ch = this.code\n                if (ch !== Jsep.CBRACK_CODE) {\n                    this.throwError('Unclosed [')\n                }\n                this.index++\n            } else if (ch === Jsep.OPAREN_CODE) {\n                // A function call is being made; gobble all the arguments\n                node = {\n                    type: Jsep.CALL_EXP,\n                    'arguments': this.gobbleArguments(Jsep.CPAREN_CODE),\n                    callee: node,\n                }\n            } else if (ch === Jsep.PERIOD_CODE || optional) {\n                if (optional) {\n                    this.index--\n                }\n                this.gobbleSpaces()\n                node = {\n                    type: Jsep.MEMBER_EXP,\n                    accessor: '.',\n                    computed: false,\n                    object: node,\n                    property: this.gobbleIdentifier(),\n                }\n            }\n\n            if (optional) {\n                // Ensure node is MemberExpression before setting optional\n                if (node.type === Jsep.MEMBER_EXP || node.type === Jsep.CALL_EXP) {\n                    node.optional = true\n                }\n            } // else leave undefined for compatibility with esprima\n\n            this.gobbleSpaces()\n            ch = this.code\n        }\n\n        return node\n    }\n\n    /**\n     * Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to\n     * keep track of everything in the numeric literal and then calling `parseFloat` on that string\n     */\n    gobbleNumericLiteral(): Literal {\n        // console.log('gobbleNumericLiteral', this.expr)\n        let number = '', ch, chCode\n\n        while (Jsep.isDecimalDigit(this.code) || this.code === Jsep.USCORE_CODE) {\n            if (this.code === Jsep.USCORE_CODE) {\n                this.index++\n            } else {\n                number += this.expr.charAt(this.index++)\n            }\n        }\n\n        if (this.code === Jsep.PERIOD_CODE) { // can start with a decimal marker\n            number += this.expr.charAt(this.index++)\n\n            while (Jsep.isDecimalDigit(this.code)) {\n                number += this.expr.charAt(this.index++)\n            }\n        }\n\n        ch = this.char\n\n        if (ch === 'e' || ch === 'E') { // exponent marker\n            number += this.expr.charAt(this.index++)\n            ch = this.char\n\n            if (ch === '+' || ch === '-') { // exponent sign\n                number += this.expr.charAt(this.index++)\n            }\n\n            while (Jsep.isDecimalDigit(this.code)) { // exponent itself\n                number += this.expr.charAt(this.index++)\n            }\n\n            if (!Jsep.isDecimalDigit(this.expr.charCodeAt(this.index - 1))) {\n                this.throwError('Expected exponent (' + number + this.char + ')')\n            }\n        }\n\n        chCode = this.code\n\n        // Check to make sure this isn't a variable name that start with a number (123abc)\n        if (Jsep.isIdentifierStart(chCode)) {\n            this.throwError(\n                'Variable names cannot start with a number ('\n                + number + this.char + ')',\n            )\n        } else if (chCode === Jsep.PERIOD_CODE || (number.length === 1 && number.charCodeAt(0) === Jsep.PERIOD_CODE)) {\n            this.throwError('Unexpected period')\n        }\n\n        return {\n            type: Jsep.LITERAL,\n            valueType: 'number',\n            value: parseFloat(number),\n            raw: number,\n        }\n    }\n\n    NEWLINE = String.fromCharCode(10)\n    /**\n     * Parses a string literal, staring with single or double quotes with basic support for escape codes\n     * e.g. `\"hello world\"`, `'this is\\nJSEP'`\n     */\n    gobbleStringLiteral(): Literal {\n        let str = ''\n        const startIndex = this.index\n        const quote = this.expr.charAt(this.index++)\n        let closed = false\n\n        while (this.index < this.expr.length) {\n            let ch = this.expr.charAt(this.index++)\n\n            if (ch === quote) {\n                closed = true\n                break\n            } else if (ch === '\\\\') { // Correct escape character check\n                // Check for all of the common escape codes\n                ch = this.expr.charAt(this.index++)\n                switch (ch) {\n                    case 'n':\n                        str += String.fromCharCode(10)\n                        break\n                    case 'r':\n                        str += String.fromCharCode(13)\n                        break\n                    case 't':\n                        str += String.fromCharCode(9)\n                        break\n                    case 'b':\n                        str += String.fromCharCode(8)\n                        break\n                    case 'f':\n                        str += String.fromCharCode(12)\n                        break\n                    case 'v':\n                        str += String.fromCharCode(11)\n                        break\n                    default:\n                        str += ch\n                }\n            } else {\n                str += ch\n            }\n        }\n\n        if (!closed) {\n            this.throwError('Unclosed quote after \"' + str + '\"')\n        }\n\n        return {\n            type: Jsep.LITERAL,\n            value: str,\n            valueType: 'string',\n            raw: this.expr.substring(startIndex, this.index),\n        }\n    }\n\n    /**\n     * Gobbles only identifiers\n     * e.g.: `foo`, `_value`, `$x1`\n     * Also, this function checks if that identifier is a literal:\n     * (e.g. `true`, `false`, `null`) or `this`\n     */\n    gobbleIdentifier(): Identifier {\n        let ch = this.code, start = this.index\n\n        if (Jsep.isIdentifierStart(ch)) {\n            this.index++\n        } else {\n            this.throwError('Unexpected ' + this.char)\n        }\n\n        while (this.index < this.expr.length) {\n            ch = this.code\n\n            if (Jsep.isIdentifierPart(ch)) {\n                this.index++\n            } else {\n                break\n            }\n        }\n        return {\n            type: Jsep.IDENTIFIER,\n            name: this.expr.slice(start, this.index),\n        }\n    }\n\n    /**\n     * Gobbles a list of arguments within the context of a function call\n     * or array literal. This function also assumes that the opening character\n     * `(` or `[` has already been gobbled, and gobbles expressions and commas\n     * until the terminator character `)` or `]` is encountered.\n     * e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`}\n     */\n    // Allow null elements for array literals like [,,]\n    gobbleArguments(termination: number): (Expression | null)[] {\n        const args: (Expression | null)[] = [] // Initialize with correct type\n        let closed = false\n        let separator_count = 0\n\n        while (this.index < this.expr.length) {\n            this.gobbleSpaces()\n            let ch_i = this.code\n\n            if (ch_i === termination) { // done parsing\n                closed = true\n                this.index++\n\n                if (termination === Jsep.CPAREN_CODE && separator_count && separator_count >= args.length) {\n                    this.throwError('Unexpected token ' + String.fromCharCode(termination))\n                }\n\n                break\n            } else if (ch_i === Jsep.COMMA_CODE) { // between expressions\n                this.index++\n                separator_count++\n\n                if (separator_count !== args.length) { // missing argument\n                    if (termination === Jsep.CPAREN_CODE) {\n                        this.throwError('Unexpected token ,')\n                    } // Handle sparse arrays like [a,,c]\n                    else if (termination === Jsep.CBRACK_CODE) {\n                        // Push null for the missing element before the comma\n                        args.push(null)\n                        // If there are multiple commas like [a,,,d], keep pushing null\n                        while (this.expr.charCodeAt(this.index) === Jsep.COMMA_CODE) {\n                            this.index++\n                            separator_count++\n                            args.push(null)\n                        }\n                    }\n                }\n            } else if (args.length !== separator_count && separator_count !== 0) {\n                // NOTE: `&& separator_count !== 0` allows for either all commas, or all spaces as arguments\n                this.throwError('Expected comma')\n            } else {\n                const node = this.gobbleExpression()\n\n                if (!node || node.type === Jsep.COMPOUND) {\n                    this.throwError('Expected comma')\n                }\n\n                args.push(node)\n            }\n        }\n\n        if (!closed) {\n            this.throwError('Expected ' + String.fromCharCode(termination))\n        }\n\n        return args\n    }\n\n    /**\n     * Responsible for parsing a group of things within parentheses `()`\n     * that have no identifier in front (so not a function call)\n     * This function assumes that it needs to gobble the opening parenthesis\n     * and then tries to gobble everything within that parenthesis, assuming\n     * that the next thing it should see is the close parenthesis. If not,\n     * then the expression probably doesn't have a `)`\n     */\n    gobbleGroup(): Expression {\n        this.index++\n        let nodes = this.gobbleExpressions(Jsep.CPAREN_CODE)\n        if (this.code === Jsep.CPAREN_CODE) {\n            this.index++\n            if (nodes.length === 1) {\n                const node = nodes[0]\n                if (node.type === Jsep.BINARY_EXP) {\n                    node.parenthesis = true\n                }\n                return node\n            } else if (!nodes.length) {\n                this.throwError('Empty group expression')\n            } else {\n                return {\n                    type: Jsep.SEQUENCE_EXP,\n                    expressions: nodes,\n                }\n            }\n        } else {\n            this.throwError('Unclosed (')\n        }\n    }\n\n    /**\n     * Responsible for parsing Array literals `[1, 2, 3]`\n     * This function assumes that it needs to gobble the opening bracket\n     * and then tries to gobble the expressions as arguments.\n     */\n    gobbleArray(): ArrayExpression {\n        this.index++\n\n        return {\n            type: Jsep.ARRAY_EXP,\n            elements: this.gobbleArguments(Jsep.CBRACK_CODE),\n        }\n    }\n}\n\n// Static fields:\nconst hooks = new Hooks()\nObject.assign(Jsep, {\n    hooks,\n    plugins: new Plugins(Jsep),\n\n    // Node Types\n    // ----------\n    // This is the full set of types that any JSEP node can be.\n    // Store them here to save space when minified\n    COMPOUND: 'Compound',\n    SEQUENCE_EXP: 'SequenceExpression',\n    IDENTIFIER: 'Identifier',\n    MEMBER_EXP: 'MemberExpression',\n    LITERAL: 'Literal',\n    THIS_EXP: 'ThisExpression',\n    CALL_EXP: 'CallExpression',\n    UNARY_EXP: 'UnaryExpression',\n    BINARY_EXP: 'BinaryExpression',\n    ARRAY_EXP: 'ArrayExpression',\n    TAGGED_TEMPLATE_EXPRESSION: 'TaggedTemplateExpression',\n    TEMPLATE_LITERAL: 'TemplateLiteral',\n    TEMPLATE_ELEMENT: 'TemplateElement',\n\n    TAB_CODE: 9,\n    LF_CODE: 10,\n    CR_CODE: 13,\n    SPACE_CODE: 32,\n    PERIOD_CODE: 46, // '.'\n    COMMA_CODE: 44, // ','\n    SQUOTE_CODE: 39, // single quote\n    DQUOTE_CODE: 34, // double quotes\n    OPAREN_CODE: 40, // (\n    CPAREN_CODE: 41, // )\n    OBRACK_CODE: 91, // [\n    CBRACK_CODE: 93, // ]\n    QUMARK_CODE: 63, // ?\n    SEMCOL_CODE: 59, // ;\n    COLON_CODE: 58, // :\n    BTICK_CODE: 96, // `\n    OCURLY_CODE: 123, // {\n    CCURLY_CODE: 125, // }\n    FSLASH_CODE: 47, // /\n    BSLASH_CODE: 92, // \\\n    USCORE_CODE: 95, // _\n\n    // Operations\n    // ----------\n    // Use a quickly-accessible map to store all of the unary operators\n    // Values are set to `1` (it really doesn't matter)\n    unary_ops: {\n        '-': 1,\n        '!!': 1,\n        '!': 1,\n        '~': 1,\n        '+': 1,\n    },\n\n    // Also use a map for the binary operations but set their values to their\n    // binary precedence for quick reference (higher number = higher precedence)\n    // see [Order of operations](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)\n    binary_ops: {\n        '||': 1,\n        '??': 1,\n        '&&': 2,\n        '|': 3,\n        '^': 4,\n        '&': 5,\n        '==': 6,\n        '!=': 6,\n        '===': 6,\n        '!==': 6,\n        '<': 7,\n        '>': 7,\n        '<=': 7,\n        '>=': 7,\n        'in': 7,\n        '<<': 8,\n        '>>': 8,\n        '>>>': 8,\n        '+': 9,\n        '-': 9,\n        '*': 10,\n        '/': 10,\n        '%': 10,\n        '**': 11,\n    },\n\n    // sets specific binary_ops as right-associative\n    right_associative: new Set(['**']),\n\n    // Additional valid identifier chars, apart from a-z, A-Z and 0-9 (except on the starting char)\n    additional_identifier_chars: new Set(['$', '_']),\n\n    // Literals\n    // ----------\n    // Store the values to return for the various literals we may encounter\n    literals: {\n        'true': true,\n        'false': false,\n        'null': null,\n        // Numbers and strings are handled directly, no need to list them here\n    } as Record<string, boolean | null | number | string | RegExp>, // Ensure type matches static property\n\n    // Except for `this`, which is special. This could be changed to something like `'self'` as well\n    this_str: 'this',\n})\nJsep.max_unop_len = Jsep.getMaxKeyLen(Jsep.unary_ops)\nJsep.max_binop_len = Jsep.getMaxKeyLen(Jsep.binary_ops)\n\nconst ARROW_EXP = 'ArrowFunctionExpression'\n\nconst CONDITIONAL_EXP = 'ConditionalExpression'\n\nexport const ternary: JSEPPlugin = {\n    name: 'ternary',\n\n    init(jsep) {\n        // Ternary expression: test ? consequent : alternate\n        jsep.hooks.add('after-expression', function gobbleTernary(env: HookEnv) {\n            if (env.node && this.code === jsep.QUMARK_CODE) {\n                this.index++\n                const test = env.node as BinaryExpression\n                const consequent = this.gobbleExpression()\n\n                if (!consequent) {\n                    this.throwError('Expected expression')\n                }\n\n                this.gobbleSpaces()\n\n                if (this.code === jsep.COLON_CODE) {\n                    this.index++\n                    const alternate = this.gobbleExpression()\n\n                    if (!alternate) {\n                        this.throwError('Expected expression')\n                    }\n                    env.node = {\n                        type: CONDITIONAL_EXP as 'ConditionalExpression', // Use constant and assert type\n                        test,\n                        consequent,\n                        alternate,\n                    } as ConditionalExpression // Cast to ConditionalExpression\n\n                    // check for operators of higher priority than ternary (i.e. assignment)\n                    // jsep sets || at 1, and assignment at 0.9, and conditional should be between them\n                    if (test.operator && jsep.binary_ops[test.operator] <= 0.9) {\n                        let newTest = test as BinaryExpression & { right: UnaryExpression; left: UnaryExpression }\n                        while (newTest.right.operator && jsep.binary_ops[newTest.right.operator] <= 0.9) {\n                            // @ts-ignore\n                            newTest = newTest.right\n                        }\n                        env.node.test = newTest.right\n                        // @ts-ignore\n                        newTest.right = env.node\n                        env.node = test\n                    }\n                } else {\n                    this.throwError('Expected :')\n                }\n            }\n        })\n    },\n}\n\nexport const arrow: JSEPPlugin = {\n    name: 'arrow',\n\n    init(jsxp) {\n        // arrow-function expressions: () => x, v => v, (a, b) => v\n        jsxp.addBinaryOp('=>', 0.1, true)\n\n        // this hook searches for the special case () => ...\n        // which would normally throw an error because of the invalid LHS to the bin op\n        // Use HookCallback type for consistency\n        jsxp.hooks.add('gobble-expression', function gobbleEmptyArrowArg(this: Jsep, env: HookEnv) {\n            this.gobbleSpaces()\n            if (this.code === jsxp.OPAREN_CODE) {\n                const backupIndex = this.index\n                this.index++\n\n                this.gobbleSpaces()\n                if (this.code === jsxp.CPAREN_CODE) {\n                    this.index++\n\n                    const biop = this.gobbleBinaryOp()\n                    if (biop === '=>') {\n                        // () => ...\n                        // Rename second 'body' variable to avoid conflict\n                        const arrowBody = this.gobbleBinaryExpression()\n                        if (!arrowBody) {\n                            this.throwError('Expected expression after ' + biop)\n                        }\n                        env.node = {\n                            type: ARROW_EXP as 'ArrowFunctionExpression', // Use constant and assert type\n                            params: null,\n                            body: arrowBody, // Use renamed variable\n                        } // Don't need 'as' assertion if types match HookEnv.node\n                        return // Return from the hook callback\n                    }\n                }\n                this.index = backupIndex\n            }\n        })\n\n        // Use HookCallback type\n        jsxp.hooks.add('after-expression', function fixBinaryArrow(this: Jsep, env: HookEnv) {\n            updateBinariesToArrows(env.node as Expression) // Pass env.node which can be Expression | null\n        })\n\n        // node can be Expression | null\n        function updateBinariesToArrows(node: Expression | null): void { // Use specific type\n            if (node && typeof node === 'object') { // Check if node is an object and not null\n                // Traverse full tree, converting any sub-object nodes as needed\n                Object.values(node).forEach((val) => { // Infer type for val\n                    // Check if val is an Expression or array before recursing\n                    if (val && typeof val === 'object') {\n                        if (Array.isArray(val)) {\n                            val.forEach(updateBinariesToArrows)\n                        } else if ('type' in val) { // Basic check for Expression-like object\n                            updateBinariesToArrows(val as Expression)\n                        }\n                    }\n                })\n\n                // Check if node is a BinaryExpression with operator '=>'\n                if (node.type === jsxp.BINARY_EXP && node.operator === '=>') {\n                    const arrowNode = node as any // Cast to any to modify properties\n                    arrowNode.type = ARROW_EXP\n                    arrowNode.params = arrowNode.left ? [arrowNode.left] : null\n                    arrowNode.body = arrowNode.right\n                    if (arrowNode.params && arrowNode.params[0].type === jsxp.SEQUENCE_EXP) {\n                        arrowNode.params = arrowNode.params[0].expressions\n                    }\n                    // Delete properties after casting to any\n                    delete arrowNode.left\n                    delete arrowNode.right\n                    delete arrowNode.operator\n                    delete arrowNode.parenthesis // Also delete parenthesis property\n                }\n            }\n        }\n    },\n}\n\nconst OBJECT_EXP = 'ObjectExpression'\nconst PROPERTY = 'Property'\n\nexport const object: JSEPPlugin = {\n    name: 'object',\n\n    init(jsxp) {\n        // Object literal support\n        // Use HookCallback type\n        function gobbleObjectExpression(this: Jsep, env: HookEnv) {\n            if (this.code === jsxp.OCURLY_CODE) { // Use static constant\n                this.index++\n                const properties: (Property | Expression)[] = [] // Match ObjectExpression.properties type\n\n                while (this.index < this.expr.length) { // Check index bounds\n                    this.gobbleSpaces()\n                    if (this.code === jsxp.CCURLY_CODE) { // Correct check: CCURLY_CODE\n                        this.index++\n                        // gobbleTokenProperty expects Expression, ensure type matches\n                        const objNode: ObjectExpression = {\n                            type: OBJECT_EXP as 'ObjectExpression', // Use constant and assert\n                            properties,\n                        }\n                        env.node = this.gobbleTokenProperty(objNode)\n                        return // Return from hook callback\n                    }\n\n                    // Note: using gobbleExpression instead of gobbleToken to support object destructuring\n                    const key = this.gobbleExpression()\n                    if (!key) {\n                        break // missing }\n                    }\n\n                    this.gobbleSpaces()\n                    if (key.type === jsxp.IDENTIFIER && (this.code === jsxp.COMMA_CODE || this.code === jsxp.CCURLY_CODE)) {\n                        // property value shorthand\n                        properties.push({\n                            type: PROPERTY as 'Property', // Use constant and assert\n                            computed: false,\n                            key,\n                            value: key,\n                            shorthand: true,\n                        })\n                    } else if (this.code === jsxp.COLON_CODE) {\n                        this.index++\n                        const value = this.gobbleExpression()\n\n                        if (!value) {\n                            this.throwError('unexpected object property')\n                        }\n                        const computed = key.type === jsxp.ARRAY_EXP\n                        properties.push({\n                            type: PROPERTY as 'Property', // Use constant and assert\n                            computed,\n                            key: computed\n                                // Ensure key.elements[0] is an Expression if key is ArrayExpression\n                                ? (key as ArrayExpression).elements[0] as Expression\n                                : key,\n                            value: value,\n                            shorthand: false,\n                        } as Property)\n                        this.gobbleSpaces()\n                    } // Ensure key is not null before pushing\n                    else if (key) {\n                        // spread, assignment (object destructuring with defaults), etc.\n                        properties.push(key)\n                    }\n\n                    if (this.code === jsxp.COMMA_CODE) {\n                        this.index++\n                    }\n                }\n                this.throwError('missing }')\n            }\n        }\n\n        jsxp.hooks.add('gobble-token', gobbleObjectExpression)\n    },\n}\n\nexport const regex: JSEPPlugin = {\n    name: 'regex',\n\n    init(jsxp) {\n        // Regex literal: /abc123/ig\n        // Use HookCallback type\n        jsxp.hooks.add('gobble-token', function gobbleRegexLiteral(this: Jsep, env: HookEnv) {\n            if (this.code === jsxp.FSLASH_CODE) { // Use static constant\n                const patternIndex = ++this.index\n\n                let inCharSet = false\n                while (this.index < this.expr.length) {\n                    // Check for escape char '\\' before checking for '/' or '[' or ']'\n                    const currentCode = this.code // Store current code\n\n                    if (currentCode === jsxp.FSLASH_CODE && !inCharSet) { // Use static constant\n                        const pattern = this.expr.slice(patternIndex, this.index)\n\n                        let flags = ''\n                        while (++this.index < this.expr.length) {\n                            const code = this.code\n                            if (\n                                (code >= 97 && code <= 122) // a...z\n                                || (code >= 65 && code <= 90) // A...Z\n                                || (code >= 48 && code <= 57)\n                            ) { // 0-9\n                                flags += this.char\n                            } else {\n                                break\n                            }\n                        }\n\n                        let value\n                        try {\n                            value = new RegExp(pattern, flags)\n                        } catch (e: unknown) { // Catch unknown error type\n                            if (e instanceof Error) {\n                                this.throwError(e.message)\n                            } else {\n                                this.throwError('Invalid Regular Expression')\n                            }\n                        }\n\n                        const literalNode: Literal = { // Ensure type matches Literal\n                            type: jsxp.LITERAL,\n                            value, // Value is RegExp here\n                            // @ts-ignore\n                            valueType: typeof value,\n                            raw: this.expr.slice(patternIndex - 1, this.index),\n                        }\n                        env.node = literalNode\n\n                        // allow . [] and () after regex: /regex/.test(a)\n                        // gobbleTokenProperty expects Expression, ensure type matches\n                        env.node = this.gobbleTokenProperty(literalNode)\n                        return // Return from hook callback\n                    }\n\n                    if (currentCode === jsxp.BSLASH_CODE) { // Check for backslash first\n                        this.index += 2 // Skip escaped char\n                    } else {\n                        if (currentCode === jsxp.OBRACK_CODE) { // [\n                            inCharSet = true\n                        } else if (inCharSet && currentCode === jsxp.CBRACK_CODE) { // ]\n                            inCharSet = false\n                        }\n                        this.index++ // Move to next char\n                    }\n                }\n                this.throwError('Unclosed Regex') // Throw error if loop finishes without closing '/'\n            }\n        })\n    },\n}\n\nexport const jsepSpread: JSEPPlugin = {\n    name: 'jsepSpread',\n\n    init(jsxp) {\n        // Spread operator: ...a\n        // Works in objects { ...a }, arrays [...a], function args fn(...a)\n        // NOTE: does not prevent `a ? ...b : ...c` or `...123`\n        // Use HookCallback type\n        jsxp.hooks.add('gobble-token', function gobbleSpread(this: Jsep, env: HookEnv) {\n            if ([0, 1, 2].every(i => this.expr.charCodeAt(this.index + i) === jsxp.PERIOD_CODE)) {\n                this.index += 3\n                const argument = this.gobbleExpression() // Can return null\n                if (!argument) {\n                    this.throwError('Expected expression after ...')\n                }\n                env.node = {\n                    type: 'SpreadElement',\n                    argument: argument,\n                } as SpreadElement\n            }\n        })\n    },\n}\n\nconst TAGGED_TEMPLATE_EXPRESSION = 'TaggedTemplateExpression'\nconst TEMPLATE_LITERAL = 'TemplateLiteral'\nconst TEMPLATE_ELEMENT = 'TemplateElement' // Now defined above\n\nexport const jsepTemplateLiteral: JSEPPlugin = {\n    name: 'jsepTemplateLiteral',\n\n    init(jsxp) {\n        // env can be null when called directly, make it optional\n        function gobbleTemplateLiteral(this: Jsep, env?: HookEnv | null, gobbleMember = true): TemplateLiteral | undefined {\n            if (this.code === jsxp.BTICK_CODE) { // Use static constant\n                const node: TemplateLiteral = { // Use TemplateLiteral type\n                    type: TEMPLATE_LITERAL as 'TemplateLiteral', // Use constant and assert\n                    quasis: [],\n                    expressions: [],\n                }\n                let cooked: string | null = '' // cooked can be null\n                let raw = ''\n                let closed = false\n                const length = this.expr.length\n                const templateStart = this.index // Keep track of start for raw value\n\n                const pushQuasi = () => {\n                    const quasi: TemplateElement = { // Use TemplateElement type\n                        type: TEMPLATE_ELEMENT as 'TemplateElement', // Use constant and assert\n                        value: {\n                            raw: raw,\n                            cooked: cooked,\n                        },\n                        tail: closed,\n                    }\n                    node.quasis.push(quasi)\n                }\n\n                this.index++ // Consume opening backtick `\n\n                while (this.index < length) {\n                    const elStart = this.index\n                    let ch = this.expr.charAt(this.index)\n\n                    if (ch === '`') { // End of template literal\n                        raw = this.expr.slice(elStart, this.index)\n                        this.index++ // Consume closing backtick\n                        closed = true\n                        pushQuasi()\n\n                        // Assign node to env if called as a hook\n                        if (env) env.node = node\n\n                        // Optionally gobble member/call expressions after the literal\n                        if (gobbleMember && env) {\n                            // Ensure node is not null before passing\n                            env.node = this.gobbleTokenProperty(node)\n                        }\n\n                        return node // Return the completed TemplateLiteral node\n                    } else if (ch === '$' && this.expr.charAt(this.index + 1) === '{') { // Start of expression hole ${...}\n                        raw = this.expr.slice(elStart, this.index)\n                        pushQuasi() // Push the preceding TemplateElement\n\n                        this.index += 2 // Consume ${\n                        // Pass CCURLY_CODE to gobbleExpressions\n                        node.expressions.push(...this.gobbleExpressions(jsxp.CCURLY_CODE))\n                        if (this.code !== jsxp.CCURLY_CODE) { // Correct check: CCURLY_CODE\n                            this.throwError('unclosed ${')\n                        }\n                        this.index++ // Consume closing }\n\n                        // Reset raw/cooked for the next TemplateElement\n                        raw = ''\n                        cooked = ''\n                    } else { // Regular character or escape sequence\n                        this.index++ // Consume the character\n                        if (ch === '\\\\') { // Escape sequence\n                            if (this.index >= length) {\n                                this.throwError('Invalid escape sequence')\n                            }\n                            const escapedChar = this.expr.charAt(this.index++)\n                            switch (escapedChar) {\n                                case 'n':\n                                    cooked += '\\n'\n                                    break\n                                case 'r':\n                                    cooked += '\\r'\n                                    break\n                                case 't':\n                                    cooked += '\\t'\n                                    break\n                                case 'b':\n                                    cooked += '\\b'\n                                    break\n                                case 'f':\n                                    cooked += '\\f'\n                                    break\n                                case 'v':\n                                    cooked += '\\v'\n                                    break\n                                case '`':\n                                    cooked += '`'\n                                    break\n                                case '$':\n                                    cooked += '$'\n                                    break\n                                case '\\\\':\n                                    cooked += '\\\\'\n                                    break\n                                // TODO: Handle unicode/hex escapes if needed\n                                default:\n                                    // Handle invalid escape sequences - cooked becomes null\n                                    cooked = null\n                                    break\n                            }\n                        } else {\n                            if (cooked !== null) { // Don't append if already invalid\n                                cooked += ch\n                            }\n                        }\n                    }\n                }\n                this.throwError('Unclosed `')\n            }\n            return undefined // Return undefined if not starting with `\n        }\n\n        // Use HookCallback type\n        jsxp.hooks.add('gobble-token', function gobbleTemplateLiteralHook(this: Jsep, env: HookEnv) {\n            // Call the main logic, assigning the result to env.node\n            gobbleTemplateLiteral.call(this, env, true)\n        })\n\n        // Use HookCallback type\n        jsxp.hooks.add('after-token', function gobbleTaggedTemplateIdentifier(this: Jsep, env: HookEnv) {\n            // Check env.node exists and is the right type before proceeding\n            if (env.node && (env.node.type === jsxp.IDENTIFIER || env.node.type === jsxp.MEMBER_EXP) && this.code === jsxp.BTICK_CODE) {\n                const tag = env.node\n                // Call gobbleTemplateLiteral directly, not as a hook, don't gobble member after\n                const quasi = gobbleTemplateLiteral.call(this, undefined, false) // Pass undefined for env\n\n                if (!quasi) {\n                    // Should not happen if BTICK_CODE was detected, but check anyway\n                    this.throwError('Expected template literal after tag')\n                }\n\n                const taggedNode: TaggedTemplateExpression = { // Use specific type\n                    type: TAGGED_TEMPLATE_EXPRESSION as 'TaggedTemplateExpression', // Use constant and assert\n                    tag: tag,\n                    quasi: quasi,\n                }\n                env.node = taggedNode\n\n                // allow . [] and () after tagged template: bar`foo`.length\n                env.node = this.gobbleTokenProperty(taggedNode)\n\n                // No explicit return needed, env.node is modified\n            }\n        })\n    },\n}\nconst FSLSH_CODE = 47; // /\nconst ASTSK_CODE = 42; // *\n\nconst comment: JSEPPlugin  ={\n    name: 'comment',\n\n    init(jsep) {\n        // treat all comments as whitespace to remove from parsing\n        jsep.hooks.add('gobble-spaces', function gobbleComment() {\n            if (this.code === FSLSH_CODE) {\n                let ch = this.expr.charCodeAt(this.index + 1);\n                if (ch === FSLSH_CODE) {\n                    // '//': read to end of line/input\n                    this.index += 1;\n                    while (ch !== jsep.LF_CODE && !isNaN(ch)) {\n                        ch = this.expr.charCodeAt(++this.index);\n                    }\n                    this.gobbleSpaces();\n                }\n                else if (ch === ASTSK_CODE) {\n                    // read to */ or end of input\n                    this.index += 2;\n                    while (!isNaN(ch)) {\n                        ch = this.expr.charCodeAt(this.index++);\n                        if (ch === ASTSK_CODE) {\n                            ch = this.expr.charCodeAt(this.index++);\n                            if (ch === FSLSH_CODE) {\n                                this.gobbleSpaces();\n                                return;\n                            }\n                        }\n                    }\n\n                    // missing closing */\n                    this.throwError('Missing closing comment, */');\n                }\n            }\n        });\n    },\n};\nJsep.plugins.register(ternary, arrow, object, regex, jsepSpread, jsepTemplateLiteral, comment)\n// Backward Compatibility:\nconst jsep = expr => (new Jsep(expr)).parse() as Expression\nconst stdClassProps = Object.getOwnPropertyNames(class Test { })\nObject.getOwnPropertyNames(Jsep)\n    .filter(prop => !stdClassProps.includes(prop) && jsep[prop] === undefined)\n    .forEach((m) => {\n        jsep[m] = Jsep[m]\n    })\njsep.Jsep = Jsep // allows for const { Jsep } = require('jsep');\nexport default jsep\n";export{n as default};
