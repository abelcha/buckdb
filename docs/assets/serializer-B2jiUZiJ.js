const e="\ntype Sep = ','\ntype Sep2 = '='\n\n// Helper to convert literals to strings\ntype ToString<T> = T extends string ? `'${T}'`\n    : T extends number ? `${T}`\n    : T extends boolean ? `${T}`\n    : never\n\n// Helper to check if a type is an object\ntype IsObject<T> = T extends Record<string, any> ? T : never\n\n// --- Recursive Serialization Helpers ---\n\n// Helper type to map and join array elements recursively\ntype SerializeValueArrayHelper<A extends any[]> = // Removed Depth\n    // Removed depth check\n    A extends [infer Head, ...infer Tail] ? `${SerializeValue<Head>}${Tail extends [] ? '' : Sep}${SerializeValueArrayHelper<Tail>}` // Removed Decrement\n        : ''\n\n// Helper to serialize any value (primitive, object, or array)\nexport type SerializeValue<T> = // Removed Depth default\n    // Removed depth check\n    T extends string | number | boolean ? ToString<T> // Handle primitives\n        : T extends readonly any[] // Handle readonly arrays first\n            ? `[${SerializeValueArrayHelper<[...T]>}]` // Removed Depth\n        : T extends any[] // Handle mutable arrays\n            ? `[${SerializeValueArrayHelper<T>}]`\n        : T extends Record<string, any> // Handle objects\n            ? `{${SerializeNested<T>}}` // Use SerializeNested for object contents\n        : 'unknown' // Fallback for other types (e.g., null, undefined handled by runtime)\n\n// --- Original Types Modified ---\n\ntype SepNested = ':'\n\n// Helper to create key-value pair strings for NESTED objects (uses ':')\ntype KeyValuePairsMapNested<T extends Record<string, any>> = {\n    [K in keyof T as K extends string ? K : never]: K extends string ? `${K}${SepNested}${SerializeValue<T[K]>}` // Nested uses SepNested (:)\n        : never\n}\n\n// Helper to create key-value pair strings for TOP LEVEL (uses '=')\ntype KeyValuePairsMap<T extends Record<string, any>> = {\n    [K in keyof T as K extends string ? K : never]: K extends string ? `${K}${Sep2}${SerializeValue<T[K]>}` // Top level uses Sep2 (=)\n        : never\n}\n\n// Extract the values as a union\ntype KeyValuePairs<T extends Record<string, any>> = KeyValuePairsMap<T>[keyof KeyValuePairsMap<T>] // Removed Depth\n\n// Helpers for union-to-tuple and joining\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n    k: infer I,\n) => void ? I\n    : never\n\ntype UnionToTuple<T> = UnionToIntersection<\n    T extends any ? () => T : never\n> extends () => infer R ? [...UnionToTuple<Exclude<T, R>>, R]\n    : []\n\ntype JoinUnion<T extends string, Delimiter extends string = ','> = UnionToTuple<T> extends infer Tuple ? Tuple extends [infer First, ...infer Rest] // Matches one or more\n        ? Rest extends [] // Is Rest empty? (i.e., Tuple had only one element)\n            ? First & string // If yes, just return First\n        : Rest extends string[] // Is Rest non-empty?\n            ? `${First & string}${Delimiter}${JoinUnion<Rest[number], Delimiter>}` // If yes, add delimiter and recurse\n        : never // Should not happen\n    : '' // Tuple was empty\n    : never\n\n// Type to extract and join key-value pairs for NESTED objects (uses KeyValuePairsMapNested with ':')\ntype SerializeNested<\n    T extends Record<string, any>,\n> = JoinUnion<KeyValuePairsMapNested<T>[keyof KeyValuePairsMapNested<T>]>\n\n// Main type for TOP LEVEL serialization (uses KeyValuePairsMap with '=')\nexport type Serialize<\n    T extends Record<string, any>,\n> = JoinUnion<KeyValuePairs<T>>\n\nexport function __serialize<T>(value: T, depth = 0): string { // Removed depth parameter\n    // Removed depth check\n\n    if (value === null || value === undefined) {\n        return 'null'\n    }\n\n    if (typeof value === 'string') {\n        return `'${value}'`\n    }\n\n    if (typeof value === 'number' || typeof value === 'boolean') {\n        return String(value)\n    }\n\n    if (Array.isArray(value)) {\n        if (value.length === 0) return '[]'\n        return `[${value.map(item => __serialize(item, depth + 1)).join(',')}]` // Removed depth from recursive call\n    }\n\n    if (typeof value === 'object') {\n        const pairs = Object.entries(value)\n            .map(([key, val]) => `${key}${depth === 0 ? '=' : ':'}${__serialize(val, depth + 1)}`) // Removed depth from recursive call\n            .join(',')\n\n        return depth === 0 ? pairs : `{${pairs}}`\n    }\n    return 'unknown'\n}\nexport function serialize<\n    const T extends Record<string, any>,\n>(obj: T) { // Removed Depth parameter\n    return __serialize(obj) as unknown as JoinUnion<KeyValuePairs<T>> // Removed Depth logic from return type\n}\n\n// console.log(__serialize(['toto', 'tata', { lol: 123, xx: \"12\" }]))\n\n// const obj = { d: 1, z: { a: 1, b: '2' }, x: ['toto'], u: true } as const\n// const t4 = serialize(obj) satisfies\n//   `d=1,z={a:1,b:'2'},x=['toto'],u=true`\n// const type_check: `d=1,z={a:1,b:'2'},x=['toto'],u=true` = serialize(obj) // should be ok\n\n// --- New Ordered Serialization based on Key Tuple ---\n\n// Helper to stringify array elements recursively for the joiner (for Ordered)\ntype Ordered_StringifyArrayRest<A extends readonly any[]> = A extends readonly [] ? ''\n    : A extends readonly [infer First, ...infer Rest] ? `${Sep}${Ordered_StringifyValue<First>}${Ordered_StringifyArrayRest<Rest>}`\n    : string // Fallback for non-tuple arrays\n\n// Helper to stringify array literals into a JSON-like string literal (for Ordered)\ntype Ordered_StringifyArray<A extends readonly any[]> = A extends readonly [] ? '[]'\n    : A extends readonly [infer First, ...infer Rest] ? `[${Ordered_StringifyValue<First>}${Ordered_StringifyArrayRest<Rest>}]`\n    : string // Fallback for non-tuple arrays\n\n// Helper to stringify individual values into string literals (for Ordered)\n// (Handles primitives, null, undefined, arrays, and NESTED objects using ':' separator)\ntype Ordered_StringifyValue<V> = V extends string ? `'${V}'` // Use single quotes for strings\n    : V extends number | boolean ? `${V}` // Handle numbers and booleans directly\n    : V extends null ? 'null' // Handle null\n    : V extends undefined ? 'undefined' // Handle undefined\n    : V extends readonly any[] ? Ordered_StringifyArray<V> // Handle arrays/tuples recursively\n    : V extends object ? `{${SerializeNested<V>}}` // Reuse original SerializeNested (uses ':')\n    : 'unknown' // Default fallback\n\n// Helper to filter keys from K that exist in O\nexport type FilterKeys<K extends readonly string[], O = {}> = O extends Record<string, any> ? K extends readonly [infer F, ...infer R extends readonly string[]] // Ensure R is string[]\n        ? F extends keyof O ? [F, ...FilterKeys<R, O>] // Keep F if it's in O\n        : FilterKeys<R, O> // Discard F if it's not in O\n    : [] // Base case: empty tuple\n    : 321\n\n// type res = FilterKeys<['a', 'b', 'c'], {}>; // Should be ['a', 'b']\n\n// Core recursive serializer using filtered keys\ntype SerializeOrderedCore<O, FK extends readonly (keyof O)[]> = FK extends readonly [infer First extends keyof O, ...infer Rest extends (keyof O)[]]\n    // Construct \"key=value\" pair for the first element using O\n    ? `${First & string}${Sep2}${Ordered_StringifyValue<O[First]>}${\n        // Check if there are more keys in Rest\n        Rest extends readonly []\n            // If Rest is empty, we're done\n            ? ''\n            // If Rest is not empty, add a comma and recurse\n            : `${Sep}${SerializeOrderedCore<O, Rest>}`}`\n    // Base case: If FK is empty, return an empty string\n    : ''\n\n/**\n * Serializes properties of O specified by the keys present in both tuple K and O,\n * into a string literal. The order of keys in the output string matches the order in K.\n *\n * @template K A tuple containing potential keys, defining the order.\n * @template O The object containing the actual values to serialize.\n */\nexport type SerializeOrdered<\n    K extends readonly string[],\n    O extends Record<string, any>,\n> = SerializeOrderedCore<O, K> // Use FilterKeys and Core (Removed assertion)\n\n// --- Example Usage for SerializeOrdered ---\n\n// // Define an example object type\n\n// // Define the keys and order\n// type KeysExample = ['toto', 'tata', 'nothing'];\n\n// // Apply the new Serialize type\n// type ResultExample = SerializeOrdered<MyObjectExample, KeysExample>;\n\n// //   ^? type ResultExample = \"toto=123,tata=[\\\"zz\\\",true,null],nothing=undefined\"\n\n// // Another example\n// type ResultExample2 = SerializeOrdered<MyObjectExample, KeysExample2>;\n// //   ^? type ResultExample2 = \"extra=\\\"extra\\\",config={...},toto=123\"\n\n// // Empty keys\n// type ResultExampleEmpty = SerializeOrdered<MyObjectExample, []>;\n// //   ^? type ResultExampleEmpty = \"\"\n\n// // Single key\n// type ResultExampleSingle = SerializeOrdered<MyObjectExample, ['tata']>;\n\n// type Keys = ['a', 'b', 'c', 'd', 'e', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n\ntype Model = {\n    a: string\n    b: number\n    c: boolean\n    d: string[]\n    e: { nested: number[] }\n}\n\n// Use the updated 2-argument signature for SerializeOrdered\n// type Result1 = SerializeOrdered<Keys, { c: false, a: 'toto', g: { lol: 123, toto: 'xx' } }>;\n// type Result2 = SerializeOrdered<Keys, { sdq: 123, a:11, }>;\n// Nested object 'g' should now use ':' internally. Test if Result1 extends the union of possible orders.\n// type test_case = Assert<Result1 extends (\"a='toto',c=false,g={lol:123,toto:'xx'}\" | \"a='toto',c=false,g={toto:'xx',lol:123}\") ? true : false>;\n";export{e as default};
