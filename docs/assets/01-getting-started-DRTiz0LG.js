const n="// ðŸš€ BuckDB: Getting Started - Real Working Examples\n// All examples use actual DuckDB system tables with realistic operations\n\nimport { Buck, MemoryDB } from '@buckdb/isomorphic'\n\n// ================================\n// ðŸŽ¯ TYPE-SAFE QUERYING - The Foundation\n// ================================\n\n// Basic query with type checking using satisfies\nconst basicResult = await MemoryDB.from('duckdb_functions()')\n    .select(e => ({\n        function_name: e.function_name,\n        function_type: e.function_type,\n    }))\n    .execute() satisfies {\n        function_name: string\n        function_type: string\n    }[]\n\nconsole.log('Basic query:', basicResult)\n\n\n// ================================\n// ðŸŽª WHERE CLAUSES - Boolean operations used correctly\n// ================================\n\n// Boolean operations in WHERE clauses - this is the correct way!\nconst whereClausesResult = await MemoryDB.from('duckdb_functions()')\n    .select(e => ({\n        function_name: e.function_name,\n        function_type: e.function_type,\n        name_length: e.function_name.len(),\n    }))\n    .where(e => e.function_name.Like('%sum%') && e.function_name.len().Between(3, 15))\n    .execute() satisfies {\n        function_name: string\n        function_type: string\n        name_length: number\n    }[]\n\n// console.log('WHERE with Like and Between:', whereClausesResult)\n\n// Using array values\nconst notNullResult = await MemoryDB.from('duckdb_functions()')\n    .select(e => [e.function_name, e.function_type, e.function_name.len()])\n    .where(e => !e.description.IsNull())\n    .limit(5)\n    .execute() satisfies [string, string, number][]\n\nconsole.log('Functions with descriptions:', notNullResult)\n\n\n// String WHERE clause\nconst stringWhereResult = await MemoryDB.from('duckdb_functions()')\n    .select(e => ({\n        function_name: e.function_name,\n    }))\n    .where(\"function_name LIKE '%array%'\")\n    .limit(3)\n    .execute() satisfies {\n        function_name: string\n    }[]\n\nconsole.log('String WHERE clause:', stringWhereResult)\n\n// ================================\n// ðŸŒŸ STRING OPERATIONS - Text processing\n// ================================\n\n// String methods in SELECT - non-boolean operations\nconst stringOpsResult = await MemoryDB.from('duckdb_functions()')\n    .select(e => ({\n        original: e.function_name,\n        upper_name: e.function_name.upper(),\n        name_length: e.function_name.len(),\n        prefix_3: e.function_name[0.3],\n        suffix_3: e.function_name[-3],\n        starts_with_a: e.function_name.starts_with('a')\n    }))\n    .where(e => e.function_name.len() < 10)\n    .limit(5)\n    .execute() satisfies {\n        original: string\n        upper_name: string\n        name_length: number\n        prefix_3: string\n        suffix_3: string\n        starts_with_a: boolean\n    }[]\n\nconsole.log('String operations:', stringOpsResult)\n\n// ================================\n// ðŸ“Š GROUPBY WITH AGGREGATIONS - Keyed results\n// ================================\n\n// GroupBy returns Record<string, Array> - very powerful!\nconst groupedResult = await MemoryDB.from('duckdb_functions()')\n    .select((e, D) => ({\n        function_count: D.count(),\n        shortest_name: D.min(e.function_name),\n        avg_name_length: D.avg(e.function_name.len()),\n    }))\n    .groupBy('function_type')\n    .execute() satisfies Record<string, {\n        function_count: number\n        shortest_name: string\n        avg_name_length: number\n    }[]>\n\nconsole.log('Function types:', Object.keys(groupedResult))\nconsole.log('Scalar functions count:', groupedResult.scalar?.[0]?.function_count)\n\n// ================================\n// ðŸŽ¯ SINGLE ROW OPERATIONS - minBy/maxBy\n// ================================\n\n// minBy/maxBy return single objects, not arrays!\nconst shortestFunctionResult = await MemoryDB.from('duckdb_functions()')\n    .select(e => ({\n        function_name: e.function_name,\n        function_type: e.function_type,\n        name_length: e.function_name.len(),\n    }))\n    .minBy(e => e.function_name.len())\n    .execute() satisfies {\n        function_name: string\n        function_type: string\n        name_length: number\n    }\n\nconsole.log('Shortest function name:', shortestFunctionResult)\n\n// ================================\n// ðŸŽ² SAMPLING AND PAGINATION\n// ================================\n\n// Sample and pagination work together\nconst sampleResult = await MemoryDB.from('duckdb_functions()')\n    .select(e => ({\n        function_name: e.function_name,\n        function_type: e.function_type,\n    }))\n    .where(e => e.function_type === 'scalar')\n    .sample(10)\n    .limit(3)\n    .execute() satisfies {\n        function_name: string\n        function_type: string\n    }[]\n\nconsole.log('Sample result:', sampleResult)\n\n// ================================\n// ðŸ§® NUMERIC OPERATIONS - Mathematical expressions\n// ================================\n\n// Numeric operations on function metadata\nconst numericResult = await MemoryDB.from('duckdb_functions()')\n    .select(e => ({\n        function_name: e.function_name,\n        name_length: e.function_name.len(),\n        length_squared: e.function_name.len() * e.function_name.len(),\n        length_plus_ten: e.function_name.len() + 10,\n        length_mod_3: e.function_name.len() % 3,\n    }))\n    .where(e => e.function_name.len().Between(5, 15))\n    .limit(5)\n    .execute() satisfies {\n        function_name: string\n        name_length: number\n        length_squared: number\n        length_plus_ten: number\n        length_mod_3: number\n    }[]\n\nconsole.log('Numeric operations:', numericResult)\n\n// ================================\n// ðŸŽ­ CONDITIONAL EXPRESSIONS - Ternary operators\n// ================================\n\n// Ternary operators compile to SQL CASE statements\nconst conditionalResult = await MemoryDB.from('duckdb_functions()')\n    .select(e => ({\n        function_name: e.function_name,\n        category: e.function_type === 'scalar' ? 'SCALAR_FUNC' : 'OTHER_FUNC',\n        size_category: e.function_name.len() > 10 ? 'LONG' :\n            e.function_name.len() > 5 ? 'MEDIUM' : 'SHORT',\n        mixed_result: e.function_name === 'sum' ? 42 : e.function_name,\n    }))\n    .limit(5)\n    .execute() satisfies {\n        function_name: string\n        category: string\n        size_category: string\n        mixed_result: string | number\n    }[]\n\nconsole.log('Conditional expressions:', conditionalResult)\n\n// ================================\n// ðŸ—ï¸ NESTED STRUCTURES - Complex objects\n// ================================\n\n// Deep object nesting in select clauses\nconst nestedResult = await MemoryDB.from('duckdb_functions()')\n    .select(e => ({\n        metadata: {\n            name: e.function_name,\n            type: e.function_type,\n            analysis: {\n                length: e.function_name.len(),\n                category: e.function_name.len() > 10 ? 'long' : 'short',\n                first_char: e.function_name[0.1],\n            },\n        },\n    }))\n    .where(e => e.function_type === 'scalar')\n    .limit(3)\n    .execute() satisfies {\n        metadata: {\n            name: string\n            type: string\n            analysis: {\n                length: number\n                category: string\n                first_char: string\n            }\n        }\n    }[]\n\nconsole.log('Nested structure:', nestedResult)\n\n// ================================\n// ðŸ”— PATTERN MATCHING - WHERE clause patterns\n// ================================\n\n// xxzPattern matching with Like, Between, IsNull used correctly in WHERE\nconst patternResult = await MemoryDB.from('duckdb_functions()')\n    .select()\n    .where(e =>\n        e.function_name.Like('%str%') &&\n        e.function_name.len().Between(3, 12) &&\n        !e.description.IsNull()\n    )\n    .execute() satisfies {\n        function_name: string\n        name_length: number\n        function_type: string\n    }[]\n\nconsole.log('Pattern matching in WHERE:', patternResult)\n\n// ================================\n// âž• STRING CONCATENATION - Template literals\n// ================================\n\n// String concatenation using multiple patterns\nconst stringConcatResult =\n    await MemoryDB.from('duckdb_functions()')\n        .select(e => ({\n            // Template literal style\n            description: `Function \"${e.function_name}\" is of type ${e.function_type}`,\n\n            // Plus operator concatenation\n            simple_concat: e.function_name + '_func',\n\n            // Mixed operations\n            detailed_info: 'Name: ' + e.function_name + ', Length: ' + e.function_name.len(),\n        }))\n        .where(e => e.function_type === 'scalar')\n        .limit(3)\n        .execute() satisfies {\n            description: string\n            simple_concat: string\n            detailed_info: string\n        }[]\n\nconsole.log('String concatenation:', stringConcatResult)\n\n// ================================\n// ðŸŽ¯ ADVANCED AGGREGATIONS\n// ================================\n\n// Advanced aggregation patterns\nconst advancedAggResult = await MemoryDB.from('duckdb_functions()')\n    .select((e, D) => ({\n        function_type: e.function_type,\n        total_functions: D.count(),\n        function_names: D.array_agg(e.function_name),\n        avg_name_length: D.avg(e.function_name.len()),\n        longest_name: D.max(e.function_name),\n        shortest_name: D.min(e.function_name),\n    }))\n    .groupBy('function_type')\n    .execute() satisfies Record<string, {\n        function_type: string\n        total_functions: number\n        function_names: string[]\n        avg_name_length: number\n        longest_name: string\n        shortest_name: string\n    }[]>\n\nconsole.log('Advanced aggregations by type:')\nObject.entries(advancedAggResult).forEach(([type, data]) => {\n    console.log(`${type}: ${data[0].total_functions} functions, avg length: ${data[0].avg_name_length.toFixed(1)}`)\n})\n\n// ================================\n// ðŸ”— REALISTIC JOINS\n// ================================\n\n// Cross join to demonstrate multi-table operations\nconst joinResult = await MemoryDB.from('duckdb_functions()')\n    .join('duckdb_types()', 'types').on((a, b) => true) // Cross join\n    .select(e => ({\n        function_name: e.duckdb_functions.function_name,\n        type_name: e.types.logical_type,\n        combination: e.duckdb_functions.function_name + '_' + e.types.logical_type,\n    }))\n    .where(e => e.duckdb_functions.function_type === 'scalar' && e.types.logical_type.Like('%INT%'))\n    .limit(5)\n    .execute() satisfies {\n        function_name: string\n        type_name: string\n        combination: string\n    }[]\n\nconsole.log('Join result:', joinResult)\n\n/*\nðŸš€ What makes BuckDB extraordinary?\n\nâœ¨ TYPE SAFETY: Full TypeScript integration with satisfies checks\nâœ¨ COMPLEX JOINS: Multi-table operations with intelligent aliases\nâœ¨ STRING OPERATIONS: levenshtein, damerau_levenshtein, concat_ws, etc.\nâœ¨ AGGREGATION POWER: groupBy returns Record<string, T[]> structures\nâœ¨ SINGLE ROW OPS: minBy/maxBy return single objects, not arrays\nâœ¨ KEYED RESULTS: keyBy creates Record<string, T> lookups\nâœ¨ SAMPLING: sample(N) or sample('50%') for data sampling\nâœ¨ NESTED OBJECTS: Deep object structures in select clauses\nâœ¨ NUMERIC OPS: pow, sqrt, to_hex, to_base with type safety\nâœ¨ CONDITIONALS: Ternary operators with proper type inference\nâœ¨ MIXED TYPES: Implicit conversions handled intelligently\n\nðŸŽ¯ Next: Explore CTEs, unions, array operations, and advanced patterns!\n*/\n\nconsole.log('ðŸŽ‰ BuckDB: Where JavaScript truly meets SQL!')\n";export{n as default};
