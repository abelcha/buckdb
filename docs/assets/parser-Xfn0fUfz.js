const n="import { DMetaField } from '.buck/types'\nimport jsep, { ArrayExpression, ArrowFunctionExpression, BinaryExpression, CallExpression, ConditionalExpression, Expression, Identifier, Literal, MemberExpression, ObjectExpression, Property, SequenceExpression, SpreadElement, TemplateElement, TemplateLiteral, UnaryExpression } from './jsep'\nimport { AggregateFunctions, LitteralTypesMap, PatternMatchers, PolyfillMapping, UnmethodMapping } from './typedef'\nimport { wrap, Σ } from './utils'\n\nconst RegexpFuncsWthOptions = new Map([\n  ['regexp_extract', 3],\n  ['regexp_extract_all', 3],\n  ['regexp_replace', 3],\n  ['regexp_matches', 2],\n  ['regexp_full_matches', 2],\n])\n\nconst UnaryOperatorMap = new Map([\n  ['!!', 'NOTNULL'],\n  ['!', 'NOT'], // Logical negation\n  ['-', '-'], // Numeric negation\n  ['+', '+'], // Unary plus (no change needed)\n  ['~', '~'], // Bitwise NOT (DuckDB supports this)\n])\n\nfunction mapUnaryOperator(jsOperator: any) {\n  if (!UnaryOperatorMap.has(jsOperator)) {\n    throw new Error(`Unsupported unary operator: ${jsOperator}`)\n  }\n  return UnaryOperatorMap.get(jsOperator)\n}\n\nconst OperatorMap = new Map([\n  ['==', '='],\n  ['!=', '!='],\n  ['===', '='],\n  ['!==', 'is distinct from'],\n  ['??', 'COALESCE'],\n  ['+', '+'],\n  ['-', '-'],\n  ['*', '*'],\n  ['/', '/'],\n  ['%', '%'],\n  ['&&', 'AND'],\n  ['||', 'OR'],\n  ['>', '>'],\n  ['<', '<'],\n  ['>=', '>='],\n  ['<=', '<='],\n  ['in', 'IN'],\n])\nfunction mapOperator(jsOperator: any) {\n  if (!OperatorMap.has(jsOperator)) {\n    throw new Error(`Unsupported operator: ${jsOperator}`)\n  }\n  return OperatorMap.get(jsOperator)\n}\n\nconst joinMembers = (members: any[]) => {\n  if (!Array.isArray(members)) {\n    return members\n  }\n  return members?.reduce?.((acc, member) => {\n    if (!acc) return member\n    if (member === \"'*'\") {\n      return acc + '.*'\n    }\n    if (typeof member === 'number') {\n      return acc + '[' + member.toString().replace('.', ':') + ']'\n    }\n    if (member instanceof Number && 'raw' in member) {\n      return acc + '[' + (member as any).raw.replace('.', ':') + ']'\n    }\n    if (member?.startsWith(\"'\") && member?.endsWith(\"'\")) {\n      return acc + `[${member}]`\n    }\n    return acc + '.' + member\n  }, '')\n}\n\nconst SLASH = String.fromCharCode(47)\nconst BACKSLASH = String.fromCharCode(92)\n// Helper function to check if a node is or contains a string literal\nfunction hasStringLiteral(node: BinaryExpression | Expression): boolean {\n  if (!node) return false\n  // Check for nested string literals in binary expressions\n  if (node.type === 'BinaryExpression') {\n    return hasStringLiteral(node.right) || hasStringLiteral(node.left)\n  }\n  // Direct string literal\n  return node.type === 'Literal' && typeof node.value === 'string'\n}\n\n// Helper function to recursively transform string concatenation\nfunction transformStringConcat(node: any, transformer: any, isTopLevel = true): any {\n  // If not a binary expression or not addition, process normally\n  if (node.type !== 'BinaryExpression' || node.operator !== '+') {\n    return transformer(node)\n  }\n\n  // Recursively process left and right sides\n  const left = transformStringConcat(node.left, transformer, false)\n  const right = transformStringConcat(node.right, transformer, false)\n\n  // Always use || for concatenation in binary expressions that contain strings\n  const result = `${left} || ${right}`\n  return isTopLevel ? `(${result})` : result\n}\n// Process template literal parts into SQL concatenation\nfunction processTemplateLiteral(\n  node: TemplateLiteral,\n  transformer: (node: Expression) => string,\n): string {\n  if (node.expressions.length === 0) {\n    // Simple template literal without expressions\n    const cooked = node.quasis[0]?.value?.cooked ?? node.quasis[0]?.value?.raw\n    if (cooked === undefined) {\n      throw new Error('TemplateLiteral quasis[0].value.cooked is undefined.')\n    }\n    return `'${cooked.replaceAll(/'/g, \"''\")}'`\n  }\n\n  // Template literal with expressions - use SQL string concatenation with ||\n  const parts: string[] = []\n\n  // Process each part of the template literal\n  for (let i = 0; i < node.quasis.length; i++) {\n    const quasi = node.quasis[i]\n    if (!quasi) {\n      throw new Error(`Template literal has undefined quasi at index ${i}`)\n    }\n    // Only add non-empty string parts\n    if ((quasi.value.cooked ?? quasi.value.raw) !== '') {\n      parts.push(`'${(quasi.value.cooked ?? quasi.value.raw).replaceAll(/'/g, \"''\")}'`)\n    }\n\n    // Add expression if not at the end\n    if (!quasi.tail) {\n      const expr = transformer(node.expressions[i] as Expression)\n\n      // If the expression contains binary operators, ensure it's properly parenthesized\n      if (node.expressions[i]?.type === 'BinaryExpression' && !expr.startsWith('(')) {\n        parts.push('(' + expr + ')')\n      } else {\n        parts.push(expr)\n      }\n    }\n  }\n\n  // Join all parts with the SQL concatenation operator\n  return `(${parts.join(' || ')})`\n}\n\ntype Topts = {\n  isFuncArg?: boolean\n  closureVars?: string[]\n}\n\n// type oProps = { subMemberExpression?: boolean, isProperty?: boolean }\nexport function transformDuckdb(node: Expression, params = new Map<string, { depth: number; position: number }>(), context: Record<string, any> = {}) {\n  function transformTree(node: Expression, opts: Topts = { isFuncArg: false }): any {\n    const transformNode = (n: any, o = {}) => transformTree(n, Object.assign({}, opts, o))\n    // const transform = (node: any, ..._: any[]) => transformNode(node)\n    const isGlobalMethod = (node: CallExpression) => {\n      return node.callee.type === 'MemberExpression' && node.callee.object.type === 'Identifier' && params.get(node.callee.object.name)?.position === 1\n    }\n    const MapFunc = {\n      TaggedTemplateExpression: (node: any) => {\n        const { quasis, expressions } = node.quasi;\n        let result = \"\";\n        for (let i = 0; i < quasis.length; i++) {\n          result += quasis[i].value.cooked;\n          if (i < expressions.length) {\n            result += `\\${...}`; // or inject placeholder, or evaluate if needed\n          }\n        }\n\n        return result;\n      },\n      ObjectExpression(node: ObjectExpression) {\n        return `{${node.properties.map(transformNode).join(', ')}}`\n      },\n      Property(node: Property) {\n        return `${transformNode({ ...node.key, isProperty: true })}: ${transformNode(node.value)}`\n      },\n      SequenceExpression(node: SequenceExpression) {\n        return node.expressions.map(transformNode).join(', ')\n      },\n      Identifier(node: Identifier) {\n        if (!node.isProperty) {\n          if (params.has(node.name)) {\n            if (params.get(node.name)?.depth === 0) {\n              return null\n            }\n            return node.name\n          } else if (opts.closureVars?.includes(node.name)) {\n            return node.name\n          } else if (typeof globalThis[node.name] !== 'undefined') {\n            return `${node.name}`\n          } else if (typeof context[node.name] !== 'undefined') {\n            return '(' + JSON.stringify(context[node.name]).replaceAll(/'/g, \"''\").replaceAll(/\\\"/g, \"'\") + ')'\n          } else {\n            throw new Error(`Undefined variable: ${node.name}, use .context({ ${node.name} }) too pass it down`)\n          }\n        }\n        return node.name\n      },\n      MemberExpression(node: MemberExpression) {\n        node as MemberExpression\n        const hasSubMember = node.object?.type === 'MemberExpression'\n        if (hasSubMember && node.property.type === 'Identifier' && !node.subMemberExpression && node.property.name === 'length') {\n          node.property.name = 'len()' // tmp\n        }\n        if (hasSubMember) {\n          node.object.subMemberExpression = true\n        }\n        if (node.property.type === 'UnaryExpression' && node.property.operator === '-' && node.property.argument?.type === 'Literal' && node.property.argument.valueType === 'number' && typeof node.property.argument.value === 'number') {\n          node.property = {\n            type: 'Literal',\n            value: -node.property.argument.value,\n            raw: '-' + node.property.argument.raw,\n            valueType: 'number',\n          }\n          return transformNode(node)\n        }\n        node.property.isProperty = true\n        const rtn = [transformNode(node.object), transformNode(node.property)].filter(Boolean).flatMap(x => x) as string[]\n        // @ts-ignore\n        return opts.isFuncArg && node.accessor !== '[' ? rtn : joinMembers(rtn)\n      },\n      Literal(node: Literal) {\n        node = node as Literal\n        if (node.value instanceof RegExp) {\n          const value = node.value as RegExp\n          const rgx = node.value.toString().split(SLASH).slice(1, -1).join(SLASH)\n          const flags = false && opts.isFuncArg && value.flags ? `, '${value.flags}'` : ''\n          return `'${rgx}'` + flags\n        }\n        if (node.value === null) {\n          return 'NULL'\n        }\n        if (node.raw.startsWith('\"') && node.raw.endsWith('\"')) {\n          return `'${node.raw.slice(1, -1).replaceAll(/'/g, \"''\")}'`\n        }\n        if (typeof node.value === 'number') {\n          const rtn = new Number(node.value)\n          return Object.assign(rtn, { raw: node.raw })\n        }\n        return node.raw\n      },\n      CallExpression(node: CallExpression) {\n\n        if (node.callee.type === 'MemberExpression' && node.callee.property.type === 'Identifier' && PolyfillMapping[node.callee.property.name]) {\n          if (node.callee.property.name === 'filter') {\n            const calleeArr = transformNode(node.callee, { isFuncArg: true })\n            if (AggregateFunctions.find(e => calleeArr[0].startsWith(e))) {\n              const gargs = node.arguments.map(transformNode)\n              return `${calleeArr.slice(0, -1)} FILTER (${gargs.join(', ')})`\n            }\n          }\n          node.callee.property.name = PolyfillMapping[node.callee.property.name]\n        }\n        const calleeArr = transformNode(node.callee, { isFuncArg: true })\n        const lastCallee = calleeArr[calleeArr.length - 1]\n        // let args = node.arguments.map(e => transformNode(e, { isFuncArg: true }))\n        let args = node.arguments.map(e => joinMembers(transformNode(e, { isFuncArg: true }) || []))\n        // console.log({ argsx })\n\n        if (RegexpFuncsWthOptions.has(lastCallee)) {\n          const offset = RegexpFuncsWthOptions.get(lastCallee) as number\n          const index = node.arguments.findIndex((e) => e?.type === 'Literal' && e.value instanceof RegExp)\n          if (index >= 0) {\n            // const pargs = node.arguments.slice(index)\n            if (offset === 3 && node.arguments.length === index + 1) {\n              args.push('0')\n            }\n            if (node.arguments.length - offset < index) {\n              let value = (node.arguments[index] as Literal)?.value\n              if (value instanceof RegExp && value.flags) {\n                args.push(wrap(value.flags, \"'\"))\n              }\n            }\n          }\n        }\n        const firstValue = (node.arguments[0] as Literal)?.value\n        const secValue = (node.arguments[1] as Literal)?.value\n\n        // console.log({ lastCallee })\n        // if (UnmethodMapping[lastCallee]) {\n        //   console.log('==========')\n        //   const gargs = node.arguments.map(transformNode)\n        //   console.log({ lastCallee })\n        //   if (lastCallee === 'filter') {\n        //     console.log('lastcalllllllle')\n        //     if (AggregateFunctions.find(e => calleeArr[0].startsWith(e)))\n        //       return `${calleeArr.slice(0, -1)} FILTER (${gargs.join(', ')})`\n        //   }\n        //   if (node.arguments?.[0]?.type === 'ArrowFunctionExpression') {\n        //     return UnmethodMapping[lastCallee](`${calleeArr.slice(0, -1).join('.')}, ${gargs.join(', ')}`);\n        //   }\n        //   return UnmethodMapping[lastCallee](`${calleeArr.slice(0, -1).join('.')}, ${gargs.join(', ')}`)\n        // }\n        if (PatternMatchers[lastCallee]) {\n          const { keyword, joinWith } = PatternMatchers[lastCallee]\n          if (node.callee.type === 'MemberExpression' && node.callee.object?.type === 'Identifier' && params.has(node.callee.object.name)) {\n            return `${args[0]} ${keyword} ${args.slice(1).join(joinWith)}`\n          }\n          if (lastCallee in Σ('SimilarTo', 'regexp_matches') && firstValue instanceof RegExp && firstValue.flags) {\n            return `regexp_matches(${calleeArr.slice(0, -1)}, ${args[0]}, '${firstValue?.flags}')`\n          }\n\n          return `${joinMembers(calleeArr.slice(0, -1))} ${keyword} ${args.join(joinWith)}`\n        }\n        if (lastCallee === 'as') {\n          const gargs = node.arguments.slice(1).map(transformNode)\n          return wrap(`${joinMembers(calleeArr.slice(0, -1))}::${firstValue}` + (gargs?.length ? ('(' + gargs.join(', ') + ')') : ''), '(', ')')\n        }\n\n        if (typeof calleeArr[0] === 'string' && calleeArr[0].toLowerCase() === 'cast' && node.arguments.length >= 2) {\n          const supp = args.length > 2 ? `(${node.arguments.map((e: any) => e.value).slice(2).join(', ')})` : ''\n          return `CAST(${args[0]} AS ${secValue}${supp})`\n        }\n        if (isGlobalMethod(node) && lastCallee === 'Raw') {\n          // @ts-ignore\n          return transformNode(node.arguments[0], { isFuncArg: true }).slice(1, -1)\n        }\n        if (LitteralTypesMap.has(lastCallee) && isGlobalMethod(node)) {\n          const toType = LitteralTypesMap.get(lastCallee)\n          if (toType === '') {\n            return `(${args[0]})`\n          }\n          return `CAST(${args[0]} AS ${toType})`\n        }\n        if (lastCallee === 'count' && node.arguments.length === 1 && node.arguments[0].type === 'Literal' && node.arguments[0]?.value === '*') {\n          args = ['*']\n        }\n        // console.log({ args })\n        return `${joinMembers(calleeArr)}(${args.join(', ')})`\n      },\n      UnaryExpression(node: UnaryExpression) {\n        if (node.operator === '!!') {\n          return `${transformNode(node.argument)} IS NOT NULL`\n        }\n        if (node.operator === '!' && node.argument.type === 'Literal' && typeof node.argument.value === 'number') {\n          return !node.argument.value\n        }\n        if (node.operator === '!' && node.argument.type === 'CallExpression' && node.argument.callee.type === 'MemberExpression' && node.argument.callee.property.type === 'Identifier' && node.argument.callee.property?.name === 'IsNull') {\n          return transformNode(node.argument).replace('IS NULL ', 'IS NOT NULL')\n        }\n        return `${mapUnaryOperator(node.operator)} ${transformNode(node.argument)}`\n      },\n      BinaryExpression(node: BinaryExpression) {\n        if (node.operator === '??') {\n          return `COALESCE(${transformNode(node.left)}, ${transformNode(node.right)})`\n        }\n        if (node.operator === 'in' && node.right.type === 'ArrayExpression') {\n          return `${transformNode(node.left)} IN (${node.right.elements.map(transformNode).join(', ')})`\n        }\n        // Special handling for string concatenation\n        if (node.operator === '+' && hasStringLiteral(node)) {\n          return transformStringConcat(node, transformNode)\n        }\n        if (node.operator in Σ('==', '===') && node.right.type === 'Literal' && node.right?.raw === 'null') {\n          return `${transformNode(node.left)} IS NULL`\n        }\n\n        // Regular binary operation\n        const b = `${transformNode(node.left)} ${mapOperator(node.operator)} ${transformNode(node.right)}`\n        return node.parenthesis ? `(${b})` : b\n      },\n      ArrayExpression(node: ArrayExpression) {\n        return `[${node.elements.map(transformNode).join(', ')}]`\n      },\n      SpreadElement(node: SpreadElement) {\n        return `...${transformNode(node.argument)}`\n      },\n      ConditionalExpression(node: ConditionalExpression) {\n        const getCondition = () => {\n          if (node.test.type === 'UnaryExpression' && node.test.operator === '!') {\n            return transformNode(node.test.argument) + ' IS NULL'\n          }\n          if (node.test.type in Σ('MemberExpression', 'Identifier')) {\n            return transformNode(node.test) + ' IS NOT NULL'\n          }\n          return transformNode(node.test)\n        }\n        node = node as ConditionalExpression\n        return `(CASE WHEN (${getCondition()}) THEN ${transformNode(node.consequent)} ELSE ${transformNode(node.alternate)} END)`\n      },\n      TemplateLiteral(node: TemplateLiteral) {\n        return processTemplateLiteral(node, transformNode)\n      },\n      TemplateElement(node: TemplateElement) {\n        return `'${(node as TemplateElement).value.cooked?.replaceAll(/'/g, \"''\")}'`\n      },\n      ArrowFunctionExpression(node: ArrowFunctionExpression) {\n        const closureVars = (node.params || []).map(x => (x as Identifier).name)\n        return `(${closureVars.join(', ')}) -> ${transformNode(node.body, { ...opts, closureVars })}`\n        // default:\n      },\n    }\n\n    if (!(node?.type in MapFunc)) {\n      if (context?.log !== false) {\n        console.log(JSON.stringify(node, null, 2))\n      }\n      throw new Error(`Unsupported node type: ${node.type}`)\n    }\n    // @ts-ignore\n    return MapFunc[node.type](node)\n  }\n  return transformTree(node)\n}\n\ntype DParam = { depth: number; position: number; destuctured?: boolean; excluded?: string[] }\nconst isWildcardParam = (d: DParam) => {\n  return d.depth === 0 && d.position === 0\n}\nconst extractParams = (ast: Expression) => {\n  const params = new Map<string, DParam>()\n\n  function walk(node: Expression, depth: number, position: number) {\n    if (!node || typeof node !== 'object') return\n\n    if (node.type === 'ObjectExpression') {\n      node = node as ObjectExpression\n      const excluded = node.properties.filter((e) => e.type === 'Property').map((e: Property) => e.key.name)\n      const spreadId = (node.properties.find((e) => e.type === 'SpreadElement') as SpreadElement)?.argument?.name\n      params.set(spreadId, { depth, position, destuctured: true, excluded })\n      excluded.forEach(e => params.set(e, { depth: depth + 1, position }))\n      return\n    }\n    if (node.type === 'Identifier') {\n      params.set(node.name, { depth, position })\n      return\n    }\n\n    if (Array.isArray(node)) {\n      node.forEach((e, i) => walk(e, depth + 1, i))\n      return\n    }\n\n    for (const key in node) {\n      if (key !== 'type' && typeof node[key] === 'object' && key !== 'key') {\n        walk(node[key] as unknown as Expression, depth + 1, position)\n      }\n    }\n  }\n  walk(ast, -1, 0)\n  return params\n}\n\nexport const extractParamsContext = (ast: Expression) => {\n  // if (ast.type === 'ConditionalExpression' && ast?.test?.type !== 'ArrowFunctionExpression') {\n  //   ast = ast.test\n  // }\n  if (ast.type !== 'ArrowFunctionExpression') {\n    throw new Error('AST is not an ArrowFunctionExpression')\n  }\n  return extractParams(ast.params as unknown as Expression)\n}\n\ntype Expr<T> = (d: T, z: DMetaField) => any\n\n\nexport function parse<T extends Record<string, any>>(expr: Expr<T> | string | Function, context = {}) {\n  const fnstr = typeof expr === 'string' ? expr : expr.toString()\n  const ast = jsep(fnstr) as ArrowFunctionExpression\n  const params = extractParamsContext(ast)\n  const duckdbExpr = transformDuckdb(ast.body, params, context)\n  return duckdbExpr\n}\n\nconst extractSpreadedParams = (ast: ArrowFunctionExpression) => {\n  if (ast.params === null) {\n    return { excluded: [], spreadId: undefined }\n  }\n  // console.log(\"xxx\", ast.params[0])\n  if (ast.params[0].type === 'Identifier') {\n    ast.params[0] = {\n      type: 'ObjectExpression',\n      properties: [\n        {\n          type: 'SpreadElement',\n          argument: ast.params[0],\n        },\n      ],\n    }\n  }\n  if (ast.params[0]?.type !== 'ObjectExpression') {\n    throw new Error('AST param is not an ObjectExpression (?)')\n  }\n  const excluded = ast.params[0].properties.filter((e) => e.type === 'Property').map(e => e.key.name)\n  const spreadId = ast.params[0]?.properties.find((e) => e.type === 'SpreadElement')?.argument?.name\n  return { excluded, spreadId }\n}\n\nconst handleExcluded = ({ excluded }: { excluded: string[] } & any) => {\n  return ['', '', '*' + (excluded?.length ? ` EXCLUDE(${excluded.join(', ')})` : '')]\n}\n\nexport function parseObject<T extends Record<string, any>>(expr: Expr<T> | string | Function, context = {}) {\n  const fnstr = typeof expr === 'string' ? expr : expr.toString()\n  const ast = jsep(fnstr) as ArrowFunctionExpression\n\n  const params = extractParamsContext(ast)\n  const node = ast.body\n  if (node.type === 'Literal') {\n    return [['', '', node.value]]\n  }\n  if (node.type === 'TemplateLiteral') {\n    return [['', '', transformDuckdb(node, params, context)]]\n  }\n  if (node.type === 'Identifier' && params.has(node.name)) {\n    const p = params.get(node.name)\n    // console.log(p)\n    if (p?.destuctured && p?.excluded?.length) {\n      return [handleExcluded(p)]\n    }\n    if (p?.depth === 0 && p?.position === 0) {\n      return [['', '', '*']]\n    }\n  }\n  if (node.type === 'ObjectExpression') {\n    return node.properties.map((prop: any) => {\n      // console.log('prop', prop)\n      if (prop.type === 'SpreadElement') {\n        const { excluded, spreadId } = extractSpreadedParams(ast)\n        // console.log({ excluded, spreadId })\n        if (prop.argument.name === spreadId) {\n          return handleExcluded({ excluded })\n        }\n      }\n      return [prop.key?.name, transformDuckdb(prop.value, params, context)]\n    })\n  } else if (node.type === 'CallExpression' || node.type === 'MemberExpression') {\n    const rtn = [[null, transformDuckdb(node, params, context)]]\n    return rtn\n  } else if (node.type === 'ArrayExpression') {\n    return node.elements.map((prop: any, i) => {\n      return [i, transformDuckdb(prop, params, context)]\n    })\n  } else {\n    return [['', transformDuckdb(node, params, context)]]\n  }\n}\n";export{n as default};
