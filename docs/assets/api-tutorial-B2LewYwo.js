const n="import { Buck, from } from \"@buckdb/isomorphic\";\n// import { copy } from \"../src/copy\";\n\n// const BS = Buck('s3://a1738/files')\n\n// BS.from('Stations')\n\n\nconst Akira = Buck('s3://a1738/akira09.db')\n\n\nconst r = Akira.from('Rental')\n    .join('Customer').using('customer_id')\n    .join('Address').using('address_id')\n    .join('Film').on(e => e.Rental.customer_id === e.Customer.customer_id)\n    .select(e => `${e.Customer.last_name}, ${e.Customer.first_name}`)\n    .where(e => (\n        e.Rental.rental_date !== null\n        // && e.rental_date !== e.Film.rental_duration\n    ))\n    .orderBy('title')\n    .limit(5)\n    .exec()\n\n// const respxx = await from('duckdb_functions()')\n//     .select(e => `__${e.function_name}_${e.return_type}__`)\n//     .where(e => !!e.function_name && !!e.return_type)\n//     .dump()\n//     .execute()\n\n// const rx\n//     = await Akira.from('Customer').select(e => e.Customer.active).execute()\n\n\n\n// // SELECT CONCAT(customer.last_name, ', ', customer.first_name) AS customer,\n// // address.phone, film.title\n// // FROM rental INNER JOIN customer ON rental.customer_id = customer.customer_id\n// // INNER JOIN address ON customer.address_id = address.address_id\n// // INNER JOIN inventory ON rental.inventory_id = inventory.inventory_id\n// // INNER JOIN film ON inventory.film_id = film.film_id\n// // WHERE rental.return_date IS NULL\n// // AND rental_date + INTERVAL film.rental_duration DAY < CURRENT_DATE()\n// // ORDER BY title\n// // LIMIT 5;\n// from('duckdb_functions()')\n//     .select(e => `__${e.function_name}_${e.return_type}__`)\n//     .where(e => !!e.function_name && !!e.return_type)\n//     .execute()\n\n// // .distinctOn('Address.city_id')\n\n\n\n\n// // SELECT first_name, last_name, count(*) films\n// // FROM actor AS a\n// // JOIN film_actor AS fa USING (actor_id)\n// // GROUP BY actor_id, first_name, last_name\n// // ORDER BY films DESC\n// // LIMIT 1;\n// // Actor with most films (ignoring ties)\n// const mostFilmActor =\n//     await Akira.from('Actor')\n//         .join('Film_actor').using('actor_id')\n//         .select(({ first_name, last_name }, D) => ({\n//             first_name,\n//             last_name,\n//             films: D.count('*')\n//         }))\n//         .groupBy('actor_id', 'first_name', 'last_name')\n//         .orderBy('films', 'DESC')\n//         .limit(1)\n//         .execute()\n\n// const mostFilmActor2 =\n//     await Akira.from('Actor')\n//         .join('Film_actor').using('actor_id')\n//         .select(({ first_name, last_name }, D) => [first_name, last_name, D.count()])\n//         .groupBy('ALL')\n//         .orderBy([(e, D) => D.count('*'), 'DESC'])\n//         .limit(1)\n//         .execute()\n\n\n\n// const resp =\n//     await BS.from('geo/cities.parquet').select(e => e.label_en).exec()\n\n\n// const z =\n//     await BS.from('geo/cities.parquet').select('ascii_name', 'population').exec()\n\n\n// const robj =\n//     await BS.from('geo/cities.parquet').select(e => [e.ascii_name, e.population.stats()]).exec()\n\n// // whatever\n\n// const z2 =\n//     await BS.from('geo/cities.parquet').select((e, D) => ({\n//         roundpop: `${D.round(e.population / 1000, 2)}K - ${e.ascii_name}`,\n//     }))\n//         .where(c => c.population > 1000_000 && c.timezone.match(/^Europe/m))\n//         .orderBy('population', 'DESC')\n//         .exec()\n\n\n// const rsingle =\n//     await BS.from('geo/cities.parquet')\n//         .select((e, D) => ({ name: e.cou_name_en, countx: D.count() }))\n//         .groupBy('cou_name_en')\n//         .having(x => x.countx > 1000)\n//         .exec()\n\n\n// const rarr = await BS.from('geo/cities.parquet').select('name', 'elevation', 'population', 'country_code')\n// .select()\n// .copyTo('s3://a1738/cities_parts', { partition_by: 'country_code', format: 'parquet' }).execute()\n\n\n\n// const rax =\n//     await BS.from('s3://a1738/geo/cities.parquet')\n//         .select(({ timezone, ...e }) => ({ ...e, continent: timezone.string_split('/')[0] }))\n//         .copyTo('s3://a1738/parts', { partition_by: 'continent' })\n//         .execute()\n\n// const c2 =\n//     await BS.from('geo/cities.parquet')\n//         .select((e, D) => e.alternate_names.split(',').join('|') ?? '<default>')\n//         .exec()\n\n// const c3 =\n//     await BS.from('geo/cities.parquet')\n//         .select((e, D) => ({\n//             ev: D.cast(e.elevation, 'Bigint') ?? 0,\n//             pos: e.elevation.as('Int') > 1000 ? 'hi' : 'low',\n//         }))\n//         .exec()\n";export{n as default};
