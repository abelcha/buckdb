const n="// ðŸ“Š BuckDB: Aggregations & Analytics Powerhouse\n// Transform data into insights with JavaScript-native syntax\n\nimport { MemoryDB } from '@buckdb/isomorphic'\n\n// ================================\n// ðŸŽ¯ BASIC AGGREGATIONS - Statistical insights made simple\n// ================================\n\n// Analyze DuckDB function characteristics\nconst functionStats = await MemoryDB.from('duckdb_functions()')\n    .select((f, D) => ({\n        // ðŸ”¥ Count and basic stats\n        totalFunctions: D.count(),\n        avgNameLength: D.avg(f.function_name.len()),\n        maxNameLength: D.max(f.function_name.len()),\n        minNameLength: D.min(f.function_name.len()),\n\n        // ðŸ”¥ Advanced statistical functions\n        stdDevNameLength: D.stddev(f.function_name.len()),\n        varianceNameLength: D.var_pop(f.function_name.len()),\n\n        // ðŸ”¥ String aggregations\n        longestFunctionName: D.max_by(f.function_name, f.function_name.len()),\n        shortestFunctionName: D.min_by(f.function_name, f.function_name.len()),\n\n        // ðŸ”¥ Array aggregations  \n        allFunctionTypes: D.array_agg(D.Distinct(f.function_type)),\n        sampleFunctions: D.array_agg(f.function_name),\n\n        // ðŸ”¥ Advanced calculations\n        complexityScore: D.sum(f.function_name.len() * f.parameters.len()),\n        avgComplexity: D.avg(f.function_name.len() * f.parameters.len())\n    }))\n    .execute()\n\nconsole.log('Function Statistics:', functionStats)\n\n// ================================\n// ðŸš€ GROUP BY ANALYTICS - Segment your data powerfully\n// ================================\n\n// Analyze functions by type with rich statistics\nconst functionsByType = await MemoryDB.from('duckdb_functions()')\n    .select((f, D) => ({\n        functionType: f.function_type,\n\n        // ðŸ”¥ Count and distribution\n        functionCount: D.count(),\n\n        // ðŸ”¥ Name analysis\n        avgNameLength: D.round(D.avg(f.function_name.len()), 2),\n        nameVariation: D.round(D.stddev(f.function_name.len()), 2),\n\n        // ðŸ”¥ Representative examples\n        exampleFunctions: D.array_agg(f.function_name),\n        longestName: D.max_by(f.function_name, f.function_name.len()),\n\n        // ðŸ”¥ Complexity metrics\n        totalComplexity: D.sum(f.function_name.len() + f.parameters.len()),\n        avgComplexity: D.round(D.avg(f.function_name.len() + f.parameters.len()), 2),\n\n        // ðŸ”¥ Advanced aggregations\n        distinctReturnTypes: D.count(D.Distinct(f.return_type)),\n\n        // ðŸ”¥ Conditional statistics\n        hasDocumentation: D.count().filter(!f.description.IsNull()),\n        withUnderscores: D.count().filter(f.function_name.Like('%_%'))\n    }))\n    .groupBy('function_type')\n    .having((f, D) => D.count() > 5)  // Only significant groups\n    .orderBy((f, D) => D.count(), 'DESC')\n    .execute()\n\nconsole.log('Functions by Type:', functionsByType)\n\n// ================================\n// ðŸŒŸ WINDOW FUNCTIONS - Advanced analytical operations  \n// ================================\n\n// Rank and analyze functions with window functions\nconst functionRankings = await MemoryDB.from('duckdb_functions()')\n    .select((f, D) => ({\n        functionName: f.function_name,\n        functionType: f.function_type,\n        nameLength: f.function_name.len(),\n\n        // ðŸ”¥ Ranking functions\n        overallRank: D.row_number().over().orderBy(f.function_name.len(), 'DESC'),\n        lengthRank: D.rank().over().orderBy(f.function_name.len(), 'DESC'),\n        denseRank: D.dense_rank().over().orderBy(f.function_name.len(), 'DESC'),\n\n        // ðŸ”¥ Percentile functions\n        lengthPercentile: D.percent_rank().over().orderBy(f.function_name.len()),\n        lengthQuartile: D.ntile(4).over().orderBy(f.function_name.len()),\n\n        // ðŸ”¥ Window aggregations\n        avgLengthInType: D.avg(f.function_name.len()).over().partitionBy(f.function_type),\n        maxLengthInType: D.max(f.function_name.len()).over().partitionBy(f.function_type),\n        countInType: D.count().over().partitionBy(f.function_type),\n\n        // ðŸ”¥ Lag/Lead functions\n        previousFunction: D.lag(f.function_name, 1).over().orderBy(f.function_name.len()),\n        nextFunction: D.lead(f.function_name, 1).over().orderBy(f.function_name.len()),\n\n        // ðŸ”¥ Running calculations\n        runningCount: D.count().over().orderBy(f.function_name.len()),\n        runningAvgLength: D.avg(f.function_name.len()).over().orderBy(f.function_name.len()),\n\n        // ðŸ”¥ Complex window expressions\n        lengthDifferenceFromAvg: f.function_name.len() - D.avg(f.function_name.len()).over().partitionBy(f.function_type),\n        isAboveTypeAverage: f.function_name.len() > D.avg(f.function_name.len()).over().partitionBy(f.function_type)\n    }))\n    .where(f => f.function_name.len() > 5)\n    .orderBy(f => f.function_name.len(), 'DESC')\n    .limit(25)\n    .execute()\n\nconsole.log('Function Rankings:', functionRankings)\n\n// ================================\n// ðŸŽª MULTI-LEVEL GROUPING - Hierarchical analysis\n// ================================\n\n// Multi-dimensional analysis of function characteristics\nconst hierarchicalAnalysis = await MemoryDB.from('duckdb_functions()')\n    .select((f, D) => ({\n        functionType: f.function_type,\n        returnType: f.return_type,\n        lengthCategory: f.function_name.len() < 6 ? 'Short' :\n            f.function_name.len() < 12 ? 'Medium' : 'Long',\n\n        // ðŸ”¥ Basic counts\n        functionCount: D.count(),\n\n        // ðŸ”¥ Descriptive statistics\n        avgNameLength: D.round(D.avg(f.function_name.len()), 2),\n        medianNameLength: D.median(f.function_name.len()),\n\n        // ðŸ”¥ Distribution analysis\n        minLength: D.min(f.function_name.len()),\n        maxLength: D.max(f.function_name.len()),\n        lengthRange: D.max(f.function_name.len()) - D.min(f.function_name.len()),\n\n        // ðŸ”¥ Sample data\n        exampleFunctions: D.string_agg(f.function_name, ', '),\n        representativeFunction: D.arbitrary(f.function_name),\n\n        // ðŸ”¥ Pattern detection\n        underscoreCount: D.count().filter(f.function_name.Like('%_%')),\n        numberCount: D.count().filter(f.function_name.regexp_matches('[0-9]')),\n\n        // ðŸ”¥ Conditional aggregations\n        documentedCount: D.count().filter(!f.description.IsNull()),\n\n        // ðŸ”¥ Advanced metrics\n        uniqueReturnTypes: D.count(D.Distinct(f.return_type)),\n        avgParameterCount: D.round(D.avg(f.parameters.len()), 2),\n\n        // ðŸ”¥ Complexity scoring\n        totalComplexity: D.sum(\n            f.function_name.len() +\n            f.parameters.len() * 2 +\n            (f.description.IsNull() ? 0 : f.description.len() / 10)\n        ),\n        avgComplexity: D.round(D.avg(\n            f.function_name.len() +\n            f.parameters.len() * 2 +\n            (f.description.IsNull() ? 0 : f.description.len() / 10)\n        ), 2)\n    }))\n    .groupBy('function_type', 'return_type', 'lengthCategory')\n    .having((f, D) => D.count() >= 2)\n    .orderBy([(f, D) => D.count(), 'DESC'], ['function_type', 'ASC'], ['return_type', 'ASC'])\n    .limit(30)\n    .execute()\n\nconsole.log('Hierarchical Analysis:', hierarchicalAnalysis)\n\n// ================================\n// ðŸŒŠ ADVANCED AGGREGATIONS - Custom analytical functions\n// ================================\n\n// Complex analytical operations combining multiple techniques\nconst advancedAnalytics = await MemoryDB.from('duckdb_functions()')\n    .select((f, D) => ({\n        functionType: f.function_type,\n\n        // ðŸ”¥ Advanced statistical measures\n        geometricMean: D.exp(D.avg(D.ln(f.function_name.len()))),\n        harmonicMean: D.count() / D.sum(1.0 / f.function_name.len()),\n\n        // ðŸ”¥ Distribution characteristics\n        skewness: D.skewness(f.function_name.len()),\n        kurtosis: D.kurtosis(f.function_name.len()),\n\n        // ðŸ”¥ Quantile analysis\n        q1: D.quantile_disc(f.function_name.len(), 0.25),\n        median: D.quantile_disc(f.function_name.len(), 0.5),\n        q3: D.quantile_disc(f.function_name.len(), 0.75),\n        iqr: D.quantile_disc(f.function_name.len(), 0.75) - D.quantile_disc(f.function_name.len(), 0.25),\n\n        // ðŸ”¥ Entropy and information theory\n        nameEntropy: D.entropy(f.function_name),\n        returnTypeEntropy: D.entropy(f.return_type),\n\n        // ðŸ”¥ Advanced string analytics\n        avgEditDistance: D.avg(f.function_name.levenshtein('function')),\n        maxSimilarity: D.max(f.function_name.jaro_winkler_similarity('aggregate')),\n\n        // ðŸ”¥ Pattern frequency analysis\n        vowelRatio: D.avg(D.regexp_extract_all(f.function_name, /[aeiou]/).len() / f.function_name.len()),\n        consonantRatio: D.avg(D.regexp_extract_all(f.function_name, /[bcdfghjklmnpqrstvwxyz]/).len() / f.function_name.len()),\n\n        // ðŸ”¥ Complexity distribution\n        simpleCount: D.count().filter(f.function_name.len() <= 6 && f.parameters.len() <= 2),\n        complexCount: D.count().filter(f.function_name.len() > 10 && f.parameters.len() > 3),\n\n        // ðŸ”¥ Function density analysis\n        functionDensity: D.count() / (D.max(f.function_oid) - D.min(f.function_oid) + 1),\n\n        // ðŸ”¥ Character analysis\n        avgUppercaseRatio: D.avg(D.regexp_extract_all(f.function_name, /[A-Z]/).len() / f.function_name.len()),\n        specialCharCount: D.sum(D.regexp_extract_all(f.function_name, /[^a-zA-Z0-9_]/).len()),\n\n        // ðŸ”¥ Semantic grouping\n        mathFunctions: D.count().filter(f.function_name.Like('%math%') || f.function_name.Like('%calc%')),\n        stringFunctions: D.count().filter(f.function_name.Like('%str%') || f.function_name.Like('%text%')),\n        dateFunctions: D.count().filter(f.function_name.Like('%date%') || f.function_name.Like('%time%'))\n    }))\n    .groupBy('function_type')\n    .having((f, D) => D.count() > 3)\n    .orderBy((f, D) => D.count(), 'DESC')\n    .execute()\n\nconsole.log('Advanced Analytics:', advancedAnalytics)\n\n// ================================\n// ðŸš€ ROLLING ANALYTICS - Time-series style analysis\n// ================================\n\n// Simulate time-series analysis using function_oid as a sequence\nconst rollingAnalysis = await MemoryDB.from('duckdb_functions()')\n    .select((f, D) => ({\n        functionName: f.function_name,\n        functionOid: f.function_oid,\n        nameLength: f.function_name.len(),\n\n        // ðŸ”¥ Rolling window calculations\n        rollingAvg3: D.avg(f.function_name.len()).over()\n            .orderBy(f.function_oid)\n            .rowsBetween(2, 'CURRENT ROW'),\n\n        rollingMax5: D.max(f.function_name.len()).over()\n            .orderBy(f.function_oid)\n            .rowsBetween(4, 'CURRENT ROW'),\n\n        rollingSum: D.sum(f.function_name.len()).over()\n            .orderBy(f.function_oid)\n            .rowsBetween('UNBOUNDED PRECEDING', 'CURRENT ROW'),\n\n        // ðŸ”¥ Moving statistics\n        movingStdDev: D.stddev(f.function_name.len()).over()\n            .orderBy(f.function_oid)\n            .rowsBetween(9, 'CURRENT ROW'),\n\n        movingVariance: D.var_pop(f.function_name.len()).over()\n            .orderBy(f.function_oid)\n            .rowsBetween(9, 'CURRENT ROW'),\n\n        // ðŸ”¥ Trend analysis\n        deltaFromPrevious: f.function_name.len() - D.lag(f.function_name.len(), 1).over().orderBy(f.function_oid),\n\n        deltaFromNext: D.lead(f.function_name.len(), 1).over().orderBy(f.function_oid) - f.function_name.len(),\n\n        // ðŸ”¥ Percentile tracking\n        runningPercentile: D.percent_rank().over().orderBy(f.function_name.len()),\n\n        // ðŸ”¥ Sequential patterns\n        isLocalMaxima: f.function_name.len() > D.lag(f.function_name.len(), 1).over().orderBy(f.function_oid) &&\n            f.function_name.len() > D.lead(f.function_name.len(), 1).over().orderBy(f.function_oid),\n\n        sequentialId: D.row_number().over().orderBy(f.function_oid),\n\n        // ðŸ”¥ Growth patterns\n        cumulativeComplexity: D.sum(f.function_name.len() * f.parameters.len()).over()\n            .orderBy(f.function_oid)\n            .rowsBetween('UNBOUNDED PRECEDING', 'CURRENT ROW')\n    }))\n    .where(f => f.function_oid > 0)\n    .orderBy('function_oid')\n    .limit(50)\n    .execute()\n\nconsole.log('Rolling Analysis:', rollingAnalysis)\n\n// ================================\n// ðŸŽ¯ GROUPING SETS - Advanced grouping techniques\n// ================================\n\n// Multiple grouping levels in a single query\nconst groupingSetsAnalysis = await MemoryDB.from('duckdb_functions()')\n    .select((f, D) => ({\n        functionType: f.function_type,\n        returnType: f.return_type,\n\n        // ðŸ”¥ Flexible aggregations\n        totalFunctions: D.count(),\n        avgComplexity: D.avg(f.function_name.len() + f.parameters.len()),\n        maxNameLength: D.max(f.function_name.len()),\n\n        // ðŸ”¥ Statistical measures\n        stdDevLength: D.stddev(f.function_name.len()),\n\n        // ðŸ”¥ Pattern counts\n        withUnderscores: D.count().filter(f.function_name.Like('%_%')),\n        withNumbers: D.count().filter(f.function_name.regexp_matches('[0-9]')),\n\n        // ðŸ”¥ Representative samples\n        longestFunction: D.max_by(f.function_name, f.function_name.len()),\n        mostComplex: D.max_by(f.function_name, f.function_name.len() + f.parameters.len())\n    }))\n    .groupBy('GROUPING SETS', [\n        ['function_type', 'return_type'],  // Detailed breakdown\n        ['function_type'],                 // By function type only\n        ['return_type'],                   // By return type only\n        []                                 // Grand total\n    ])\n    .orderBy(['function_type'], ['return_type'])\n    .execute()\n\nconsole.log('Grouping Sets Analysis:', groupingSetsAnalysis)\n\n/*\nðŸš€ What makes BuckDB aggregations extraordinary?\n\nâœ¨ NATURAL SYNTAX: JavaScript functions that compile to optimal SQL aggregations\nâœ¨ STATISTICAL POWER: Advanced functions like stddev, kurtosis, entropy built-in\nâœ¨ WINDOW FUNCTIONS: Powerful analytical operations with intuitive syntax\nâœ¨ FLEXIBLE GROUPING: GROUPING SETS, CUBE, ROLLUP support for complex analysis\nâœ¨ TYPE SAFETY: TypeScript knows your aggregation result types\nâœ¨ PERFORMANCE: Optimized SQL generation for maximum query efficiency\nâœ¨ COMPLEX EXPRESSIONS: Combine multiple aggregation techniques seamlessly\n\nðŸŽ¯ Next: Explore data transformations, CTEs, and advanced query patterns!\n*/\n\nconsole.log('ðŸ“Š Advanced analytics mastered!')\n";export{n as default};
