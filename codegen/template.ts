// AUTOGENERATED CODE // DONT EDIT OR TEST
import { FromPlain } from '../src/deep-map'
export const version = 'V2'
export type DBOOLEAN_NATIVE = 'Bool' | 'Boolean' | 'Logical'
export type DCOMPOSITE_NATIVE = 'List' | 'Map' | 'Row' | 'Struct' | 'Union'
export type DDATETIME_NATIVE = 'Date' | 'Datetime' | 'Interval' | 'Time' | 'Timestamp' | 'Timestamptz' | 'Timestamp_ms' | 'Timestamp_ns' | 'Timestamp_s' | 'Timestamp_us' | 'Timetz'
export type DNUMERIC_NATIVE = 'Bigint' | 'Dec' | 'Decimal' | 'Double' | 'Float' | 'Float4' | 'Float8' | 'Hugeint' | 'Int' | 'Int1' | 'Int128' | 'Int16' | 'Int2' | 'Int32' | 'Int4' | 'Int64' | 'Int8' | 'Integer' | 'Integral' | 'Long' | 'Numeric' | 'Oid' | 'Real' | 'Short' | 'Signed' | 'Smallint' | 'Tinyint' | 'Ubigint' | 'Uhugeint' | 'Uint128' | 'Uint16' | 'Uint32' | 'Uint64' | 'Uint8' | 'Uinteger' | 'Usmallint' | 'Utinyint'
export type DSTRING_NATIVE = 'Bpchar' | 'Char' | 'Nvarchar' | 'String' | 'Text' | 'Varchar' | 'JSON'
export type DANY_NATIVE = 'Binary' | 'Bit' | 'Bitstring' | 'Blob' | 'Bytea' | 'Enum' | 'Guid' | 'Null' | 'Uuid' | 'Varbinary' | 'Varint'
export type DALL_NATIVE = DBOOLEAN_NATIVE | DCOMPOSITE_NATIVE | DDATETIME_NATIVE | DNUMERIC_NATIVE | DSTRING_NATIVE | DANY_NATIVE
export type DAnyable = any | DAnyField
export type DVarcharable = string | DVarcharField
export type RegExpable = RegExp | string
export type DBoolable = boolean | DBoolField
export type DDateable = Date | DDateField
export type DArrayable = any[] | DArrayField
export type DStructable = Record<string, any> | DStructField
export type DNumericable = number | DNumericField
export type DJsonable = Record<string, any> | DJsonField
export type DField = DVarcharField | DNumericField | DDateField | DNumericField | DVarcharField | DAnyField | DArrayField | DDateField | DStructField | DBoolField | DJsonField
export declare const sId: unique symbol
export declare const sComptype: unique symbol
export declare const sAnti: unique symbol
export declare const sInferred: unique symbol

export interface DDateField extends DAnyField {
    [sInferred]: Date
    [sComptype]: Date
    /*{renderMethods({type:'DDate'})}*/
}

export interface DAny<DNum, DStr> extends Astor<DNum, DStr>, DPatternMatchers {
    /*{renderMethods({
        override:['greatest', 'least'],
        type: 'DAny', typeMap: {...gentypes }})}*/
}

export interface DAnyComp extends DAny<DNumericComp, DVarcharComp> {

}

export interface DAnyField extends DAny<DNumericField, DVarcharField> {
    [sInferred]: any
    [sComptype]: any
}

type AsComp<T> = T extends { [sComptype]: infer V } ? V : T

export interface DArrayField<T = DAnyField> extends Omit<Array<T>, 'map' | 'filter' | 'reduce'> {
    [sInferred]: T[]
    // [sComptype]: AsComp<T>[];
    [sComptype]: DArrayField<AsComp<T>>
    /*{renderMethods({
        type:'DArray',
        typeMap: { 'array': 'DArrayField<T>' },
        override: ['array_transform', 'array_filter', 'array_reduce' ,'array_slice', 'array_to_string']
    })}*/
    array_reduce<U>(lambda: (accumulator: U, currentValue: T) => U, initialValue: U): FromPlain<U>
    array_transform<U>(lambda: (x: T) => U): DArrayField<FromPlain<U>>
    array_filter(lambda: (x: T) => any): DArrayField<T>
    array_slice(begin: number, end: number, step?: number): DArrayField<FromPlain<T>>
    map: this['array_transform']
    array_to_string(sep: DVarcharable): DVarcharField


}

export interface DBoolField extends DAnyField {
    // [sInferred]: boolean
    // [sComptype]: boolean
    /*{renderMethods({type:'DBool'})}*/
}
export interface _DStructField<T = {}> {
    // [sInferred]: T
    // [sComptype]: T
    /*{renderMethods({type:'DStruct'})}*/
}
export type DStructField<T = {}> = T & _DStructField<T>

export interface DMapField {
    // [sInferred]: string;
    // [sComptype]: string;
    /*{renderMethods({type:'DMap'})}*/
}

export interface _DJsonField {
    // [sInferred]: string;
    // [sComptype]: string;
    /*{renderMethods({type:'DJson'})}*/
}
export type DJsonField = _DJsonField & Record<string, any>

export interface _DVarcharField extends DAnyField {
    // [sInferred]: string
    // [sComptype]: DVarcharComp
    /*{renderMethods({type:'DVarchar'})}*/
}
export type DVarcharField = _DVarcharField & string
export interface _DNumericField extends DAnyField {
    // [sInferred]: number
    // [sComptype]: DNumericComp
    /*{renderMethods({type:'DNumeric'})}*/
}
export type DNumericField = _DNumericField & number

export interface _DVarcharComp extends DAnyComp {
    /*{renderMethods({type:'DVarchar', typeMap: comptypes})}*/
}
export type DVarcharComp = _DVarcharComp & string

export interface _DNumericComp extends DAnyComp {
    /*{renderMethods({type:'DNumeric',  typeMap: comptypes})}*/
}
export type DNumericComp = number & _DNumericComp

export interface DAggregate<DNum, DStr> {
    /*{renderMethods({
        match: (e) => e.function_type === 'aggregate',
        typeMap: { numeric: 'DNum & { filter: (x: DAnyable) => DNum }', varchar: 'DStr & { filter: (x: DStr) => boolean }' },
        slice: 0,
        override: ['greatest', 'max','min', 'last', 'arbitrary', 'median', 'quantile_disc']
    })}*/
    greatest<X>(...vargs: X[]): FromPlain<X>;
    max<X>(...vargs: X[]): FromPlain<X>;
    median<X>(...vargs: X[]): FromPlain<X>;
    min<X>(...vargs: X[]): FromPlain<X>;
    last<X>(...vargs: X[]): FromPlain<X>;
    arbitrary<X>(...vargs: X[]): FromPlain<X>; // first
    quantile_disc(...vargs: DAnyable): DNumericField;
}

export interface DMacroAG {
    /*{renderMacros({
        match: (e) => e.macro_definition.startsWith('list_aggr'),
        slice: 0,
    })}*/
}

export interface DMacro {
    /*{renderMacros({
        match: (e) =>  !e.macro_definition.startsWith('list_aggr'),
        typeMap: { numeric: 'DNum', varchar: 'DStr' },
        slice: 0,
    })}*/
}


export interface DGlobal<DNum, DStr> {
    /*{renderMethods({
        match: (e) => e.function_type === 'scalar',
        typeMap: { numeric: 'DNum', varchar: 'DStr' },
        slice: 0,
        override: ['array_transform', 'array_filter', 'array_reduce', 'array_slice', 'array_to_string', 'greatest', 'least']
    })}*/
    // array_transform<T, U>(list: T[], lambda: (x: T) => U): DArrayField<FromPlain<U>>
    array_transform<T, U>(list: DArrayField<T> | T[], lambda: (x: FromPlain<T>) => U): DArrayField<FromPlain<U>>
    array_reduce<T, U>(list: DArrayField<T> | T[], lambda: (accumulator: U, currentValue: FromPlain<T>) => U, initialValue: U): FromPlain<U>;
    array_filter<T>(list: DArrayField<T> | T[], lambda: (x: T) => any): DArrayField<T>
    array_slice<T>(list: DArrayField<T> | T[], begin: number, end: number, step?: number): DArrayField<FromPlain<T>>
    array_to_string(arr: DArrayable, sep: DVarcharable): DVarcharField


}

export interface DTable {
    /*{renderMethods({
        match: (e) => e.function_type === 'table' && !e.function_name.match(/^(sniff_.+|read_.+|.+_scan)$/),
        slice: 0,
    })}*/
}


interface DTaggedTemplate {
    raw(strings: TemplateStringsArray, ...exprs: any[]): string;
}


export interface DKeywords<DNum, DStr> {
    Distinct<X>(val: X): X
    Raw: (val: string) => DAnyField
}

export type DKeywordsField = DKeywords<DNumericField, DVarcharField>
export type DGlobalField = DGlobal<DNumericField, DVarcharField>
// export type DGlobalComp = DGlobal<DNumericComp, DVarcharComp>

export type DAggregateField = DAggregate<DNumericField, DVarcharField>
// export type DAggregateComp = DAggregate<DNumericComp, DVarcharComp>

export type DCastorsField = DCastors<DNumericField, DVarcharField>
// export type DCastorsComp = DCastors<DNumericComp, DVarcharComp>

export type DConstructorsField = DConstructors<DNumericField, DVarcharField>
// export type DConstructorsComp = DConstructors<DNumericComp, DVarcharComp>

export type DMacroAGField = DMacroAG
export type DMacroField = DMacro

export type DMetaField = DGlobalField & DAggregateField & DConstructorsField & DGlobalPatternMatchers & DCastorsField & DMacroField & DMacroAGField & DKeywordsField & DTaggedTemplate
// export type DMetaComp = DGlobalComp & DAggregateComp & DConstructorsComp & DGlobalPatternMatchers & DCastorsComp



export interface DConstructors<DNum, DStr> {
    /**@example: Array(val)      @external: Array(val:OTHER) -> ARRAY*/
    Array<T = DAnyable>(val: T[]): DArrayField<FromPlain<T>>
    /**@example: Json(val)       @external: Json(val:OTHER) -> JSON*/
    Json(val: any): DJsonField
    /**@example: List(val)       @external: List(val:OTHER) -> LIST*/
    Struct<T extends {}>(val: DStructField<T> | T): DStructField<FromPlain<T>>
    /**@example: Time(val)       @external: Time(val:OTHER) -> TIME*/
    List: this['Array']
    /**@example: Map(val)        @external: Map(val:OTHER) -> MAP*/
    Map(val: DAnyable): DAnyComp
    /**@example: Bigint(val)     @external: Bigint(val:OTHER) -> BIGINT*/
    Bigint(val: DAnyable): DNum
    /**@example: Bit(val)        @external: Bit(val:OTHER) -> BIT*/
    Bit(val: DAnyable): DAnyComp
    /**@example: Blob(val)       @external: Blob(val:OTHER) -> BLOB*/
    Blob(val: DAnyable): DAnyComp
    /**@example: Boolean(val)    @external: Boolean(val:OTHER) -> BOOLEAN*/
    Boolean(val: DAnyable): DBoolField
    /**@example: Date(val)       @external: Date(val:OTHER) -> DATE*/
    Date(val: DAnyable): DDateField
    /**@example: Decimal(val)    @external: Decimal(val:OTHER) -> DECIMAL*/
    Decimal(val: DAnyable): DNum
    /**@example: Double(val)     @external: Double(val:OTHER) -> DOUBLE*/
    Double(val: DAnyable): DNum
    /**@example: Enum(val)       @external: Enum(val:OTHER) -> ENUM*/
    Enum(val: DAnyable): DAnyComp
    /**@example: Float(val)      @external: Float(val:OTHER) -> FLOAT*/
    Float(val: DAnyable): DNum
    /**@example: Hugeint(val)    @external: Hugeint(val:OTHER) -> HUGEINT*/
    Hugeint(val: DAnyable): DNum
    /**@example: Integer(val)    @external: Integer(val:OTHER) -> INTEGER*/
    Integer(val: DAnyable): DNum
    /**@example: Interval(val)   @external: Interval(val:OTHER) -> INTERVAL*/
    Interval(val: DAnyable): DAnyComp
    /**@example: Null(val)       @external: Null(val:OTHER) -> NULL*/
    Null(val: DAnyable): DAnyComp
    /**@example: Smallint(val)   @external: Smallint(val:OTHER) -> SMALLINT*/
    Smallint(val: DAnyable): DNum
    /**@example: Struct(val)     @external: Struct(val:OTHER) -> STRUCT*/
    Time(val: DAnyable): DDateField
    /**@example: Timestamp(val)  @external: Timestamp(val:OTHER) -> TIMESTAMP*/
    Timestamp(val: DAnyable): DDateField
    /**@example: Timestamp_ms(val)       @external: Timestamp_ms(val:OTHER) -> TIMESTAMP_MS*/
    Timestamp_ms(val: DAnyable): DDateField
    /**@example: Timestamp_ns(val)       @external: Timestamp_ns(val:OTHER) -> TIMESTAMP_NS*/
    Timestamp_ns(val: DAnyable): DDateField
    /**@example: Timestamp_s(val)        @external: Timestamp_s(val:OTHER) -> TIMESTAMP_S*/
    Timestamp_s(val: DAnyable): DDateField
    /**@example: Tinyint(val)    @external: Tinyint(val:OTHER) -> TINYINT*/
    Tinyint(val: DAnyable): DNum
    /**@example: Ubigint(val)    @external: Ubigint(val:OTHER) -> UBIGINT*/
    Ubigint(val: DAnyable): DNum
    /**@example: Uhugeint(val)   @external: Uhugeint(val:OTHER) -> UHUGEINT*/
    Uhugeint(val: DAnyable): DNum
    /**@example: Uinteger(val)   @external: Uinteger(val:OTHER) -> UINTEGER*/
    Uinteger(val: DAnyable): DNum
    /**@example: Union(val)      @external: Union(val:OTHER) -> UNION*/
    Union(val: DAnyable): DAnyComp
    /**@example: Usmallint(val)  @external: Usmallint(val:OTHER) -> USMALLINT*/
    Usmallint(val: DAnyable): DNum
    /**@example: Utinyint(val)   @external: Utinyint(val:OTHER) -> UTINYINT*/
    Utinyint(val: DAnyable): DNum
    /**@example: Uuid(val)       @external: Uuid(val:OTHER) -> UUID*/
    Uuid(val: DAnyable): DAnyComp
    /**@example: Varchar(val)    @external: Varchar(val:OTHER) -> VARCHAR*/
    Varchar(val: DAnyable): DStr
    /**@example: Varint(val)     @external: Varint(val:OTHER) -> VARINT*/
    Varint(val: DAnyable): DNum
}

export interface DCastors<DNum, DStr> {
    cast(val: DAnyable, destype: DBOOLEAN_NATIVE, ...args: DAnyable[]): DBoolField
    cast(val: DAnyable, destype: DCOMPOSITE_NATIVE, ...args: DAnyable[]): DAnyField
    cast(val: DAnyable, destype: DDATETIME_NATIVE, ...args: DAnyable[]): DDateField
    cast(val: DAnyable, destype: DNUMERIC_NATIVE, ...args: DAnyable[]): DNum
    cast(val: DAnyable, destype: DSTRING_NATIVE, ...args: DAnyable[]): DStr
    cast(val: DAnyable, destype: DANY_NATIVE, ...args: DAnyable[]): DAnyField
}

export interface Astor<DNum, DStr> {
    as(destype: DBOOLEAN_NATIVE, ...args: DAnyable[]): DBoolField
    as(destype: DCOMPOSITE_NATIVE, ...args: DAnyable[]): this
    as(destype: DDATETIME_NATIVE, ...args: DAnyable[]): DDateField
    as(destype: DNUMERIC_NATIVE, ...args: DAnyable[]): DNum
    as(destype: DSTRING_NATIVE, ...args: DAnyable[]): DStr
    as(destype: DANY_NATIVE, ...args: DAnyable[]): this
}

export interface DPatternMatchers {
    /**@example: Ilike(val, matcher)     @external: Ilike(val:VARCHAR, matcher:ANY) -> BOOLEAN*/
    Ilike(matcher: DAnyable): DBoolField
    /**@example: In(val, matcher)        @external: In(val:VARCHAR, matcher:ANY) -> BOOLEAN*/
    In(matcher: DAnyable): DBoolField
    /**@example: Like(val, matcher)      @external: Like(val:VARCHAR, matcher:ANY) -> BOOLEAN*/
    Like(matcher: DAnyable): DBoolField
    /**@example: IsNull(val)     @external: IsNull(val:ANY) -> BOOLEAN*/
    IsNull(): DBoolField
    /**@example: Between(val, col1, col2)        @external: Between(val:INT, col1:INT, col2:INT) -> BOOLEAN*/
    Between(col1: DNumericable, col2: DNumericable): DBoolField
    /**@example: NotBetween(val, col1, col2)     @external: NotBetween(val:INT, col1:INT, col2:INT) -> BOOLEAN*/
    NotBetween(col1: DNumericable, col2: DNumericable): DBoolField
    /**@example: SimilarTo(val, matcher) @external: SimilarTo(val:VARCHAR, matcher:ANY) -> BOOLEAN*/
    SimilarTo(matcher: DAnyable): DBoolField
    /**@example: Glob(val, matcher)      @external: Glob(val:VARCHAR, matcher:ANY) -> BOOLEAN*/
    Glob(matcher: DAnyable): DBoolField
}

export interface DGlobalPatternMatchers {
    /**@example: Ilike(val, matcher)     @external: Ilike(val:VARCHAR, matcher:ANY) -> BOOLEAN*/
    Ilike(item: DAnyable, matcher: DAnyable): DBoolField
    /**@example: In(val, matcher)        @external: In(val:VARCHAR, matcher:ANY) -> BOOLEAN*/
    In(item: DAnyable, matcher: DAnyable): DBoolField
    /**@example: Like(val, matcher)      @external: Like(val:VARCHAR, matcher:ANY) -> BOOLEAN*/
    Like(item: DAnyable, matcher: DAnyable): DBoolField
    /**@example: IsNull(val)     @external: IsNull(val:ANY) -> BOOLEAN*/
    IsNull(item: DAnyable): DBoolField
    /**@example: Between(val, col1, col2)        @external: Between(val:INT, col1:INT, col2:INT) -> BOOLEAN*/
    Between(item: DAnyable, col1: DNumericable, col2: DNumericable): DBoolField
    /**@example: NotBetween(val, col1, col2)     @external: NotBetween(val:INT, col1:INT, col2:INT) -> BOOLEAN*/
    NotBetween(item: DAnyable, col1: DNumericable, col2: DNumericable): DBoolField
    /**@example: SimilarTo(val, matcher) @external: SimilarTo(val:VARCHAR, matcher:ANY) -> BOOLEAN*/
    SimilarTo(item: DAnyable, matcher: DAnyable): DBoolField
    /**@example: Glob(val, matcher)      @external: Glob(val:VARCHAR, matcher:ANY) -> BOOLEAN*/
    Glob(item: DAnyable, matcher: DAnyable): DBoolField
}

export interface DSettings {
    /*{
    generateSettings({
        access_mode: "'AUTOMATIC' | 'READ_ONLY' | 'READ_WRITE'"
    })
    }*/

}



export type DExtensions = /*{duckdb_extensions.map(e => `'${e}'`).join(' | ')}*/ | string | {}
