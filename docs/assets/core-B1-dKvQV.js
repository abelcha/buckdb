const n="import { DSettings } from './.buck/types'\nimport { formatSource } from './src/formalise'\nimport { parse, parseObject } from './src/parser'\nimport { deriveName } from './src/utils'\n\nexport type DuckdbCon = {\n    type: 'wasm' | 'node' | 'remote'\n    isBucket?: boolean\n    handle?: string | null\n    queue: CommandQueue\n    run: (sql: string) => Promise<any>\n    getSchemaUri: (model: string) => string\n    lazyAttach: (path: string, alias: string, options?: { readonly: boolean }) => any\n    ensureSchema: (uri: string) => Promise<any>\n    describe: (uri: string) => Promise<Record<string, any>>\n    query: (sql: string, opts?: Record<string, any>) => Promise<any[]>\n    lazySettings: (s: Partial<DSettings>) => DuckdbCon\n    lazyMacros: (s: Record<string, (...args: any[]) => any>) => DuckdbCon\n    lazyExtensions: (...extensions: string[]) => DuckdbCon\n}\n\nexport abstract class BuckDBBase implements DuckdbCon {\n    abstract readonly type: 'wasm' | 'node' | 'remote'\n    abstract query(sql: string, opts?: Record<string, any>): Promise<any[]>\n    abstract run(sql: string): Promise<any>\n    abstract ensureSchema(uri: string): Promise<any>\n    readonly queue = new CommandQueue()\n\n    constructor(\n        public handle?: string,\n        public settings?: Record<string, any>,\n    ) { }\n    getSchemaUri(s: string) {\n        const [_, fnname, params] = s.match(/(\\w+)\\((.+)\\)/) || []\n        if (fnname) {\n            return `${fnname}()`\n        }\n        return s\n        // console.log({ s, match })\n    }\n    lazyMacros(s: any) {\n        this.queue.pushMacros(s)\n        return this\n    }\n\n    lazySettings(s: Partial<DSettings>) {\n        this.queue.pushSettings(s)\n        return this\n    }\n\n    lazyAttach(uri: string, alias?: string, options?: { readonly: boolean }) {\n        this.queue.pushAttach(uri, alias || deriveName(uri), options)\n        return this\n    }\n\n    lazyExtensions(...extensions: string[]) {\n        this.queue.pushExtensions(...extensions)\n        return this\n    }\n\n    async describe(uri: string) {\n        return this.query(`DESCRIBE FROM ${formatSource({ catalog: this.handle, uri })};`)\n    }\n}\n\nexport class CommandQueue {\n    constructor() {\n        this.queue = []\n    }\n    usedDB: string | null = null\n    queue: string[]\n\n    getUsedDB() {\n        if (!this.usedDB) {\n            return ''\n        }\n        return `USE ${this.usedDB};`\n    }\n\n    pushMacros(macros: () => Record<string, (args: any) => any>) {\n        const rrr = parseObject(macros)\n            .map(([name, fn]) => `CREATE OR REPLACE MACRO ${name}${fn.replace('->', 'AS')};`)\n        this.queue.push(...rrr)\n        return this\n    }\n    pushSettings(settings: Partial<DSettings> = {}) {\n        const sts = Object.entries(settings).map(([key, value]) => `SET ${key} = '${value}'`)\n        if (sts.length) {\n            this.queue.push(sts.join('; '))\n        }\n        return this\n    }\n    pushAttach(path: string, alias: string, options?: { readonly: boolean }) {\n        const opts = options?.readonly ? '(READONLY)' : ''\n        this.queue.push(`ATTACH IF NOT EXISTS '${path}' AS ${alias} ${opts}`, `USE ${alias}`)\n        this.usedDB = alias\n        return this\n    }\n    pushExtensions(...extensions: string[]) {\n        const officialExtensions = [\n            'arrow',\n            'autocomplete',\n            'avro',\n            'aws',\n            'azure',\n            'core_functions',\n            'delta',\n            'excel',\n            'ducklake',\n            'fts',\n            'h3',\n            'httpfs',\n            'iceberg',\n            'icu',\n            'inet',\n            'jemalloc',\n            'json',\n            'motherduck',\n            'mysql_scanner',\n            'parquet',\n            'postgres_scanner',\n            'spatial',\n            'sqlite_scanner',\n            'tpcds',\n            'tpch',\n            'ui',\n            'vss',\n        ]\n        const brokenExt = ['wireduck', 'vortex', 'tarfs', 'scrooge', 'redis', 'quackformers', 'pyroscope', 'pcap_reader', 'parser_tools', 'ofquack', 'nanodbc', 'nanoarrow', 'msolap', 'httpfs', 'hdf5']\n        this.queue.push(...extensions.filter(e => !brokenExt.includes(e)).map(e => `INSTALL '${e}' ${!officialExtensions.includes(e) ? 'FROM community' : ''};LOAD '${e}';`))\n        return this\n    }\n    flush() {\n        const s = this.queue\n        this.queue = []\n        return s\n    }\n}\n";export{n as default};
