const e="import { DCondition, DCte, DDatasource, DOrder, DSelectee, DState } from './typedef'\nimport { copy } from './copy'\nimport { parse } from './parser'\nimport { isBucket, wrap, isFile, isFunction, maxBy } from './utils'\nimport { highlightSql } from './highlighter'\n\nexport const formatSource = ({ catalog = '', uri = '' }) => {\n    if (!isFunction(uri)) {\n        if (isBucket(catalog) && uri.match(/[^\\w]/) && !uri.includes('://')) {\n            uri = catalog.replace(/\\/*$/, '') + '/' + uri\n        }\n        if (isFile(uri)) {\n            uri = `'${uri}'`\n        }\n\n    }\n\n    if (isBucket(catalog)) {\n        // todo make the pr ob duckdb\n        return uri.replaceAll(/\\'([^\\/][^\\'\\:]+\\.\\w{3,12})\\'/g, `'${catalog}/$1'`)\n    }\n    return uri\n}\n\nexport function toSql(state: DState & { trim?: boolean, minTrim?: number }) {\n    const CR = state.trim ? '' : '\\n'\n    const CRW = state.trim ? ' ' : '\\n '\n    const CRT = state.trim ? ' ' : '\\n\\t'\n\n\n\n\n    const serializeTuple = (id: string, opts: Record<string, any> = {}) => (p: string[]) => {\n        if (!p.length) {\n            return ''\n        }\n        if (p.length === 1 && !opts.forceParent) {\n            return `${id} ${p[0]}`\n        }\n        return `${id} (${p.join(', ')})`\n    }\n    const serializeValue = (id: string) => (p: any) => p !== null ? `${id} ${p}` : ''\n\n    const serializeConditions = (id = 'WHERE') => (conditions: DCondition[]) => {\n        return conditions.map((e, i) => {\n            const prefix = i === 0 ? id : (e.operator || 'AND')\n            return `${prefix} (${e.condition})`\n        }).join(' ')\n    }\n    const serializeOrder = (id: string) => (orders: DOrder[]) => {\n        if (!orders.length) return ''\n        const m = orders.map((e, i) => {\n            // const prefix = i === 0 ? id : (e.direction)\n            return `${e.field} ${e.direction || ''}`.trim()\n        })\n        return m.length ? `${id} ${m.join(', ')}` : ''\n    }\n\n    const formatAlias = (source: { alias?: string; uri: string }) => {\n        if (source.alias) {\n            // return `${formatSource(source)} AS ${source.alias}`\n            return `${formatSource(source)} AS ${source.alias}`\n        }\n        return formatSource(source)\n    }\n    const formatAs = (source: DSelectee, maxLen = 100) => {\n        if (source.as && typeof source.as === 'string') {\n            return `${(source.as + ':').padEnd(maxLen)} ${source.field.toString()}`\n        }\n        return source.field\n    }\n\n    const wrapIfNotEmpty = (value: string) => value ? `(${value})` : ''\n    const serializeDatasource = (datasources: DDatasource[]) => {\n        return datasources.map((d) => {\n            const getJointure = (d: DDatasource): string => {\n                if (d.using && d.join === 'CROSS JOIN') {\n                    return ` AS ${d.using}`\n                }\n                if (d.joinOn) return `ON (${d.joinOn})`;\n                if (d.using) return `USING (${d.using})`;\n                return '';\n            };\n            const jointure = getJointure(d);\n            if (d.join) {\n                return `${d.join} ${formatAlias(d)} ${jointure}`.trim();\n            }\n\n            return formatAlias(d);\n        }).join(CRW)\n    }\n    const serializeSelected = (selected: DSelectee[]) => {\n        // console.log('SERIALIZE SELECTED', selected)\n        if (!selected.length) {\n            return '*'\n        }\n        const maxLen = Math.max(...selected.map(e => (e.as || e.field).toString()?.length))\n        // if (selected[0].raw) {\n        //     const [e, ...rest] = selected\n        //     return [e.raw, ...rest.map(e => `${CRT}${formatAs(e, maxLen)}`)].join(',')\n        // }\n        const m = selected.map(e => e.raw || `${CRT}${formatAs(e, maxLen)}`)\n        // console.log({ m })\n        return m.join(',')\n        // return prettifyPrintSQL(selected.map(([v, k]) => !k?.match(/[^\\d]/) ? v : `${v} AS ${k}`).join(\", \") || \"*\", pretty);\n    }\n\n    const serializeUpdated = (updated: DSelectee[]) => {\n        return updated.map(e => ` ${e.as} = ${e.raw ? wrap(e.raw, \"'\") : e.field}`).join(`,${CRW}`)\n    }\n\n    function serializeSetops(setops: { type: string; value: string }[], opts: { trim?: boolean } = {}) {\n        return setops.map(e => `${CR}${e.type}${CRW}(${e.value})`)\n    }\n\n    function serializeCte(e: DCte) {\n        const q = e.query.toSql({ false: true, minTrim: 50 })\n        return `${CRW}${e.name} AS (${q > 50 ? `${CR}${q}${CR}` : q})`\n    }\n    function serializeCtes(ctes: DCte[]) {\n        if (!ctes.length)\n            return ''\n        return `WITH ${ctes.map(serializeCte).join(', ')}${CR}`\n\n    }\n    if (state.action === 'update') {\n        // return `UPDATE ${state.table} SET ${serializeUpdates(state.updated)} WHERE ${serializeConditions('WHERE')(state.conditions)}`\n        return [\n            'UPDATE',\n            serializeDatasource(state.datasources),\n            'SET',\n            CR,\n            serializeUpdated(state.updated),\n            CR,\n            serializeConditions('WHERE')(state.conditions),\n        ].filter(Boolean).join(' ')\n    }\n\n    let components = [\n        serializeCtes(state.ctes),\n        'FROM ' + serializeDatasource(state.datasources),\n        'SELECT ' + serializeTuple('DISTINCT ON', { forceParent: true })(state.distinctOn),\n        serializeSelected(state.selected),\n        serializeConditions('WHERE')(state.conditions),\n        serializeTuple('GROUP BY')(state.groupBy),\n        serializeConditions('HAVING')(state.having),\n        serializeValue('USING SAMPLE')(state.sample),\n        serializeOrder('ORDER BY')(state.orderBy),\n        serializeValue('LIMIT')(state.limit),\n        serializeValue('OFFSET')(state.offset),\n    ].filter(Boolean)\n    if (state.setops.length) {\n        components = ['FROM (', ...components, ')'].concat(...serializeSetops(state.setops, state))\n    }\n\n    const comps = components.join(CRW).trim()\n    if (state.copyTo.length) {\n        return copy(comps).to(state.copyTo[0].uri, state.copyTo[0].options).toSql(state)\n    }\n    // if (state.trim && (!state.minTrim || comps.length < state.minTrim)) {\n    //     return comps.replace(/(\\s|\\n)+/g, '$1').trim()\n    // }\n    return comps\n}\n\n\n\nconst createSerialize = (table: string, ex: string, opts: Record<string, any> = {}) => {\n    if (table.match(/\\.(.sv|json*|parquet)$/)) {\n        return `COPY (${ex}) TO '${table}'`\n    }\n    return [\n        'CREATE',\n        opts.replace ? 'OR REPLACE' : '',\n        'TABLE',\n        opts.ifNotExists ? 'IF NOT EXISTS' : '',\n        table,\n        'AS',\n        ex,\n    ].filter(Boolean).join(' ')\n}\n\nexport const serializeCreate = (table: string, items: any[], opts: Record<string, any> = {}) => {\n    if (items.length === 1 && Array.isArray(items[0])) {\n        items = items[0]\n    }\n    if (items[0]?.toSql) {\n        return createSerialize(table, items[0]?.toSql(), opts)\n    }\n    const tempname = 'tmp_' + Math.random() / 1e-18\n    return [\n        `CREATE TEMP TABLE ${tempname} (j JSON)`,\n        `INSERT INTO ${tempname} VALUES ${items.map(it => `('${JSON.stringify(it)}')`).join(',\\n')}`,\n        'SET variable S = ' + wrap(`select json_group_structure(j)::varchar from ${tempname}`, '(', ')'),\n        createSerialize(table, \"SELECT UNNEST(json_transform(j, getvariable('S'))) FROM \" + tempname, opts),\n    ].join(';\\n')\n}\n\n\nexport const dump = (state: DState, opts?: { state?: boolean }) => {\n    console.log(highlightSql(toSql(state)))\n    if (opts?.state) {\n        console.log(state)\n    }\n    return false\n}\n\nexport const formalize = (e: string | Function, context = {}) => typeof e === 'function' ? parse(e, context) : e\n";export{e as default};
